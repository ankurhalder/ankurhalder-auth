================================================================================
COMPLETE CODEBASE
================================================================================
Generated: 2026-02-14T12:00:09.597Z
Project: auth
Total Files: 99
================================================================================

================================================================================
DIRECTORY STRUCTURE
================================================================================

auth/
├── app
│   ├── api
│   │   ├── .well-known
│   │   │   └── jwks.json
│   │   │       └── route.ts
│   │   ├── auth
│   │   │   ├── forgot-password
│   │   │   │   └── route.ts
│   │   │   ├── logout
│   │   │   │   └── route.ts
│   │   │   ├── logout-all
│   │   │   │   └── route.ts
│   │   │   ├── me
│   │   │   │   └── route.ts
│   │   │   ├── refresh
│   │   │   │   └── route.ts
│   │   │   ├── resend-verification
│   │   │   │   └── route.ts
│   │   │   ├── reset-password
│   │   │   │   └── route.ts
│   │   │   ├── signin
│   │   │   │   └── route.ts
│   │   │   ├── signup
│   │   │   │   └── route.ts
│   │   │   ├── verify-email
│   │   │   │   └── route.ts
│   │   │   └── verify-otp
│   │   │       └── route.ts
│   │   ├── cron
│   │   │   └── cleanup
│   │   │       └── route.ts
│   │   └── health
│   │       └── route.ts
│   ├── layout.tsx
│   └── page.tsx
├── docs
│   ├── architecture.md
│   ├── dependency-rule.md
│   ├── development.md
│   ├── enforcement.md
│   ├── features.md
│   ├── infrastructure.md
│   └── request-flow.md
├── eslint.config.mjs
├── next-env.d.ts
├── next.config.ts
├── package.json
├── postcss.config.mjs
├── public
├── README.md
├── scripts
│   ├── crawl-project.js
│   ├── pre-commit.js
│   ├── remove_comments.js
│   └── version-increment.js
├── src
│   ├── application
│   │   ├── dtos
│   │   │   ├── auth.dto.ts
│   │   │   └── user.dto.ts
│   │   ├── interfaces
│   │   │   ├── email.provider.ts
│   │   │   ├── revocation.store.ts
│   │   │   └── token.service.ts
│   │   └── use-cases
│   │       ├── forgot-password.use-case.ts
│   │       ├── get-current-user.use-case.ts
│   │       ├── global-logout.use-case.ts
│   │       ├── logout.use-case.ts
│   │       ├── refresh-token.use-case.ts
│   │       ├── resend-verification.use-case.ts
│   │       ├── reset-password.use-case.ts
│   │       ├── signin.use-case.ts
│   │       ├── signup.use-case.ts
│   │       ├── verify-email.use-case.ts
│   │       └── verify-otp.use-case.ts
│   ├── domain
│   │   ├── entities
│   │   │   ├── auth-event.entity.ts
│   │   │   ├── session.entity.ts
│   │   │   └── user.entity.ts
│   │   ├── errors
│   │   │   ├── authentication.error.ts
│   │   │   ├── authorization.error.ts
│   │   │   ├── base.error.ts
│   │   │   ├── conflict.error.ts
│   │   │   ├── not-found.error.ts
│   │   │   ├── rate-limit.error.ts
│   │   │   ├── token.error.ts
│   │   │   └── validation.error.ts
│   │   ├── index.ts
│   │   ├── repositories
│   │   │   ├── auth-event.repository.ts
│   │   │   ├── session.repository.ts
│   │   │   └── user.repository.ts
│   │   └── value-objects
│   │       ├── email.vo.ts
│   │       ├── hashed-password.vo.ts
│   │       ├── jti.vo.ts
│   │       ├── session-id.vo.ts
│   │       └── token-version.vo.ts
│   ├── env.ts
│   ├── infrastructure
│   │   ├── crypto
│   │   │   ├── hash.ts
│   │   │   ├── jwks.ts
│   │   │   ├── jwt.service.ts
│   │   │   ├── otp.service.ts
│   │   │   └── password.service.ts
│   │   ├── database
│   │   │   ├── auth-event.repository.impl.ts
│   │   │   ├── connection.ts
│   │   │   ├── indexes.ts
│   │   │   ├── schemas
│   │   │   │   ├── auth-event.schema.ts
│   │   │   │   ├── session.schema.ts
│   │   │   │   └── user.schema.ts
│   │   │   ├── session.repository.impl.ts
│   │   │   └── user.repository.impl.ts
│   │   ├── email
│   │   │   └── brevo.provider.ts
│   │   └── redis
│   │       ├── client.ts
│   │       ├── otp-rate-limiter.ts
│   │       ├── revocation.store.impl.ts
│   │       └── simple-lru.ts
│   ├── instrumentation.ts
│   └── presentation
│       ├── helpers
│       │   ├── cookies.ts
│       │   ├── request-context.ts
│       │   └── response.ts
│       ├── middleware
│       │   ├── auth.ts
│       │   ├── cors.ts
│       │   ├── csrf.ts
│       │   └── rate-limit.ts
│       └── validation
│           └── schemas.ts
├── tsconfig.json
└── vercel.json


================================================================================
FILE CONTENTS
================================================================================

--------------------------------------------------------------------------------
File: app\api\.well-known\jwks.json\route.ts
--------------------------------------------------------------------------------

import { NextResponse } from "next/server";
import { JwtServiceImpl } from "@infra/crypto/jwt.service";

const tokenService = new JwtServiceImpl();

export async function GET(): Promise<NextResponse> {
  try {
    const jwks = await tokenService.getJwksData();

    return NextResponse.json(jwks, {
      status: 200,
      headers: {
        "Cache-Control": "public, max-age=86400, s-maxage=86400",
        "Access-Control-Allow-Origin": "*",
      },
    });
  } catch (error) {
    console.error(
      "[JWKS] Failed to generate JWKS:",
      error instanceof Error ? error.message : "Unknown error"
    );
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    );
  }
}


--------------------------------------------------------------------------------
File: app\api\auth\forgot-password\route.ts
--------------------------------------------------------------------------------

import { type NextRequest } from "next/server";
import { ForgotPasswordUseCase } from "@/application/use-cases/forgot-password.use-case";
import { UserRepositoryImpl } from "@/infrastructure/database/user.repository.impl";
import { BrevoEmailProvider } from "@/infrastructure/email/brevo.provider";
import { AuthEventRepositoryImpl } from "@/infrastructure/database/auth-event.repository.impl";
import { withCors } from "@/presentation/middleware/cors";
import { withRateLimit } from "@/presentation/middleware/rate-limit";
import {
  errorResponse,
  successResponse,
} from "@/presentation/helpers/response";
import { buildRequestContext } from "@/presentation/helpers/request-context";
import { ForgotPasswordSchema } from "@/presentation/validation/schemas";
import { ValidationError } from "@/domain/errors/validation.error";

async function forgotPasswordHandler(request: NextRequest): Promise<Response> {
  const context = buildRequestContext(request);

  try {
    const body = await request.json();

    const validationResult = ForgotPasswordSchema.safeParse(body);
    if (!validationResult.success) {
      const fields = validationResult.error.errors.reduce(
        (acc, err) => {
          const path = err.path.join(".");
          acc[path] = err.message;
          return acc;
        },
        {} as Record<string, string>
      );

      throw new ValidationError("Invalid email", fields);
    }

    const { email } = validationResult.data;

    const userRepository = new UserRepositoryImpl();
    const authEventRepository = new AuthEventRepositoryImpl();
    const emailProvider = new BrevoEmailProvider();

    const forgotPasswordUseCase = new ForgotPasswordUseCase(
      userRepository,
      authEventRepository,
      emailProvider
    );

    await forgotPasswordUseCase.execute({ email }, context);

    return successResponse(
      {
        message:
          "If an account exists with this email, a password reset link has been sent.",
      },
      200
    );
  } catch (error) {
    return errorResponse(
      error instanceof Error ? error : new Error(String(error)),
      context.requestId
    );
  }
}

export const POST = withCors(withRateLimit(3, 3600)(forgotPasswordHandler));


--------------------------------------------------------------------------------
File: app\api\auth\logout\route.ts
--------------------------------------------------------------------------------

import { type NextRequest } from "next/server";
import { LogoutUseCase } from "@/application/use-cases/logout.use-case";
import { SessionRepositoryImpl } from "@/infrastructure/database/session.repository.impl";
import { RevocationStoreImpl } from "@/infrastructure/redis/revocation.store.impl";
import { AuthEventRepositoryImpl } from "@/infrastructure/database/auth-event.repository.impl";
import { JwtServiceImpl } from "@/infrastructure/crypto/jwt.service";
import { withCors } from "@/presentation/middleware/cors";
import { withAuth } from "@/presentation/middleware/auth";
import {
  errorResponse,
  successResponse,
} from "@/presentation/helpers/response";
import { buildRequestContext } from "@/presentation/helpers/request-context";
import { clearAuthCookies } from "@/presentation/helpers/cookies";
import { AuthenticationError } from "@/domain/errors/authentication.error";

async function logoutHandler(
  request: NextRequest,
  authContext: { userId: string }
): Promise<Response> {
  const context = buildRequestContext(request);

  try {
    const authHeader = request.headers.get("authorization");
    const accessToken = authHeader?.substring(7) || "";

    const jwtService = new JwtServiceImpl();
    const payload = await jwtService.verifyAccessToken(accessToken);

    if (!payload || !payload.sessionId) {
      throw new AuthenticationError("Invalid access token");
    }

    const sessionRepository = new SessionRepositoryImpl();
    const authEventRepository = new AuthEventRepositoryImpl();
    const revocationStore = new RevocationStoreImpl();

    const logoutUseCase = new LogoutUseCase(
      sessionRepository,
      authEventRepository,
      revocationStore
    );

    await logoutUseCase.execute(
      {
        userId: authContext.userId,
        sessionId: payload.sessionId,
      },
      context
    );

    const response = successResponse(
      {
        message: "Logout successful",
      },
      200
    );

    clearAuthCookies(response);

    return response;
  } catch (error) {
    return errorResponse(
      error instanceof Error ? error : new Error(String(error)),
      context.requestId
    );
  }
}

export const POST = withCors(withAuth("user")(logoutHandler));


--------------------------------------------------------------------------------
File: app\api\auth\logout-all\route.ts
--------------------------------------------------------------------------------

import { type NextRequest } from "next/server";
import { GlobalLogoutUseCase } from "@/application/use-cases/global-logout.use-case";
import { UserRepositoryImpl } from "@/infrastructure/database/user.repository.impl";
import { SessionRepositoryImpl } from "@/infrastructure/database/session.repository.impl";
import { AuthEventRepositoryImpl } from "@/infrastructure/database/auth-event.repository.impl";
import { RevocationStoreImpl } from "@/infrastructure/redis/revocation.store.impl";
import { withCors } from "@/presentation/middleware/cors";
import { withAuth } from "@/presentation/middleware/auth";
import {
  errorResponse,
  successResponse,
} from "@/presentation/helpers/response";
import { buildRequestContext } from "@/presentation/helpers/request-context";
import { clearAuthCookies } from "@/presentation/helpers/cookies";

async function logoutAllHandler(
  request: NextRequest,
  authContext: { userId: string }
): Promise<Response> {
  const context = buildRequestContext(request);

  try {
    const userRepository = new UserRepositoryImpl();
    const sessionRepository = new SessionRepositoryImpl();
    const authEventRepository = new AuthEventRepositoryImpl();
    const revocationStore = new RevocationStoreImpl();

    const globalLogoutUseCase = new GlobalLogoutUseCase(
      userRepository,
      sessionRepository,
      authEventRepository,
      revocationStore
    );

    const result = await globalLogoutUseCase.execute(
      { userId: authContext.userId },
      context
    );

    const response = successResponse(
      {
        message: "Global logout successful. All sessions have been terminated.",
        sessionsRevoked: result.sessionsRevoked,
      },
      200
    );

    clearAuthCookies(response);

    return response;
  } catch (error) {
    return errorResponse(
      error instanceof Error ? error : new Error(String(error)),
      context.requestId
    );
  }
}

export const POST = withCors(withAuth("user")(logoutAllHandler));


--------------------------------------------------------------------------------
File: app\api\auth\me\route.ts
--------------------------------------------------------------------------------

import { type NextRequest } from "next/server";
import { GetCurrentUserUseCase } from "@/application/use-cases/get-current-user.use-case";
import { UserRepositoryImpl } from "@/infrastructure/database/user.repository.impl";
import { withCors } from "@/presentation/middleware/cors";
import { withAuth } from "@/presentation/middleware/auth";
import {
  errorResponse,
  successResponse,
} from "@/presentation/helpers/response";
import { buildRequestContext } from "@/presentation/helpers/request-context";

async function getCurrentUserHandler(
  request: NextRequest,
  authContext: { userId: string }
): Promise<Response> {
  const context = buildRequestContext(request);

  try {
    const userRepository = new UserRepositoryImpl();

    const getCurrentUserUseCase = new GetCurrentUserUseCase(userRepository);

    const result = await getCurrentUserUseCase.execute({
      userId: authContext.userId,
    });

    return successResponse(
      {
        id: result.id,
        email: result.email,
        isVerified: result.isVerified,
        role: result.role,
        createdAt: result.createdAt,
      },
      200
    );
  } catch (error) {
    return errorResponse(
      error instanceof Error ? error : new Error(String(error)),
      context.requestId
    );
  }
}

export const GET = withCors(withAuth("user")(getCurrentUserHandler));


--------------------------------------------------------------------------------
File: app\api\auth\refresh\route.ts
--------------------------------------------------------------------------------

import { type NextRequest } from "next/server";
import { RefreshTokenUseCase } from "@/application/use-cases/refresh-token.use-case";
import { UserRepositoryImpl } from "@/infrastructure/database/user.repository.impl";
import { SessionRepositoryImpl } from "@/infrastructure/database/session.repository.impl";
import { JwtServiceImpl } from "@/infrastructure/crypto/jwt.service";
import { RevocationStoreImpl } from "@/infrastructure/redis/revocation.store.impl";
import { AuthEventRepositoryImpl } from "@/infrastructure/database/auth-event.repository.impl";
import { withCors } from "@/presentation/middleware/cors";
import { withRateLimit } from "@/presentation/middleware/rate-limit";
import {
  errorResponse,
  successResponse,
} from "@/presentation/helpers/response";
import { buildRequestContext } from "@/presentation/helpers/request-context";
import { setAuthCookies } from "@/presentation/helpers/cookies";
import { AuthenticationError } from "@/domain/errors/authentication.error";

async function refreshHandler(request: NextRequest): Promise<Response> {
  const context = buildRequestContext(request);

  try {
    const refreshToken = request.cookies.get("refreshToken")?.value;

    if (!refreshToken) {
      throw new AuthenticationError("Refresh token not found");
    }

    const userRepository = new UserRepositoryImpl();
    const sessionRepository = new SessionRepositoryImpl();
    const authEventRepository = new AuthEventRepositoryImpl();
    const tokenService = new JwtServiceImpl();
    const revocationStore = new RevocationStoreImpl();

    const refreshTokenUseCase = new RefreshTokenUseCase(
      userRepository,
      sessionRepository,
      authEventRepository,
      tokenService,
      revocationStore
    );

    const result = await refreshTokenUseCase.execute({ refreshToken }, context);

    const response = successResponse(
      {
        message: "Token refreshed successfully",
      },
      200
    );

    setAuthCookies(response, result.accessToken, result.refreshToken);

    return response;
  } catch (error) {
    return errorResponse(
      error instanceof Error ? error : new Error(String(error)),
      context.requestId
    );
  }
}

export const POST = withCors(withRateLimit(20, 60)(refreshHandler));


--------------------------------------------------------------------------------
File: app\api\auth\resend-verification\route.ts
--------------------------------------------------------------------------------

import { type NextRequest } from "next/server";
import { ResendVerificationUseCase } from "@/application/use-cases/resend-verification.use-case";
import { UserRepositoryImpl } from "@/infrastructure/database/user.repository.impl";
import { BrevoEmailProvider } from "@/infrastructure/email/brevo.provider";
import { AuthEventRepositoryImpl } from "@/infrastructure/database/auth-event.repository.impl";
import { withCors } from "@/presentation/middleware/cors";
import { withRateLimit } from "@/presentation/middleware/rate-limit";
import {
  errorResponse,
  successResponse,
} from "@/presentation/helpers/response";
import { buildRequestContext } from "@/presentation/helpers/request-context";
import { ResendVerificationSchema } from "@/presentation/validation/schemas";
import { ValidationError } from "@/domain/errors/validation.error";

async function resendVerificationHandler(
  request: NextRequest
): Promise<Response> {
  const context = buildRequestContext(request);

  try {
    const body = await request.json();

    const validationResult = ResendVerificationSchema.safeParse(body);
    if (!validationResult.success) {
      const fields = validationResult.error.errors.reduce(
        (acc, err) => {
          const path = err.path.join(".");
          acc[path] = err.message;
          return acc;
        },
        {} as Record<string, string>
      );

      throw new ValidationError("Invalid email", fields);
    }

    const { email } = validationResult.data;

    const userRepository = new UserRepositoryImpl();
    const authEventRepository = new AuthEventRepositoryImpl();
    const emailProvider = new BrevoEmailProvider();

    const resendVerificationUseCase = new ResendVerificationUseCase(
      userRepository,
      authEventRepository,
      emailProvider
    );

    await resendVerificationUseCase.execute({ email }, context);

    return successResponse(
      {
        message:
          "If an unverified account exists with this email, a new verification link has been sent.",
      },
      200
    );
  } catch (error) {
    return errorResponse(
      error instanceof Error ? error : new Error(String(error)),
      context.requestId
    );
  }
}

export const POST = withCors(withRateLimit(5, 3600)(resendVerificationHandler));


--------------------------------------------------------------------------------
File: app\api\auth\reset-password\route.ts
--------------------------------------------------------------------------------

import { type NextRequest } from "next/server";
import { ResetPasswordUseCase } from "@/application/use-cases/reset-password.use-case";
import { UserRepositoryImpl } from "@/infrastructure/database/user.repository.impl";
import { SessionRepositoryImpl } from "@/infrastructure/database/session.repository.impl";
import { AuthEventRepositoryImpl } from "@/infrastructure/database/auth-event.repository.impl";
import { RevocationStoreImpl } from "@/infrastructure/redis/revocation.store.impl";
import { withCors } from "@/presentation/middleware/cors";
import {
  errorResponse,
  successResponse,
} from "@/presentation/helpers/response";
import { buildRequestContext } from "@/presentation/helpers/request-context";
import { ResetPasswordSchema } from "@/presentation/validation/schemas";
import { ValidationError } from "@/domain/errors/validation.error";

async function resetPasswordHandler(request: NextRequest): Promise<Response> {
  const context = buildRequestContext(request);

  try {
    const body = await request.json();

    const validationResult = ResetPasswordSchema.safeParse(body);
    if (!validationResult.success) {
      const fields = validationResult.error.errors.reduce(
        (acc, err) => {
          const path = err.path.join(".");
          acc[path] = err.message;
          return acc;
        },
        {} as Record<string, string>
      );

      throw new ValidationError("Invalid reset password data", fields);
    }

    const { token, newPassword } = validationResult.data;

    const userRepository = new UserRepositoryImpl();
    const sessionRepository = new SessionRepositoryImpl();
    const authEventRepository = new AuthEventRepositoryImpl();
    const revocationStore = new RevocationStoreImpl();

    const resetPasswordUseCase = new ResetPasswordUseCase(
      userRepository,
      sessionRepository,
      authEventRepository,
      revocationStore
    );

    await resetPasswordUseCase.execute({ token, newPassword }, context);

    return successResponse(
      {
        message:
          "Password reset successful. You can now sign in with your new password.",
      },
      200
    );
  } catch (error) {
    return errorResponse(
      error instanceof Error ? error : new Error(String(error)),
      context.requestId
    );
  }
}

export const POST = withCors(resetPasswordHandler);


--------------------------------------------------------------------------------
File: app\api\auth\signin\route.ts
--------------------------------------------------------------------------------

import { type NextRequest } from "next/server";
import { SigninUseCase } from "@/application/use-cases/signin.use-case";
import { UserRepositoryImpl } from "@/infrastructure/database/user.repository.impl";
import { SessionRepositoryImpl } from "@/infrastructure/database/session.repository.impl";
import { JwtServiceImpl } from "@/infrastructure/crypto/jwt.service";
import { BrevoEmailProvider } from "@/infrastructure/email/brevo.provider";
import { AuthEventRepositoryImpl } from "@/infrastructure/database/auth-event.repository.impl";
import { withCors } from "@/presentation/middleware/cors";
import { withRateLimit } from "@/presentation/middleware/rate-limit";
import {
  errorResponse,
  successResponse,
} from "@/presentation/helpers/response";
import { buildRequestContext } from "@/presentation/helpers/request-context";
import { setAuthCookies } from "@/presentation/helpers/cookies";
import { SigninSchema } from "@/presentation/validation/schemas";
import { ValidationError } from "@/domain/errors/validation.error";

async function signinHandler(request: NextRequest): Promise<Response> {
  const context = buildRequestContext(request);

  try {
    const body = await request.json();

    const validationResult = SigninSchema.safeParse(body);
    if (!validationResult.success) {
      const fields = validationResult.error.errors.reduce(
        (acc, err) => {
          const path = err.path.join(".");
          acc[path] = err.message;
          return acc;
        },
        {} as Record<string, string>
      );

      throw new ValidationError("Invalid signin data", fields);
    }

    const { email, password, rememberMe } = validationResult.data;

    const userRepository = new UserRepositoryImpl();
    const sessionRepository = new SessionRepositoryImpl();
    const tokenService = new JwtServiceImpl();
    const emailProvider = new BrevoEmailProvider();
    const authEventRepository = new AuthEventRepositoryImpl();

    const signinUseCase = new SigninUseCase(
      userRepository,
      sessionRepository,
      authEventRepository,
      tokenService,
      emailProvider
    );

    const result = await signinUseCase.execute(
      {
        email,
        password,
        rememberMe,
      },
      context
    );

    if (result.requiresOtp) {
      return successResponse(
        {
          message: "OTP sent to your email. Please verify to complete signin.",
          requiresOtp: true,
        },
        200
      );
    }

    const response = successResponse(
      {
        message: "Signin successful",
        user: result.user,
      },
      200
    );

    setAuthCookies(
      response,
      result.accessToken!,
      result.refreshToken!,
      rememberMe
    );

    return response;
  } catch (error) {
    return errorResponse(
      error instanceof Error ? error : new Error(String(error)),
      context.requestId
    );
  }
}

export const POST = withCors(withRateLimit(10, 900)(signinHandler));


--------------------------------------------------------------------------------
File: app\api\auth\signup\route.ts
--------------------------------------------------------------------------------

import { type NextRequest } from "next/server";
import { SignupUseCase } from "@/application/use-cases/signup.use-case";
import { UserRepositoryImpl } from "@/infrastructure/database/user.repository.impl";
import { BrevoEmailProvider } from "@/infrastructure/email/brevo.provider";
import { AuthEventRepositoryImpl } from "@/infrastructure/database/auth-event.repository.impl";
import { withCors } from "@/presentation/middleware/cors";
import { withRateLimit } from "@/presentation/middleware/rate-limit";
import {
  errorResponse,
  successResponse,
} from "@/presentation/helpers/response";
import { buildRequestContext } from "@/presentation/helpers/request-context";
import { SignupSchema } from "@/presentation/validation/schemas";
import { ValidationError } from "@/domain/errors/validation.error";

async function signupHandler(request: NextRequest): Promise<Response> {
  const context = buildRequestContext(request);

  try {
    const body = await request.json();

    const validationResult = SignupSchema.safeParse(body);
    if (!validationResult.success) {
      const fields = validationResult.error.errors.reduce(
        (acc, err) => {
          const path = err.path.join(".");
          acc[path] = err.message;
          return acc;
        },
        {} as Record<string, string>
      );

      throw new ValidationError("Invalid signup data", fields);
    }

    const { email, password, name } = validationResult.data;

    const userRepository = new UserRepositoryImpl();
    const emailProvider = new BrevoEmailProvider();
    const authEventRepository = new AuthEventRepositoryImpl();

    const signupUseCase = new SignupUseCase(
      userRepository,
      authEventRepository,
      emailProvider
    );

    const result = await signupUseCase.execute(
      { email, password, name },
      context
    );

    return successResponse(
      {
        success: result.success,
        message: result.message,
      },
      201
    );
  } catch (error) {
    return errorResponse(
      error instanceof Error ? error : new Error(String(error)),
      context.requestId
    );
  }
}

export const POST = withCors(withRateLimit(5, 3600)(signupHandler));


--------------------------------------------------------------------------------
File: app\api\auth\verify-email\route.ts
--------------------------------------------------------------------------------

import { type NextRequest } from "next/server";
import { VerifyEmailUseCase } from "@/application/use-cases/verify-email.use-case";
import { UserRepositoryImpl } from "@/infrastructure/database/user.repository.impl";
import { AuthEventRepositoryImpl } from "@/infrastructure/database/auth-event.repository.impl";
import { withCors } from "@/presentation/middleware/cors";
import {
  errorResponse,
  successResponse,
} from "@/presentation/helpers/response";
import { buildRequestContext } from "@/presentation/helpers/request-context";
import { VerifyEmailSchema } from "@/presentation/validation/schemas";
import { ValidationError } from "@/domain/errors/validation.error";

async function verifyEmailHandler(request: NextRequest): Promise<Response> {
  const context = buildRequestContext(request);

  try {
    const body = await request.json();

    const validationResult = VerifyEmailSchema.safeParse(body);
    if (!validationResult.success) {
      const fields = validationResult.error.errors.reduce(
        (acc, err) => {
          const path = err.path.join(".");
          acc[path] = err.message;
          return acc;
        },
        {} as Record<string, string>
      );

      throw new ValidationError("Invalid verification data", fields);
    }

    const { token } = validationResult.data;

    const userRepository = new UserRepositoryImpl();
    const authEventRepository = new AuthEventRepositoryImpl();

    const verifyEmailUseCase = new VerifyEmailUseCase(
      userRepository,
      authEventRepository
    );

    await verifyEmailUseCase.execute({ token }, context);

    return successResponse(
      {
        message: "Email verified successfully. You can now sign in.",
      },
      200
    );
  } catch (error) {
    return errorResponse(
      error instanceof Error ? error : new Error(String(error)),
      context.requestId
    );
  }
}

export const POST = withCors(verifyEmailHandler);


--------------------------------------------------------------------------------
File: app\api\auth\verify-otp\route.ts
--------------------------------------------------------------------------------

import { type NextRequest } from "next/server";
import { VerifyOtpUseCase } from "@/application/use-cases/verify-otp.use-case";
import { UserRepositoryImpl } from "@/infrastructure/database/user.repository.impl";
import { SessionRepositoryImpl } from "@/infrastructure/database/session.repository.impl";
import { JwtServiceImpl } from "@/infrastructure/crypto/jwt.service";
import { AuthEventRepositoryImpl } from "@/infrastructure/database/auth-event.repository.impl";
import { withCors } from "@/presentation/middleware/cors";
import { withRateLimit } from "@/presentation/middleware/rate-limit";
import {
  errorResponse,
  successResponse,
} from "@/presentation/helpers/response";
import { buildRequestContext } from "@/presentation/helpers/request-context";
import { setAuthCookies } from "@/presentation/helpers/cookies";
import { VerifyOtpSchema } from "@/presentation/validation/schemas";
import { ValidationError } from "@/domain/errors/validation.error";

async function verifyOtpHandler(request: NextRequest): Promise<Response> {
  const context = buildRequestContext(request);

  try {
    const body = await request.json();

    const validationResult = VerifyOtpSchema.safeParse(body);
    if (!validationResult.success) {
      const fields = validationResult.error.errors.reduce(
        (acc, err) => {
          const path = err.path.join(".");
          acc[path] = err.message;
          return acc;
        },
        {} as Record<string, string>
      );

      throw new ValidationError("Invalid OTP data", fields);
    }

    const { email, otp } = validationResult.data;

    const userRepository = new UserRepositoryImpl();
    const sessionRepository = new SessionRepositoryImpl();
    const authEventRepository = new AuthEventRepositoryImpl();
    const tokenService = new JwtServiceImpl();

    const verifyOtpUseCase = new VerifyOtpUseCase(
      userRepository,
      sessionRepository,
      authEventRepository,
      tokenService
    );

    const result = await verifyOtpUseCase.execute({ email, otp }, context);

    const response = successResponse(
      {
        message: "OTP verified successfully",
        user: result.user,
      },
      200
    );

    setAuthCookies(response, result.accessToken, result.refreshToken);

    return response;
  } catch (error) {
    return errorResponse(
      error instanceof Error ? error : new Error(String(error)),
      context.requestId
    );
  }
}

export const POST = withCors(withRateLimit(10, 900)(verifyOtpHandler));


--------------------------------------------------------------------------------
File: app\api\cron\cleanup\route.ts
--------------------------------------------------------------------------------

import { type NextRequest, NextResponse } from "next/server";
import { SessionRepositoryImpl } from "@/infrastructure/database/session.repository.impl";
import { env } from "@/env";

export async function POST(request: NextRequest): Promise<Response> {
  try {
    const authHeader = request.headers.get("authorization");
    const providedSecret = authHeader?.replace("Bearer ", "");

    if (!providedSecret || providedSecret !== env.CRON_SECRET) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const sessionRepository = new SessionRepositoryImpl();
    const deletedCount = await sessionRepository.deleteExpiredSessions();

    return NextResponse.json({
      success: true,
      message: "Cleanup completed",
      stats: {
        sessionsDeleted: deletedCount,
        timestamp: new Date().toISOString(),
      },
    });
  } catch (error) {
    console.error("Cron cleanup error:", error);
    return NextResponse.json(
      {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
      },
      { status: 500 }
    );
  }
}


--------------------------------------------------------------------------------
File: app\api\health\route.ts
--------------------------------------------------------------------------------

import { NextResponse } from "next/server";
import { getDatabase } from "@infra/database/connection";
import { getRedisClient } from "@infra/redis/client";

export async function GET(): Promise<NextResponse> {
  const checks: Record<string, string> = {
    service: "ok",
    mongodb: "unknown",
    redis: "unknown",
  };

  let allHealthy = true;

  try {
    const db = await getDatabase();
    await db.command({ ping: 1 });
    checks.mongodb = "connected";
  } catch (error) {
    checks.mongodb = "disconnected";
    allHealthy = false;
    console.error(
      "[Health] MongoDB check failed:",
      error instanceof Error ? error.message : "Unknown error"
    );
  }

  try {
    const redis = getRedisClient();
    if (redis) {
      await redis.ping();
      checks.redis = "connected";
    } else {
      checks.redis = "disconnected";
      allHealthy = false;
    }
  } catch (error) {
    checks.redis = "disconnected";
    allHealthy = false;
    console.error(
      "[Health] Redis check failed:",
      error instanceof Error ? error.message : "Unknown error"
    );
  }

  const status = allHealthy ? 200 : 503;

  return NextResponse.json(
    {
      status: allHealthy ? "healthy" : "unhealthy",
      timestamp: new Date().toISOString(),
      checks,
    },
    { status }
  );
}


--------------------------------------------------------------------------------
File: app\layout.tsx
--------------------------------------------------------------------------------

import "./globals.css";

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <head />
      <body>{children}</body>
    </html>
  );
}


--------------------------------------------------------------------------------
File: app\page.tsx
--------------------------------------------------------------------------------

export default function Home() {
  return (
    <main style={{ minHeight: "100vh", display: "grid", placeItems: "center" }}>
      <h1>Hello, world!</h1>
    </main>
  );
}


--------------------------------------------------------------------------------
File: docs\architecture.md
--------------------------------------------------------------------------------

# Architecture Documentation

## Overview

This authentication service is built using **Domain-Driven Design (DDD)** with a clean 4-layer architecture. The architecture enforces strict separation of concerns, dependency rules, and layer boundaries through ESLint and TypeScript.

## Why Domain-Driven Design?

DDD was chosen for this authentication service because:

1. **Complexity Management**: Authentication systems have complex business rules (token rotation, revocation strategies, OTP verification, etc.). DDD helps manage this complexity through clear domain models.

2. **Security Requirements**: Authentication is security-critical. DDD's clear boundaries and dependency rules ensure security logic stays isolated and testable.

3. **Maintainability**: Clean architecture with explicit boundaries makes the codebase easier to understand, test, and modify over time.

4. **Testability**: Dependency injection and port/adapter pattern enable comprehensive unit testing with mocks.

5. **Technology Independence**: Domain and application layers are independent of frameworks, databases, and external services, making them portable and framework-agnostic.

6. **Team Collaboration**: Clear layer boundaries enable multiple developers to work on different layers without conflicts.

## 4-Layer Architecture

The service is organized into 4 distinct layers, each with specific responsibilities and strict dependency rules.

### Layer 1: Domain Layer (Core)

**Location:** `src/domain/`

**Purpose:** Pure business logic with zero external dependencies

**Responsibilities:**

- Define business entities with behavior
- Define value objects for domain concepts
- Define repository interfaces (ports)
- Define domain errors and business rules
- Enforce invariants and validation

**Key Characteristics:**

- **Pure TypeScript** - No framework dependencies
- **No external imports** - Cannot import from outer layers
- **No infrastructure** - No database, HTTP, or external service code
- **Testable** - Easy to unit test in isolation

**Directory Structure:**

```
src/domain/
├── entities/               # Business entities
│   ├── user.entity.ts      # User entity with business methods
│   ├── session.entity.ts   # Session entity
│   └── auth-event.entity.ts # Audit log entity
├── value-objects/          # Domain value objects
│   ├── email.vo.ts         # Email value object with validation
│   ├── hashed-password.vo.ts
│   ├── jti.vo.ts           # JWT ID value object
│   ├── session-id.vo.ts
│   └── token-version.vo.ts
├── repositories/           # Repository interfaces (ports)
│   ├── user.repository.ts
│   ├── session.repository.ts
│   └── auth-event.repository.ts
├── errors/                 # Domain-specific errors
│   ├── base.error.ts       # Base domain error
│   ├── authentication.error.ts
│   ├── authorization.error.ts
│   ├── validation.error.ts
│   ├── not-found.error.ts
│   ├── conflict.error.ts
│   ├── token.error.ts
│   └── rate-limit.error.ts
└── index.ts                # Public exports
```

**Example: User Entity**

```typescript
// Domain entity with business logic
export class User {
  constructor(
    public readonly id: string,
    public readonly email: Email,
    public readonly password: HashedPassword,
    public readonly role: "user" | "admin",
    public readonly isVerified: boolean,
    public readonly tokenVersion: TokenVersion
  ) {}

  // Business method
  incrementTokenVersion(): User {
    return new User(
      this.id,
      this.email,
      this.password,
      this.role,
      this.isVerified,
      this.tokenVersion.increment()
    );
  }
}
```

### Layer 2: Application Layer (Use Cases)

**Location:** `src/application/`

**Purpose:** Orchestrate business logic and coordinate domain operations

**Responsibilities:**

- Define use cases (application services)
- Define DTOs (Data Transfer Objects) for input/output
- Define port interfaces for external dependencies
- Coordinate domain entities and repositories
- Handle application-level errors

**Key Characteristics:**

- **Can import from Domain layer only**
- **Defines interfaces** - Port interfaces for infrastructure
- **No framework code** - Framework-agnostic
- **Testable** - Easy to unit test with mocks

**Directory Structure:**

```
src/application/
├── use-cases/              # Use case implementations
│   ├── signup.use-case.ts
│   ├── signin.use-case.ts
│   ├── verify-otp.use-case.ts
│   ├── refresh-token.use-case.ts
│   ├── logout.use-case.ts
│   ├── global-logout.use-case.ts
│   ├── verify-email.use-case.ts
│   ├── forgot-password.use-case.ts
│   ├── reset-password.use-case.ts
│   ├── resend-verification.use-case.ts
│   └── get-current-user.use-case.ts
├── dtos/                   # Data transfer objects
│   ├── auth.dto.ts         # Auth-related DTOs
│   └── user.dto.ts         # User-related DTOs
└── interfaces/             # Port interfaces (Hexagonal Architecture)
    ├── email.provider.ts   # Email service interface
    ├── token.service.ts    # Token service interface
    └── revocation.store.ts # Revocation store interface
```

**Example: Use Case**

```typescript
// Application use case with dependency injection
export class SignupUseCase {
  constructor(
    private readonly userRepository: IUserRepository, // Domain port
    private readonly passwordService: IPasswordService, // App port
    private readonly emailProvider: IEmailProvider, // App port
    private readonly authEventRepository: IAuthEventRepository // Domain port
  ) {}

  async execute(input: SignupInput): Promise<SignupOutput> {
    // Orchestrate domain logic
    // 1. Validate
    // 2. Check uniqueness
    // 3. Create domain entity
    // 4. Save via repository
    // 5. Send email via provider
    // 6. Log event
  }
}
```

**Example: Port Interface**

```typescript
// Application-level interface (port)
export interface IEmailProvider {
  sendVerificationEmail(to: string, token: string): Promise<void>;
  sendOTPEmail(to: string, otp: string): Promise<void>;
  sendPasswordResetEmail(to: string, token: string): Promise<void>;
}
```

### Layer 3: Infrastructure Layer (Adapters)

**Location:** `src/infrastructure/`

**Purpose:** Implement technical details and external integrations

**Responsibilities:**

- Implement repository interfaces from domain
- Implement port interfaces from application
- Integrate with databases, external APIs, file systems
- Handle encryption, hashing, JWT operations
- Provide concrete implementations of all interfaces

**Key Characteristics:**

- **Can import from Domain and Application layers**
- **Implements interfaces** - Adapter pattern
- **Framework/library dependent** - Uses MongoDB, Redis, jose, etc.
- **Testable** - Integration tests with real infrastructure

**Directory Structure:**

```
src/infrastructure/
├── database/               # MongoDB implementations
│   ├── connection.ts       # Database connection
│   ├── indexes.ts          # Index creation
│   ├── schemas/            # MongoDB schemas
│   │   ├── user.schema.ts
│   │   ├── session.schema.ts
│   │   └── auth-event.schema.ts
│   ├── user.repository.impl.ts      # IUserRepository implementation
│   ├── session.repository.impl.ts   # ISessionRepository implementation
│   └── auth-event.repository.impl.ts
├── redis/                  # Redis implementations
│   ├── client.ts           # Redis connection
│   ├── revocation.store.impl.ts  # IRevocationStore implementation
│   ├── otp-rate-limiter.ts
│   └── simple-lru.ts       # In-memory LRU cache
├── email/                  # Email provider implementations
│   └── brevo.provider.ts   # IEmailProvider implementation (Brevo)
└── crypto/                 # Cryptographic services
    ├── hash.ts             # SHA256 hashing
    ├── password.service.ts # IPasswordService implementation
    ├── otp.service.ts      # OTP generation/encryption
    └── jwt.service.ts      # ITokenService implementation
```

**Example: Repository Implementation**

```typescript
// Infrastructure adapter implementing domain port
export class UserRepositoryImpl implements IUserRepository {
  constructor(private readonly db: Db) {}

  async save(user: User): Promise<void> {
    const userSchema = this.toSchema(user);
    await this.db.collection("users").insertOne(userSchema);
  }

  async findByEmail(email: Email): Promise<User | null> {
    const schema = await this.db
      .collection("users")
      .findOne({ email: email.value });
    return schema ? this.toDomain(schema) : null;
  }

  // Map between domain entity and database schema
  private toSchema(user: User): UserSchema {
    /* ... */
  }
  private toDomain(schema: UserSchema): User {
    /* ... */
  }
}
```

**Example: Service Implementation**

```typescript
// Infrastructure adapter implementing application port
export class BrevoEmailProvider implements IEmailProvider {
  constructor(private readonly apiKey: string) {}

  async sendVerificationEmail(to: string, token: string): Promise<void> {
    // Implement using Brevo SDK
    const brevo = new TransactionalEmailsApi();
    await brevo.sendTransacEmail({
      to: [{ email: to }],
      subject: "Verify your email",
      htmlContent: this.generateVerificationHtml(token),
    });
  }
}
```

### Layer 4: Presentation Layer (API/UI)

**Location:** `src/presentation/` and `app/api/`

**Purpose:** Handle HTTP requests, responses, and user interactions

**Responsibilities:**

- Define API routes and endpoints
- Validate HTTP requests
- Call use cases with validated input
- Format HTTP responses
- Apply middleware (CORS, rate limiting, auth, CSRF)
- Set/clear cookies
- Handle HTTP-level errors

**Key Characteristics:**

- **Can import from all layers**
- **Framework-specific** - Uses Next.js App Router
- **HTTP-focused** - Request/response handling
- **Wires dependencies** - Dependency injection setup

**Directory Structure:**

```
src/presentation/
├── middleware/             # Next.js middleware
│   ├── cors.ts             # CORS validation
│   ├── csrf.ts             # CSRF protection
│   ├── rate-limit.ts       # Rate limiting
│   └── auth.ts             # JWT authentication
├── helpers/                # Request/response helpers
│   ├── request-context.ts  # Extract IP, user agent, etc.
│   ├── cookies.ts          # Set/clear auth cookies
│   └── response.ts         # Standard response formats
└── validation/
    └── schemas.ts          # Zod validation schemas

app/api/                    # Next.js API routes
├── .well-known/
│   └── jwks.json/
│       └── route.ts        # Public JWKS endpoint
├── auth/
│   ├── signup/
│   │   └── route.ts        # POST /api/auth/signup
│   ├── signin/
│   │   └── route.ts        # POST /api/auth/signin
│   ├── verify-otp/
│   │   └── route.ts        # POST /api/auth/verify-otp
│   ├── refresh/
│   │   └── route.ts        # POST /api/auth/refresh
│   ├── logout/
│   │   └── route.ts        # POST /api/auth/logout
│   ├── logout-all/
│   │   └── route.ts        # POST /api/auth/logout-all
│   ├── me/
│   │   └── route.ts        # GET /api/auth/me
│   ├── verify-email/
│   │   └── route.ts        # POST /api/auth/verify-email
│   ├── forgot-password/
│   │   └── route.ts        # POST /api/auth/forgot-password
│   ├── reset-password/
│   │   └── route.ts        # POST /api/auth/reset-password
│   └── resend-verification/
│       └── route.ts        # POST /api/auth/resend-verification
├── cron/
│   └── cleanup/
│       └── route.ts        # POST /api/cron/cleanup
└── health/
    └── route.ts            # GET /api/health
```

**Example: API Route**

```typescript
// Presentation layer - API route
export async function POST(request: NextRequest): Promise<NextResponse> {
  try {
    // 1. Apply middleware
    const corsResult = await corsMiddleware(request);
    if (corsResult) return corsResult;

    const rateLimitResult = await rateLimitMiddleware(request);
    if (rateLimitResult) return rateLimitResult;

    // 2. Validate request
    const body = await request.json();
    const input = SignupSchema.parse(body);

    // 3. Build request context
    const context = buildRequestContext(request);

    // 4. Wire dependencies (DI)
    const db = await getDatabase();
    const userRepo = new UserRepositoryImpl(db);
    const passwordService = new PasswordService();
    const emailProvider = new BrevoEmailProvider(env.BREVO_API_KEY);
    const authEventRepo = new AuthEventRepositoryImpl(db);

    // 5. Create and execute use case
    const useCase = new SignupUseCase(
      userRepo,
      passwordService,
      emailProvider,
      authEventRepo
    );

    const output = await useCase.execute({ ...input, context });

    // 6. Return formatted response
    return successResponse(output, 201);
  } catch (error) {
    return handleDomainError(error);
  }
}
```

## Dependency Flow

The dependency flow follows the **Dependency Inversion Principle** (DIP):

```
┌─────────────────────────────────────────────────────┐
│                 Presentation Layer                  │
│                                                     │
│  • Depends on Application (use cases)              │
│  • Depends on Infrastructure (implementations)     │
│  • Wires everything together                       │
└─────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────┐
│              Infrastructure Layer                   │
│                                                     │
│  • Implements Application interfaces (ports)       │
│  • Implements Domain interfaces (repositories)     │
│  • Depends on external libraries                   │
└─────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────┐
│                Application Layer                    │
│                                                     │
│  • Depends on Domain (entities, repos, errors)     │
│  • Defines port interfaces for Infrastructure      │
│  • Orchestrates domain logic                       │
└─────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────┐
│                  Domain Layer                       │
│                                                     │
│  • No dependencies on outer layers                 │
│  • Pure business logic                             │
│  • Defines repository interfaces                   │
└─────────────────────────────────────────────────────┘
```

## Component Diagram

```
┌──────────────────────────────────────────────────────────────┐
│                     Presentation Layer                       │
│                                                              │
│  ┌────────────┐  ┌────────────┐  ┌──────────────┐          │
│  │ API Routes │  │ Middleware │  │   Helpers    │          │
│  │            │  │            │  │              │          │
│  │ - signup   │  │ - CORS     │  │ - cookies    │          │
│  │ - signin   │  │ - CSRF     │  │ - response   │          │
│  │ - refresh  │  │ - rateLimit│  │ - context    │          │
│  │ - logout   │  │ - auth     │  │ - validation │          │
│  └────────────┘  └────────────┘  └──────────────┘          │
│                                                              │
└────────────────────────┬─────────────────────────────────────┘
                         │ uses
                         ↓
┌──────────────────────────────────────────────────────────────┐
│                  Infrastructure Layer                        │
│                                                              │
│  ┌────────────┐  ┌────────────┐  ┌────────────┐            │
│  │  Database  │  │   Redis    │  │   Email    │            │
│  │            │  │            │  │            │            │
│  │ - UserRepo │  │ - Revoke   │  │ - Brevo    │            │
│  │ - SessionR │  │ - RateLimit│  │            │            │
│  │ - EventRepo│  │ - LRU      │  │            │            │
│  └────────────┘  └────────────┘  └────────────┘            │
│                                                              │
│  ┌────────────┐                                             │
│  │   Crypto   │                                             │
│  │            │                                             │
│  │ - JWT      │                                             │
│  │ - Password │                                             │
│  │ - OTP      │                                             │
│  │ - Hash     │                                             │
│  └────────────┘                                             │
│                                                              │
└────────────────────────┬─────────────────────────────────────┘
                         │ implements
                         ↓
┌──────────────────────────────────────────────────────────────┐
│                   Application Layer                          │
│                                                              │
│  ┌────────────────────────────────────────────┐             │
│  │             Use Cases                      │             │
│  │                                            │             │
│  │  - SignupUseCase                          │             │
│  │  - SigninUseCase                          │             │
│  │  - VerifyOtpUseCase                       │             │
│  │  - RefreshTokenUseCase                    │             │
│  │  - LogoutUseCase                          │             │
│  │  - GlobalLogoutUseCase                    │             │
│  │  - VerifyEmailUseCase                     │             │
│  │  - ForgotPasswordUseCase                  │             │
│  │  - ResetPasswordUseCase                   │             │
│  │  - GetCurrentUserUseCase                  │             │
│  │  - ResendVerificationUseCase              │             │
│  └────────────────────────────────────────────┘             │
│                                                              │
│  ┌──────────────┐     ┌──────────────────┐                 │
│  │     DTOs     │     │  Port Interfaces │                 │
│  │              │     │                  │                 │
│  │ - SignupI/O  │     │ - IEmailProvider │                 │
│  │ - SigninI/O  │     │ - ITokenService  │                 │
│  │ - RefreshI/O │     │ - IRevocationStore│                │
│  └──────────────┘     └──────────────────┘                 │
│                                                              │
└────────────────────────┬─────────────────────────────────────┘
                         │ orchestrates
                         ↓
┌──────────────────────────────────────────────────────────────┐
│                      Domain Layer                            │
│                                                              │
│  ┌────────────┐  ┌────────────┐  ┌────────────┐            │
│  │  Entities  │  │Value Objects│ │ Repositories│            │
│  │            │  │            │  │  (Interfaces)│            │
│  │ - User     │  │ - Email    │  │              │            │
│  │ - Session  │  │ - Password │  │ - IUserRepo  │            │
│  │ - AuthEvent│  │ - Jti      │  │ - ISessionR  │            │
│  │            │  │ - SessionId│  │ - IAuthEventR│            │
│  └────────────┘  └────────────┘  └────────────┘            │
│                                                              │
│  ┌────────────────────────────────────────────┐             │
│  │              Domain Errors                 │             │
│  │                                            │             │
│  │  - AuthenticationError                    │             │
│  │  - AuthorizationError                     │             │
│  │  - ValidationError                        │             │
│  │  - NotFoundError                          │             │
│  │  - ConflictError                          │             │
│  │  - TokenError                             │             │
│  │  - RateLimitError                         │             │
│  └────────────────────────────────────────────┘             │
│                                                              │
└──────────────────────────────────────────────────────────────┘
```

## Benefits of This Architecture

### 1. Testability

Each layer can be tested in isolation:

```typescript
// Test domain entity (no mocks needed)
describe('User', () => {
  it('should increment token version', () => {
    const user = new User(...);
    const updated = user.incrementTokenVersion();
    expect(updated.tokenVersion.value).toBe(1);
  });
});

// Test use case (mock repositories)
describe('SignupUseCase', () => {
  it('should create user and send email', async () => {
    const mockUserRepo = createMock<IUserRepository>();
    const mockEmailProvider = createMock<IEmailProvider>();

    const useCase = new SignupUseCase(mockUserRepo, mockEmailProvider);
    await useCase.execute(input);

    expect(mockUserRepo.save).toHaveBeenCalled();
    expect(mockEmailProvider.sendVerificationEmail).toHaveBeenCalled();
  });
});
```

### 2. Maintainability

Clear boundaries make it easy to:

- Understand where code belongs
- Find specific functionality
- Modify without breaking other layers
- Onboard new developers

### 3. Technology Independence

Easily swap implementations:

```typescript
// Switch from Brevo to SendGrid
class SendGridEmailProvider implements IEmailProvider {
  // Same interface, different implementation
}

// Switch from MongoDB to PostgreSQL
class PostgresUserRepository implements IUserRepository {
  // Same interface, different database
}
```

### 4. Security Isolation

Security-critical code is isolated in domain/application layers and thoroughly tested without infrastructure dependencies.

### 5. Framework Agnosticism

Domain and application layers don't depend on Next.js, making them reusable in other contexts (CLI tools, background workers, different frameworks).

## Best Practices

### 1. Keep Domain Pure

```typescript
// ✅ Good - Pure domain entity
export class User {
  incrementTokenVersion(): User {
    return new User(/* ... */);
  }
}

// ❌ Bad - Domain depends on infrastructure
import { MongoDB } from "mongodb";
export class User {
  async save() {
    await MongoDB.save(this); // NO!
  }
}
```

### 2. Use Dependency Injection

```typescript
// ✅ Good - Dependencies injected
class SignupUseCase {
  constructor(
    private readonly userRepo: IUserRepository,
    private readonly emailProvider: IEmailProvider
  ) {}
}

// ❌ Bad - Hard-coded dependencies
class SignupUseCase {
  execute() {
    const repo = new UserRepositoryImpl(); // NO!
  }
}
```

### 3. Define Interfaces in Inner Layers

```typescript
// ✅ Good - Interface in application layer
// src/application/interfaces/email.provider.ts
export interface IEmailProvider {
  sendVerificationEmail(to: string, token: string): Promise<void>;
}

// Implementation in infrastructure layer
// src/infrastructure/email/brevo.provider.ts
export class BrevoEmailProvider implements IEmailProvider {
  async sendVerificationEmail(to: string, token: string): Promise<void> {
    // Implementation
  }
}
```

### 4. DTOs for Layer Communication

```typescript
// ✅ Good - Use DTOs
interface SignupInput {
  email: string;
  password: string;
}

// ❌ Bad - Expose domain entities
function signup(user: User) {
  // NO!
  // Domain entity should not cross layer boundaries
}
```

### 5. Map Between Layers

```typescript
// ✅ Good - Map between domain and persistence
class UserRepositoryImpl {
  async save(user: User): Promise<void> {
    const schema = this.toSchema(user); // Map to DB schema
    await this.db.collection("users").insertOne(schema);
  }

  private toSchema(user: User): UserSchema {
    return {
      _id: new ObjectId(user.id),
      email: user.email.value,
      // ... map all fields
    };
  }
}
```

## Summary

This authentication service uses a clean 4-layer DDD architecture:

1. **Domain Layer**: Pure business logic, zero dependencies
2. **Application Layer**: Use cases, DTOs, port interfaces
3. **Infrastructure Layer**: Database, Redis, email, crypto implementations
4. **Presentation Layer**: API routes, middleware, HTTP handling

The architecture enforces:

- **Strict dependency rules** (enforced by ESLint)
- **Dependency inversion** (outer layers depend on inner interfaces)
- **Testability** (each layer testable in isolation)
- **Maintainability** (clear boundaries and responsibilities)
- **Technology independence** (core logic framework-agnostic)

For more details, see:

- [Dependency Rules](dependency-rule.md)
- [Enforcement](enforcement.md)
- [Development Guide](development.md)


--------------------------------------------------------------------------------
File: docs\dependency-rule.md
--------------------------------------------------------------------------------

# Dependency Rules

This document defines the strict layer dependency rules enforced in the authentication service's Domain-Driven Design (DDD) architecture.

## Overview

The authentication service uses a 4-layer DDD architecture with **unidirectional dependencies**:

```
Domain ← Application ← Infrastructure ← Presentation
```

Arrows indicate dependency direction: outer layers depend on inner layers, never the reverse.

## The Dependency Rule

> **Source code dependencies must point only inwards, toward higher-level policies.**

This is the **Dependency Inversion Principle** (DIP) from SOLID principles.

### What This Means

- **Inner layers** define interfaces (abstractions)
- **Outer layers** implement those interfaces (concretions)
- **Dependencies flow inward** (outer depends on inner)
- **Data flow can be bidirectional** (via interfaces)

## Layer-by-Layer Rules

### Domain Layer (Core)

**Location:** `src/domain/`

**Can import from:**

- ✅ **Nothing** - Domain layer has zero dependencies

**Cannot import from:**

- ❌ Application layer (`src/application/`)
- ❌ Infrastructure layer (`src/infrastructure/`)
- ❌ Presentation layer (`src/presentation/`)
- ❌ External frameworks (Next.js, MongoDB, Redis, etc.)
- ❌ Node.js-specific modules (except pure TypeScript types)

**Examples:**

```typescript
// ✅ GOOD - Pure domain entity
export class User {
  constructor(
    public readonly id: string,
    public readonly email: Email,
    public readonly password: HashedPassword
  ) {}
}

// ✅ GOOD - Domain repository interface
export interface IUserRepository {
  save(user: User): Promise<void>;
  findById(id: string): Promise<User | null>;
}

// ❌ BAD - Importing from outer layer
import { SignupUseCase } from "@app/use-cases/signup.use-case"; // NO!

// ❌ BAD - Importing framework
import { NextRequest } from "next/server"; // NO!

// ❌ BAD - Importing infrastructure
import { MongoClient } from "mongodb"; // NO!
```

**Why?**

- Domain contains pure business logic
- Must be framework-agnostic
- Easily testable without infrastructure
- Portable across different applications

### Application Layer

**Location:** `src/application/`

**Can import from:**

- ✅ Domain layer (`@domain/*`)
  - Entities
  - Value objects
  - Repository interfaces
  - Domain errors

**Cannot import from:**

- ❌ Infrastructure layer (`src/infrastructure/`)
- ❌ Presentation layer (`src/presentation/`)
- ❌ External frameworks (Next.js, MongoDB, etc.)
- Can define port interfaces for infrastructure

**Examples:**

```typescript
// ✅ GOOD - Use case importing domain
import { User } from "@domain/entities/user.entity";
import { IUserRepository } from "@domain/repositories/user.repository";
import { ValidationError } from "@domain/errors/validation.error";

export class SignupUseCase {
  constructor(
    private readonly userRepository: IUserRepository // Domain interface
  ) {}
}

// ✅ GOOD - Defining port interface
export interface IEmailProvider {
  sendVerificationEmail(to: string, token: string): Promise<void>;
}

// ❌ BAD - Importing infrastructure
import { UserRepositoryImpl } from "@infra/database/user.repository.impl"; // NO!

// ❌ BAD - Importing presentation
import { successResponse } from "@presentation/helpers/response"; // NO!

// ❌ BAD - Importing framework
import { MongoClient } from "mongodb"; // NO!
```

**Why?**

- Application orchestrates domain logic
- Defines contracts (interfaces) for infrastructure
- Still framework-agnostic
- Testable with mocks

### Infrastructure Layer

**Location:** `src/infrastructure/`

**Can import from:**

- ✅ Domain layer (`@domain/*`)
- ✅ Application layer (`@app/*`)
  - Port interfaces to implement
- ✅ External libraries (MongoDB, Redis, jose, bcrypt, etc.)
- ✅ Node.js modules (crypto, fs, etc.)

**Cannot import from:**

- ❌ Presentation layer (`src/presentation/`)

**Examples:**

```typescript
// ✅ GOOD - Implementing domain interface
import { IUserRepository } from "@domain/repositories/user.repository";
import { User } from "@domain/entities/user.entity";
import { Db } from "mongodb";

export class UserRepositoryImpl implements IUserRepository {
  constructor(private readonly db: Db) {}

  async save(user: User): Promise<void> {
    // Implementation using MongoDB
  }
}

// ✅ GOOD - Implementing application interface
import { IEmailProvider } from "@app/interfaces/email.provider";
import * as brevo from "@getbrevo/brevo";

export class BrevoEmailProvider implements IEmailProvider {
  async sendVerificationEmail(to: string, token: string): Promise<void> {
    // Implementation using Brevo
  }
}

// ❌ BAD - Importing presentation
import { buildRequestContext } from "@presentation/helpers/request-context"; // NO!
```

**Why?**

- Infrastructure implements technical details
- Adapters for external services
- Still isolated from presentation concerns
- Can be swapped without changing domain/application

### Presentation Layer

**Location:** `src/presentation/` and `app/api/`

**Can import from:**

- ✅ Domain layer (`@domain/*`)
- ✅ Application layer (`@app/*`)
- ✅ Infrastructure layer (`@infra/*`)
- ✅ Frameworks (Next.js)
- ✅ Everything

**Cannot import from:**

- Nothing - Presentation is the outermost layer

**Examples:**

```typescript
// ✅ GOOD - Importing from all layers
import { SignupUseCase } from "@app/use-cases/signup.use-case";
import { UserRepositoryImpl } from "@infra/database/user.repository.impl";
import { BrevoEmailProvider } from "@infra/email/brevo.provider";
import { ValidationError } from "@domain/errors/validation.error";
import { NextRequest, NextResponse } from "next/server";

export async function POST(request: NextRequest) {
  // Wire dependencies
  const db = await getDatabase();
  const userRepo = new UserRepositoryImpl(db);
  const emailProvider = new BrevoEmailProvider(apiKey);

  // Create and execute use case
  const useCase = new SignupUseCase(userRepo, emailProvider);
  const result = await useCase.execute(input);

  return NextResponse.json(result);
}
```

**Why?**

- Presentation coordinates everything
- Wires dependencies together (DI)
- Framework-specific (Next.js)
- User-facing layer

## Enforcement Mechanisms

### 1. ESLint Rules

Configured in `eslint.config.mjs`:

```javascript
// Domain layer restrictions
{
  files: ["src/domain/**/*.ts"],
  rules: {
    "no-restricted-imports": [
      "error",
      {
        patterns: [
          {
            group: ["@app/*", "@infra/*", "@presentation/*"],
            message: "Domain layer must not import from Application, Infrastructure, or Presentation."
          },
          {
            group: ["next/*", "mongodb", "@upstash/*", "@getbrevo/*"],
            message: "Domain layer must not depend on framework or infrastructure packages."
          }
        ]
      }
    ]
  }
}

// Application layer restrictions
{
  files: ["src/application/**/*.ts"],
  rules: {
    "no-restricted-imports": [
      "error",
      {
        patterns: [
          {
            group: ["@infra/*", "@presentation/*"],
            message: "Application layer must not import from Infrastructure or Presentation."
          },
          {
            group: ["next/*", "mongodb", "@upstash/*"],
            message: "Application layer must not depend on framework or infrastructure packages directly."
          }
        ]
      }
    ]
  }
}

// Infrastructure layer restrictions
{
  files: ["src/infrastructure/**/*.ts"],
  rules: {
    "no-restricted-imports": [
      "error",
      {
        patterns: [
          {
            group: ["@presentation/*"],
            message: "Infrastructure layer must not import from Presentation."
          }
        ]
      }
    ]
  }
}
```

**How It Works:**

- ESLint scans all files during `pnpm lint`
- Import patterns are matched against restrictions
- Build fails if violations detected
- Clear error messages guide developers

### 2. TypeScript Path Aliases

Configured in `tsconfig.json`:

```json
{
  "compilerOptions": {
    "paths": {
      "@domain/*": ["src/domain/*"],
      "@app/*": ["src/application/*"],
      "@infra/*": ["src/infrastructure/*"],
      "@presentation/*": ["src/presentation/*"]
    }
  }
}
```

**Benefits:**

- Clear layer identification in imports
- Easy to spot violations
- Refactoring-friendly
- Self-documenting code

### 3. Pre-commit Hooks

The pre-commit script validates architectural boundaries:

```javascript
// scripts/pre-commit.js
async function validateArchitecturalBoundaries() {
  const violations = [];

  // Check domain files
  const domainFiles = glob.sync("src/domain/**/*.ts");
  for (const file of domainFiles) {
    const content = fs.readFileSync(file, "utf8");

    // Domain cannot import from outer layers
    if (/@app\/|@infra\/|@presentation\//.test(content)) {
      violations.push({
        file,
        message: "Domain imports from outer layer",
      });
    }
  }

  // ... similar checks for other layers

  if (violations.length > 0) {
    throw new Error("Architectural boundary violations detected");
  }
}
```

## Common Violations and Solutions

### Violation 1: Domain Importing from Application

```typescript
// ❌ WRONG
// src/domain/entities/user.entity.ts
import { SignupInput } from '@app/dtos/auth.dto';

// ✅ SOLUTION
// Move shared types to domain layer or use primitive types
constructor(email: string, password: string) {}
```

### Violation 2: Application Importing from Infrastructure

```typescript
// ❌ WRONG
// src/application/use-cases/signup.use-case.ts
import { UserRepositoryImpl } from '@infra/database/user.repository.impl';

// ✅ SOLUTION
// Use domain interface, inject implementation from presentation
import { IUserRepository } from '@domain/repositories/user.repository';

constructor(private readonly userRepository: IUserRepository) {}
```

### Violation 3: Domain Using Framework

```typescript
// ❌ WRONG
// src/domain/entities/user.entity.ts
import { ObjectId } from 'mongodb';

// ✅ SOLUTION
// Use primitive string type, convert in infrastructure layer
constructor(public readonly id: string) {}
```

### Violation 4: Application Using Concrete Infrastructure

```typescript
// ❌ WRONG
// src/application/use-cases/signup.use-case.ts
import { BrevoEmailProvider } from '@infra/email/brevo.provider';

// ✅ SOLUTION
// Define interface in application, inject implementation
// src/application/interfaces/email.provider.ts
export interface IEmailProvider {
  sendEmail(to: string, subject: string): Promise<void>;
}

// Use interface in use case
constructor(private readonly emailProvider: IEmailProvider) {}
```

## Dependency Inversion in Practice

### Problem: How does Application call Infrastructure?

Application layer needs email service, but can't import from Infrastructure layer.

**Solution: Port and Adapter Pattern (Hexagonal Architecture)**

**Step 1: Application defines interface (Port)**

```typescript
// src/application/interfaces/email.provider.ts
export interface IEmailProvider {
  sendVerificationEmail(to: string, token: string): Promise<void>;
}
```

**Step 2: Infrastructure implements interface (Adapter)**

```typescript
// src/infrastructure/email/brevo.provider.ts
import { IEmailProvider } from "@app/interfaces/email.provider";

export class BrevoEmailProvider implements IEmailProvider {
  async sendVerificationEmail(to: string, token: string): Promise<void> {
    // Brevo implementation
  }
}
```

**Step 3: Application uses interface**

```typescript
// src/application/use-cases/signup.use-case.ts
import { IEmailProvider } from "@app/interfaces/email.provider";

export class SignupUseCase {
  constructor(private readonly emailProvider: IEmailProvider) {}

  async execute(input: SignupInput) {
    await this.emailProvider.sendVerificationEmail(user.email, token);
  }
}
```

**Step 4: Presentation wires concrete implementation**

```typescript
// app/api/auth/signup/route.ts
import { SignupUseCase } from "@app/use-cases/signup.use-case";
import { BrevoEmailProvider } from "@infra/email/brevo.provider";

const emailProvider = new BrevoEmailProvider(apiKey);
const useCase = new SignupUseCase(userRepo, emailProvider);
```

**Result:**

- Application depends on interface (abstraction)
- Infrastructure depends on interface (implements it)
- Presentation wires everything together
- **Dependencies point inward** ✓

## Benefits of Strict Dependency Rules

### 1. Testability

```typescript
// Easy to test with mocks
const mockEmailProvider: IEmailProvider = {
  sendVerificationEmail: jest.fn(),
};

const useCase = new SignupUseCase(mockUserRepo, mockEmailProvider);
```

### 2. Flexibility

```typescript
// Easy to swap implementations
const emailProvider =
  process.env.EMAIL_PROVIDER === "sendgrid"
    ? new SendGridEmailProvider()
    : new BrevoEmailProvider();
```

### 3. Portability

```typescript
// Domain and application layers can be reused in:
// - Different frameworks (Express, Fastify, etc.)
// - CLI tools
// - Background workers
// - Microservices
```

### 4. Maintainability

- Clear boundaries prevent "big ball of mud"
- Easy to locate where logic belongs
- Changes in outer layers don't affect inner layers
- Violations caught early (build time, not runtime)

## Summary

**Dependency Rules:**

- ✅ Domain: No dependencies
- ✅ Application: Depends on Domain only
- ✅ Infrastructure: Depends on Domain + Application
- ✅ Presentation: Depends on all layers

**Enforcement:**

- ESLint rules (automatic checking)
- TypeScript path aliases (clear imports)
- Pre-commit hooks (prevent violations)
- Code reviews (team awareness)

**Key Principle:**

> Dependencies point inward. Data flows in both directions (via interfaces).

For implementation details, see:

- [Architecture](architecture.md)
- [Enforcement](enforcement.md)
- [Development Guide](development.md)


--------------------------------------------------------------------------------
File: docs\development.md
--------------------------------------------------------------------------------

# Development Guide

Complete guide for developing and contributing to the authentication service.

## Table of Contents

- [Local Setup](#local-setup)
- [Development Workflow](#development-workflow)
- [Code Style Guidelines](#code-style-guidelines)
- [Testing Strategies](#testing-strategies)
- [Debugging Tips](#debugging-tips)
- [Common Tasks](#common-tasks)
- [Troubleshooting](#troubleshooting)

## Local Setup

### Prerequisites

Ensure you have installed:

- **Node.js** 22.0.0 or higher
- **pnpm** 9.0.0 or higher
- **Git**
- **VS Code** (recommended) or your preferred IDE

### Clone Repository

```bash
git clone https://github.com/ankurhalder/auth.git
cd auth
```

### Install Dependencies

```bash
pnpm install
```

### Generate JWT Keys

```bash
# Access token key pair
openssl genrsa -out private_key.pem 2048
openssl rsa -in private_key.pem -pubout -out public_key.pem

# Refresh token key pair
openssl genrsa -out refresh_private_key.pem 2048
openssl rsa -in refresh_private_key.pem -pubout -out refresh_public_key.pem
```

### Environment Variables

```bash
cp .env.example .env.local
```

Edit `.env.local` with your credentials. For development, you can use:

**MongoDB**: Use a free MongoDB Atlas M0 cluster
**Redis**: Use a free Upstash Redis instance
**Email**: Use Brevo free tier (300 emails/day)

**Generate encryption key:**

```bash
node -e "console.log(require('crypto').randomBytes(32).toString('hex'))"
```

**Generate cron secret:**

```bash
node -e "console.log(require('crypto').randomBytes(32).toString('base64'))"
```

### Database Initialization

Indexes are created automatically on server start via `src/instrumentation.ts`. No manual setup needed.

### Start Development Server

```bash
pnpm dev
```

Server starts at `http://localhost:3001` with Turbopack.

### Verify Setup

Test health endpoint:

```bash
curl http://localhost:3001/api/health
```

Expected response:

```json
{
  "success": true,
  "data": {
    "message": "Service healthy"
  }
}
```

## Development Workflow

### 1. Create Feature Branch

```bash
git checkout -b feature/your-feature-name
```

### 2. Make Changes

Follow the layer architecture:

- **New entity?** → `src/domain/entities/`
- **New use case?** → `src/application/use-cases/`
- **New repository?** → Interface in `src/domain/repositories/`, implementation in `src/infrastructure/database/`
- **New API endpoint?** → `app/api/your-endpoint/route.ts`

### 3. Run Linter

```bash
pnpm lint
```

Fix any linting errors. ESLint will catch architectural violations.

### 4. Run Type Check

```bash
pnpm type-check
```

Fix any TypeScript errors.

### 5. Test Your Changes

```bash
# Run all tests
pnpm test

# Run specific test
pnpm test src/domain/entities/user.entity.test.ts

# Watch mode
pnpm test:watch
```

### 6. Build Project

```bash
pnpm build
```

Ensure build succeeds before committing.

### 7. Commit Changes

```bash
git add .
git commit -m "feat: add your feature"
```

Use conventional commits:

- `feat:` New feature
- `fix:` Bug fix
- `docs:` Documentation
- `refactor:` Code refactoring
- `test:` Adding tests
- `chore:` Maintenance

### 8. Push and Create PR

```bash
git push origin feature/your-feature-name
```

Create pull request on GitHub.

## Code Style Guidelines

### TypeScript

**Use strict typing:**

```typescript
// ✅ Good
function createUser(email: string, password: string): User {
  return new User(email, password);
}

// ❌ Bad
function createUser(email: any, password: any) {
  return new User(email, password);
}
```

**Prefer interfaces for objects:**

```typescript
// ✅ Good
interface SignupInput {
  email: string;
  password: string;
}

// ❌ Bad (for DTOs)
type SignupInput = {
  email: string;
  password: string;
};
```

**Use readonly for immutability:**

```typescript
// ✅ Good
class User {
  constructor(
    public readonly id: string,
    public readonly email: Email
  ) {}
}
```

### Naming Conventions

- **Files**: `kebab-case.ts` (e.g., `user.entity.ts`)
- **Classes**: `PascalCase` (e.g., `SignupUseCase`)
- **Interfaces**: `IPascalCase` (e.g., `IUserRepository`)
- **Functions**: `camelCase` (e.g., `buildRequestContext`)
- **Constants**: `UPPER_SNAKE_CASE` (e.g., `MAX_ATTEMPTS`)

### File Organization

```
feature-name/
├── feature-name.entity.ts      # Domain entity
├── feature-name.repository.ts  # Repository interface
├── feature-name.use-case.ts    # Use case
├── feature-name.dto.ts         # DTOs
└── feature-name.test.ts        # Tests
```

### Import Order

```typescript
// 1. External imports
import { NextRequest, NextResponse } from "next/server";
import { z } from "zod";

// 2. Internal imports (by layer)
import { User } from "@domain/entities/user.entity";
import { SignupUseCase } from "@app/use-cases/signup.use-case";
import { UserRepositoryImpl } from "@infra/database/user.repository.impl";
import { successResponse } from "@presentation/helpers/response";

// 3. Relative imports
import { getDatabase } from "./database";
```

### Comments

**Use JSDoc for public APIs:**

```typescript
/**
 * Signs up a new user with email verification
 *
 * @param input - Signup input data
 * @returns Signup output with verification message
 * @throws ValidationError if input is invalid
 * @throws ConflictError if email already exists
 */
async execute(input: SignupInput): Promise<SignupOutput>
```

**Avoid obvious comments:**

```typescript
// ❌ Bad
// Increment counter
counter++;

// ✅ Good (when explaining why)
// Increment attempts to prevent brute force attacks
user.otp.attempts++;
```

### Error Handling

**Use domain errors:**

```typescript
// ✅ Good
throw new ValidationError("Invalid email format");

// ❌ Bad
throw new Error("Invalid email");
```

**Catch and rethrow with context:**

```typescript
try {
  await repository.save(user);
} catch (error) {
  throw new InfrastructureError("Failed to save user", { cause: error });
}
```

## Testing Strategies

### Unit Tests (Domain Layer)

Test pure business logic without dependencies:

```typescript
// user.entity.test.ts
import { User } from '@domain/entities/user.entity';
import { Email } from '@domain/value-objects/email.vo';

describe('User', () => {
  it('should increment token version', () => {
    const user = new User('id', new Email('test@example.com'), ...);
    const updated = user.incrementTokenVersion();

    expect(updated.tokenVersion.value).toBe(1);
  });
});
```

### Unit Tests (Application Layer)

Test use cases with mocked dependencies:

```typescript
// signup.use-case.test.ts
import { SignupUseCase } from "@app/use-cases/signup.use-case";
import { mock } from "jest-mock-extended";

describe("SignupUseCase", () => {
  it("should create user and send email", async () => {
    const mockUserRepo = mock<IUserRepository>();
    const mockEmailProvider = mock<IEmailProvider>();

    const useCase = new SignupUseCase(mockUserRepo, mockEmailProvider);
    await useCase.execute({
      email: "test@example.com",
      password: "Test123!@#",
    });

    expect(mockUserRepo.save).toHaveBeenCalled();
    expect(mockEmailProvider.sendVerificationEmail).toHaveBeenCalled();
  });
});
```

### Integration Tests

Test with real infrastructure (MongoDB, Redis):

```typescript
// signup.integration.test.ts
import { SignupUseCase } from "@app/use-cases/signup.use-case";
import { UserRepositoryImpl } from "@infra/database/user.repository.impl";
import { getTestDatabase } from "./test-helpers";

describe("SignupUseCase Integration", () => {
  let db: Db;

  beforeAll(async () => {
    db = await getTestDatabase();
  });

  afterAll(async () => {
    await db.dropDatabase();
  });

  it("should save user to database", async () => {
    const userRepo = new UserRepositoryImpl(db);
    const useCase = new SignupUseCase(userRepo, mockEmailProvider);

    await useCase.execute({
      email: "test@example.com",
      password: "Test123!@#",
    });

    const user = await userRepo.findByEmail(new Email("test@example.com"));
    expect(user).toBeDefined();
  });
});
```

### E2E Tests

Test complete API flows:

```typescript
// signup.e2e.test.ts
import { POST } from "@/app/api/auth/signup/route";

describe("POST /api/auth/signup", () => {
  it("should create user and return success", async () => {
    const request = new Request("http://localhost/api/auth/signup", {
      method: "POST",
      body: JSON.stringify({
        email: "test@example.com",
        password: "Test123!@#",
      }),
    });

    const response = await POST(request);
    const data = await response.json();

    expect(response.status).toBe(201);
    expect(data.success).toBe(true);
  });
});
```

## Debugging Tips

### Enable Debug Logging

Add console.log statements in development:

```typescript
if (process.env.NODE_ENV === "development") {
  console.log("Token payload:", payload);
  console.log("Session:", session);
}
```

### VS Code Debugging

Create `.vscode/launch.json`:

```json
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Next.js: debug server-side",
      "type": "node-terminal",
      "request": "launch",
      "command": "pnpm dev"
    }
  ]
}
```

Set breakpoints and press F5 to debug.

### Inspect Database

Use MongoDB Compass or mongosh:

```bash
mongosh "mongodb+srv://..."

use portfolio
db.users.find({ email: "test@example.com" })
db.sessions.find({ userId: ObjectId("...") })
```

### Inspect Redis

Use Upstash dashboard or Redis CLI:

```bash
redis-cli -h your-instance.upstash.io -p 6379 -a your-token

# View all keys
KEYS *

# Get specific key
GET "revoke:user:123"
```

### Test Email Delivery

Check Brevo dashboard → Statistics → Email to view sent emails.

### Network Debugging

Use curl to test endpoints:

```bash
# Signup
curl -X POST http://localhost:3001/api/auth/signup \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com","password":"Test123!@#"}'

# Signin
curl -X POST http://localhost:3001/api/auth/signin \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com","password":"Test123!@#"}'
```

## Common Tasks

### Add New Use Case

1. Define DTOs in `src/application/dtos/`
2. Create use case in `src/application/use-cases/`
3. Add validation schema in `src/presentation/validation/schemas.ts`
4. Create API route in `app/api/your-endpoint/route.ts`
5. Wire dependencies in route handler

### Add New Entity

1. Create entity in `src/domain/entities/`
2. Define repository interface in `src/domain/repositories/`
3. Create schema in `src/infrastructure/database/schemas/`
4. Implement repository in `src/infrastructure/database/`
5. Add indexes in `src/infrastructure/database/indexes.ts`

### Add New Middleware

1. Create middleware in `src/presentation/middleware/`
2. Apply in route handlers
3. Add to middleware chain in order: CORS → Rate Limit → CSRF → Auth

### Update Environment Variables

1. Add to `.env.example` with description
2. Add to `src/env.ts` for validation
3. Update documentation in `docs/infrastructure.md`

## Troubleshooting

### Build Errors

**"Module not found"**

- Check TypeScript path aliases in `tsconfig.json`
- Restart dev server
- Clear `.next` folder: `rm -rf .next`

**"Type error"**

- Run `pnpm type-check` to see all errors
- Check for missing type definitions
- Ensure strict mode compliance

### Runtime Errors

**"Invalid JWT signature"**

- Verify JWT keys match (private/public pair)
- Check key format (PEM with headers)
- Ensure no extra whitespace in env vars

**"CORS error"**

- Check `ALLOWED_ORIGINS` env var
- Verify origin in request headers
- Test with curl first (bypasses browser CORS)

**"Rate limit exceeded"**

- Clear Redis keys:check your rate limiting logic

### Performance Issues

**Slow response times**

- Check MongoDB indexes are created
- Review database query performance
- Enable connection pooling
- Consider Redis caching for frequent queries

**Memory leaks**

- Check for event listener leaks
- Review connection management
- Use Node.js memory profiling tools

---

## Summary

Development workflow:

1. Set up local environment
2. Create feature branch
3. Follow layer architecture
4. Write tests
5. Lint and type-check
6. Build successfully
7. Commit with conventional commits
8. Create pull request

Follow:

- [Architecture](architecture.md) for layer rules
- [Dependency Rules](dependency-rule.md) for import restrictions
- [Enforcement](enforcement.md) for validation details

Happy coding!


--------------------------------------------------------------------------------
File: docs\enforcement.md
--------------------------------------------------------------------------------

# Enforcement Documentation

This document explains how architectural boundaries and code quality standards are enforced in the authentication service.

## Overview

The authentication service uses multiple enforcement mechanisms to maintain code quality, architectural integrity, and prevent violations:

1. **ESLint** - Layer boundary enforcement
2. **TypeScript Strict Mode** - Type safety
3. **Import Restrictions** - Prevent circular dependencies
4. **Pre-commit Hooks** - Automatic validation before commits

## ESLint Layer Boundary Rules

### Configuration

Located in `eslint.config.mjs`:

```javascript
import { defineConfig } from "eslint/config";
import nextVitals from "eslint-config-next/core-web-vitals";
import nextTs from "eslint-config-next/typescript";

const eslintConfig = defineConfig([
  ...nextVitals,
  ...nextTs,

  // Layer boundary enforcement
  {
    files: ["src/domain/**/*.ts"],
    rules: {
      "no-restricted-imports": [
        "error",
        {
          patterns: [
            {
              group: ["@app/*", "@infra/*", "@presentation/*"],
              message:
                "Domain layer must not import from Application, Infrastructure, or Presentation.",
            },
            {
              group: ["next/*", "mongodb", "@upstash/*", "@getbrevo/*"],
              message:
                "Domain layer must not depend on framework or infrastructure packages.",
            },
          ],
        },
      ],
    },
  },

  {
    files: ["src/application/**/*.ts"],
    rules: {
      "no-restricted-imports": [
        "error",
        {
          patterns: [
            {
              group: ["@infra/*", "@presentation/*"],
              message:
                "Application layer must not import from Infrastructure or Presentation.",
            },
            {
              group: ["next/*", "mongodb", "@upstash/*"],
              message:
                "Application layer must not depend on framework or infrastructure packages directly.",
            },
          ],
        },
      ],
    },
  },

  {
    files: ["src/infrastructure/**/*.ts"],
    rules: {
      "no-restricted-imports": [
        "error",
        {
          patterns: [
            {
              group: ["@presentation/*"],
              message:
                "Infrastructure layer must not import from Presentation.",
            },
          ],
        },
      ],
    },
  },
]);

export default eslintConfig;
```

### How It Works

1. **File Pattern Matching**
   - ESLint scans files matching patterns (e.g., `src/domain/**/*.ts`)
   - Applies specific rules to each layer

2. **Import Pattern Detection**
   - Checks all import statements against restricted patterns
   - Matches against both path aliases (`@app/*`) and package names (`mongodb`)

3. **Error Reporting**
   - Violations reported with clear error messages
   - Build fails if violations detected
   - Provides actionable guidance

### Example Violations

**Domain Layer Violation:**

```typescript
// src/domain/entities/user.entity.ts
import { SignupUseCase } from "@app/use-cases/signup.use-case";
//     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Error: Domain layer must not import from Application, Infrastructure, or Presentation.
```

**Application Layer Violation:**

```typescript
// src/application/use-cases/signup.use-case.ts
import { UserRepositoryImpl } from "@infra/database/user.repository.impl";
//       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Error: Application layer must not import from Infrastructure or Presentation.
```

**Infrastructure Layer Violation:**

```typescript
// src/infrastructure/database/user.repository.impl.ts
import { successResponse } from "@presentation/helpers/response";
//       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Error: Infrastructure layer must not import from Presentation.
```

### Running ESLint

**Check for violations:**

```bash
pnpm lint
```

**Auto-fix violations:**

```bash
pnpm lint --fix
```

Note: Layer violations cannot be auto-fixed.

**Check specific file:**

```bash
pnpm lint src/domain/entities/user.entity.ts
```

## TypeScript Strict Mode

### Configuration

Located in `tsconfig.json`:

```json
{
  "compilerOptions": {
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "forceConsistentCasingInFileNames": true,
    "exactOptionalPropertyTypes": false
  }
}
```

### Strict Mode Features

**1. No Implicit Any**

```typescript
// ❌ Error: Parameter 'user' implicitly has an 'any' type
function processUser(user) {
  return user.email;
}

// ✅ Fixed
function processUser(user: User) {
  return user.email;
}
```

**2. Strict Null Checks**

```typescript
// ❌ Error: Object is possibly 'null'
const user = await userRepository.findById(id);
console.log(user.email);

// ✅ Fixed
const user = await userRepository.findById(id);
if (user) {
  console.log(user.email);
}
```

**3. No Unchecked Indexed Access**

```typescript
// ❌ Error: Element implicitly has an 'any' type
const users: User[] = [];
const firstUser = users[0];
firstUser.email; // Might be undefined!

// ✅ Fixed
const firstUser = users[0];
if (firstUser) {
  console.log(firstUser.email);
}
```

**4. No Implicit Returns**

```typescript
// ❌ Error: Not all code paths return a value
function getUserRole(user: User): string {
  if (user.role === "admin") {
    return "Administrator";
  }
  // Missing return!
}

// ✅ Fixed
function getUserRole(user: User): string {
  if (user.role === "admin") {
    return "Administrator";
  }
  return "User";
}
```

**5. Force Consistent Casing**

```typescript
// ❌ Error on Windows/Mac: Import casing mismatch
import { User } from "./User.entity"; // File: user.entity.ts

// ✅ Fixed
import { User } from "./user.entity";
```

### Running Type Check

**Check all files:**

```bash
pnpm type-check
```

**Watch mode:**

```bash
pnpm type-check --watch
```

**Build (includes type checking):**

```bash
pnpm build
```

## Import Restrictions per Layer

### Domain Layer Restrictions

**Allowed Imports:**

- ✅ Pure TypeScript types
- ✅ Other domain files
- ✅ Standard library (minimal)

**Blocked Imports:**

- ❌ `@app/*` (Application layer)
- ❌ `@infra/*` (Infrastructure layer)
- ❌ `@presentation/*` (Presentation layer)
- ❌ `next/*` (Next.js framework)
- ❌ `mongodb` (Database driver)
- ❌ `@upstash/*` (Redis client)
- ❌ `@getbrevo/*` (Email service)
- ❌ `bcrypt` (Crypto library)
- ❌ `jose` (JWT library)

**Example:**

```typescript
// src/domain/entities/user.entity.ts

// ✅ Allowed
import { Email } from "@domain/value-objects/email.vo";
import { HashedPassword } from "@domain/value-objects/hashed-password.vo";

// ❌ Blocked
import { SignupUseCase } from "@app/use-cases/signup.use-case";
import { MongoClient } from "mongodb";
import { NextRequest } from "next/server";
```

### Application Layer Restrictions

**Allowed Imports:**

- ✅ `@domain/*` (Domain layer)
- ✅ Pure TypeScript types
- ✅ Zod (for DTOs)

**Blocked Imports:**

- ❌ `@infra/*` (Infrastructure layer)
- ❌ `@presentation/*` (Presentation layer)
- ❌ `next/*` (Framework)
- ❌ `mongodb` (Database)
- ❌ `@upstash/*` (Redis)

**Example:**

```typescript
// src/application/use-cases/signup.use-case.ts

// ✅ Allowed
import { User } from "@domain/entities/user.entity";
import { IUserRepository } from "@domain/repositories/user.repository";
import { ValidationError } from "@domain/errors/validation.error";

// ❌ Blocked
import { UserRepositoryImpl } from "@infra/database/user.repository.impl";
import { successResponse } from "@presentation/helpers/response";
import { NextRequest } from "next/server";
```

### Infrastructure Layer Restrictions

**Allowed Imports:**

- ✅ `@domain/*` (Domain layer)
- ✅ `@app/*` (Application layer)
- ✅ External libraries (mongodb, redis, etc.)
- ✅ Node.js modules

**Blocked Imports:**

- ❌ `@presentation/*` (Presentation layer)

**Example:**

```typescript
// src/infrastructure/database/user.repository.impl.ts

// ✅ Allowed
import { User } from "@domain/entities/user.entity";
import { IUserRepository } from "@domain/repositories/user.repository";
import { Db, Collection } from "mongodb";
import * as crypto from "node:crypto";

// ❌ Blocked
import { buildRequestContext } from "@presentation/helpers/request-context";
```

### Presentation Layer Restrictions

**Allowed Imports:**

- ✅ All layers (`@domain/*`, `@app/*`, `@infra/*`)
- ✅ Next.js framework
- ✅ Libraries

**Blocked Imports:**

- None (outermost layer)

**Example:**

```typescript
// app/api/auth/signup/route.ts

// ✅ All allowed
import { SignupUseCase } from "@app/use-cases/signup.use-case";
import { UserRepositoryImpl } from "@infra/database/user.repository.impl";
import { ValidationError } from "@domain/errors/validation.error";
import { NextRequest, NextResponse } from "next/server";
```

## Pre-commit Validation

### Validation Steps

The pre-commit hook runs these checks:

```javascript
// scripts/pre-commit.js

async function preCommit() {
  console.log("🔍 Pre-commit validation started...\n");

  // 1. Remove comments
  await removeComments();

  // 2. Format code
  await formatCode();

  // 3. Lint code
  await lintCode();

  // 4. Type check
  await typeCheck();

  // 5. Build project
  await buildProject();

  // 6. Validate architectural boundaries
  await validateArchitecturalBoundaries();

  console.log("\n✅ Pre-commit validation passed!");
}
```

### Architectural Boundary Validation

```javascript
async function validateArchitecturalBoundaries() {
  console.log("🏗️  Validating architectural boundaries...");

  const violations = [];

  // Check Domain layer
  const domainFiles = glob.sync("src/domain/**/*.ts");
  for (const file of domainFiles) {
    const content = fs.readFileSync(file, "utf8");

    // Domain cannot import from outer layers
    const outerLayerImports = content.match(/@app\/|@infra\/|@presentation\//g);
    if (outerLayerImports) {
      violations.push({
        file,
        type: "domain-import-violation",
        message: `Domain layer imports from outer layer: ${outerLayerImports.join(", ")}`,
      });
    }

    // Domain cannot import frameworks
    const frameworkImports = content.match(
      /from ['"](?:next\/|mongodb|@upstash\/|@getbrevo\/)/g
    );
    if (frameworkImports) {
      violations.push({
        file,
        type: "domain-framework-violation",
        message: `Domain layer imports framework: ${frameworkImports.join(", ")}`,
      });
    }
  }

  // Check Application layer
  const appFiles = glob.sync("src/application/**/*.ts");
  for (const file of appFiles) {
    const content = fs.readFileSync(file, "utf8");

    // Application cannot import from Infrastructure or Presentation
    const restrictedImports = content.match(/@infra\/|@presentation\//g);
    if (restrictedImports) {
      violations.push({
        file,
        type: "application-import-violation",
        message: `Application layer imports from restricted layer: ${restrictedImports.join(", ")}`,
      });
    }
  }

  // Check Infrastructure layer
  const infraFiles = glob.sync("src/infrastructure/**/*.ts");
  for (const file of infraFiles) {
    const content = fs.readFileSync(file, "utf8");

    // Infrastructure cannot import from Presentation
    const presentationImports = content.match(/@presentation\//g);
    if (presentationImports) {
      violations.push({
        file,
        type: "infrastructure-import-violation",
        message: "Infrastructure layer imports from Presentation layer",
      });
    }
  }

  if (violations.length > 0) {
    console.error("\n❌ Architectural boundary violations detected:\n");
    violations.forEach((v) => {
      console.error(`  ${v.file}`);
      console.error(`    ${v.message}\n`);
    });
    throw new Error(`Found ${violations.length} architectural violations`);
  }

  console.log("   ✓ No architectural boundary violations");
}
```

### Setup Pre-commit Hook

**Install husky:**

```bash
pnpm add -D husky
npx husky install
```

**Add pre-commit hook:**

```bash
npx husky add .husky/pre-commit "node scripts/pre-commit.js"
```

**Test pre-commit:**

```bash
git add .
git commit -m "test: verify pre-commit hook"
```

## Common Violations and How to Avoid Them

### Violation 1: Importing Use Case in Domain

```typescript
// ❌ WRONG
// src/domain/entities/user.entity.ts
import { SignupUseCase } from "@app/use-cases/signup.use-case";
```

**Fix:**

- Remove the import
- Domain entities should not know about use cases
- Move shared logic to domain services if needed

### Violation 2: Importing Repository Implementation in Application

```typescript
// ❌ WRONG
// src/application/use-cases/signup.use-case.ts
import { UserRepositoryImpl } from "@infra/database/user.repository.impl";
```

**Fix:**

- Import interface instead: `import { IUserRepository } from '@domain/repositories/user.repository';`
- Inject implementation from presentation layer
- Use dependency injection pattern

### Violation 3: Using MongoDB Types in Domain

```typescript
// ❌ WRONG
// src/domain/entities/user.entity.ts
import { ObjectId } from "mongodb";

export class User {
  constructor(public readonly _id: ObjectId) {}
}
```

**Fix:**

- Use primitive types in domain: `constructor(public readonly id: string) {}`
- Convert in infrastructure layer mapper
- Keep domain pure and framework-agnostic

### Violation 4: Direct Framework Usage in Application

```typescript
// ❌ WRONG
// src/application/use-cases/signup.use-case.ts
import { NextRequest } from "next/server";

class SignupUseCase {
  async execute(request: NextRequest) {}
}
```

**Fix:**

- Define DTOs in application layer
- Extract data in presentation layer
- Pass plain objects to use cases

## Summary

The authentication service enforces:

1. **ESLint Rules**: Prevent layer violations at lint time
2. **TypeScript Strict Mode**: Ensure type safety
3. **Import Restrictions**: Block framework dependencies in core layers
4. **Pre-commit Hooks**: Validate before every commit

**Benefits:**

- Catches violations early (development time)
- Prevents architectural drift
- Ensures maintainable codebase
- Enables confident refactoring

**Commands:**

```bash
pnpm lint              # Check ESLint rules
pnpm type-check        # Check TypeScript types
pnpm build             # Full build with all checks
git commit             # Triggers pre-commit validation
```

For more details, see:

- [Architecture](architecture.md)
- [Dependency Rules](dependency-rule.md)
- [Development Guide](development.md)


--------------------------------------------------------------------------------
File: docs\features.md
--------------------------------------------------------------------------------

# Features Documentation

Complete feature documentation for the authentication service, including detailed flows, security measures, and implementation details.

## Table of Contents

- [Authentication Flows](#authentication-flows)
- [Token Management](#token-management)
- [Token Revocation](#token-revocation)
- [Session Management](#session-management)
- [OTP System](#otp-system)
- [Email Verification](#email-verification)
- [Password Reset Flow](#password-reset-flow)
- [Rate Limiting Strategy](#rate-limiting-strategy)
- [Audit Logging](#audit-logging)
- [Security Headers](#security-headers)

## Authentication Flows

### User Registration Flow (Standard User)

**Endpoint:** `POST /api/auth/signup`

**Request:**

```json
{
  "email": "user@example.com",
  "password": "Test123!@#"
}
```

**Flow Diagram:**

```
┌─────────┐                                           ┌──────────┐
│  Client │                                           │  Server  │
└────┬────┘                                           └─────┬────┘
     │                                                      │
     │  POST /api/auth/signup                              │
     │  { email, password }                                │
     ├─────────────────────────────────────────────────────>│
     │                                                      │
     │                                (1) Validate password complexity
     │                                      (8+, upper, lower, digit, special)
     │                                                      │
     │                                (2) Check email uniqueness
     │                                      └─> MongoDB query
     │                                                      │
     │                                (3) Hash password
     │                                      └─> bcrypt(password, 12)
     │                                                      │
     │                                (4) Generate verification token
     │                                      └─> 64 hex chars
     │                                                      │
     │                                (5) Hash token
     │                                      └─> SHA256(token)
     │                                                      │
     │                                (6) Encrypt token
     │                                      └─> AES-256-CBC
     │                                                      │
     │                                (7) Store user
     │                                      └─> MongoDB insert
     │                                                      │
     │                                (8) Send email (fire-and-forget)
     │                                      └─> Brevo API
     │                                                      │
     │                                (9) Log event
     │                                      └─> AuthEvents collection
     │                                                      │
     │  201 Created                                         │
     │  { message: "Verification email sent" }             │
     │<─────────────────────────────────────────────────────┤
     │                                                      │
```

**Steps:**

1. **Validate password complexity** (Use Case layer)
   - Minimum 8 characters
   - At least one uppercase letter
   - At least one lowercase letter
   - At least one digit
   - At least one special character

2. **Check email uniqueness** (Repository layer)
   - Query MongoDB for existing email
   - Return 409 Conflict if exists

3. **Hash password** (Infrastructure layer)
   - Use bcrypt with cost factor 12
   - Timing: ~150-300ms (intentionally slow)

4. **Generate verification token**
   - 64 random hex characters
   - Cryptographically secure (crypto.randomBytes)

5. **Hash token** (SHA256)
   - Store hash in database for lookup
   - Original token sent to user email

6. **Encrypt token** (AES-256-CBC)
   - Additional layer of protection
   - If database is compromised, tokens are still encrypted

7. **Store user** (MongoDB)
   - User document with hashed password
   - Verification token hash + encrypted token
   - `isVerified: false`
   - `tokenVersion: 0`

8. **Send verification email** (Fire-and-forget)
   - Async operation using p-retry
   - Link: `https://www.ankurhalder.com/verify-email?token=${token}`
   - Failure doesn't block signup
   - User can request resend

9. **Log audit event**
   - Event type: "signup"
   - IP address, user agent, request ID
   - Stored in AuthEvents collection

**Response:**

```json
{
  "success": true,
  "data": {
    "message": "Account created. Please check your email to verify your account."
  }
}
```

**Security Considerations:**

- Password hashed with bcrypt (cost 12)
- Token encrypted in database
- Enumeration protected (same response for all errors)
- Rate limited (5/hour per IP)

### User Sign-In Flow (Standard User)

**Endpoint:** `POST /api/auth/signin`

**Request:**

```json
{
  "email": "user@example.com",
  "password": "Test123!@#",
  "rememberMe": true
}
```

**Flow Diagram:**

```
┌─────────┐                                           ┌──────────┐
│  Client │                                           │  Server  │
└────┬────┘                                           └─────┬────┘
     │                                                      │
     │  POST /api/auth/signin                              │
     │  { email, password, rememberMe }                    │
     ├─────────────────────────────────────────────────────>│
     │                                                      │
     │                                (1) Find user by email
     │                                      └─> MongoDB query
     │                                                      │
     │                                (2) Check if email is verified
     │                                      └─> isVerified === true
     │                                                      │
     │                                (3) Verify password
     │                                      └─> bcrypt.compare()
     │                                                      │
     │                                (4) Check user role
     │                                      └─> role === "user" or "admin"
     │                                                      │
     │                              If admin:              │
     │                                (5a) Generate OTP    │
     │                                (6a) Encrypt OTP     │
     │                                (7a) Apply rate limit│
     │                                (8a) Send OTP email  │
     │                                (9a) Return pending  │
     │                                                      │
     │                              If user:               │
     │                                (5b) Create session  │
     │                                (6b) Generate tokens │
     │                                (7b) Set cookies     │
     │                                (8b) Return tokens   │
     │                                                      │
     │  200 OK (user) or 202 Accepted (admin)              │
     │  Set-Cookie: accessToken, refreshToken              │
     │<─────────────────────────────────────────────────────┤
     │                                                      │
```

**User Path Steps:**

1. **Find user** by email (case-insensitive)
2. **Check verification** - Email must be verified
3. **Verify password** using bcrypt (timing-safe)
4. **Auto-migrate** from PBKDF2 to bcrypt if needed
5. **Create session**:
   - Generate session ID (UUID v4)
   - Generate JTI (UUID v4)
   - Calculate expiry (7 days or 30 days with rememberMe)
   - Hash refresh token (SHA256)
   - Store in sessions collection
6. **Generate JWT tokens**:
   - **Access token**: 15 minutes expiry, signed with RS256
   - **Refresh token**: 7/30 days expiry, signed with RS256
7. **Set HTTP-only cookies**:
   - `accessToken` cookie
   - `refreshToken` cookie
   - Secure, HttpOnly, SameSite=Lax
   - Domain: `.ankurhalder.com`
8. **Log audit event** (signin)
9. **Return response** with user data

**Response (User):**

```json
{
  "success": true,
  "data": {
    "user": {
      "id": "...",
      "email": "user@example.com",
      "role": "user",
      "isVerified": true
    },
    "requiresOtp": false
  }
}
```

**Admin Path Steps:**

1-4. Same as user path 5. **Generate OTP**:

- 8 random digits (00000000 - 99999999)
- Cryptographically secure (crypto.randomInt)

6. **Encrypt OTP**:
   - AES-256-CBC encryption
   - Store encrypted OTP in user document
7. **Apply rate limiting**:
   - Escalating backoff per user
   - 1 min → 5 min → 15 min → 1 hour
8. **Send OTP email** (fire-and-forget)
9. **Return pending response**

**Response (Admin):**

```json
{
  "success": true,
  "data": {
    "requiresOtp": true,
    "message": "OTP sent to your email"
  }
}
```

**Security Considerations:**

- Timing-safe password comparison
- Auto-migration for legacy passwords
- OTP for admin users (2FA)
- Rate limiting (10/15min per IP)
- Audit logging for all attempts

### Admin OTP Verification Flow

**Endpoint:** `POST /api/auth/verify-otp`

**Request:**

```json
{
  "email": "admin@example.com",
  "otp": "12345678",
  "rememberMe": true
}
```

**Flow Diagram:**

```
┌─────────┐                                           ┌──────────┐
│  Client │                                           │  Server  │
└────┬────┘                                           └─────┬────┘
     │                                                      │
     │  POST /api/auth/verify-otp                          │
     │  { email, otp, rememberMe }                         │
     ├─────────────────────────────────────────────────────>│
     │                                                      │
     │                                (1) Find admin user  │
     │                                                      │
     │                                (2) Check OTP exists │
     │                                                      │
     │                                (3) Check OTP not expired
     │                                      └─> expiresAt > now
     │                                                      │
     │                                (4) Check attempts < 5
     │                                                      │
     │                                (5) Decrypt OTP      │
     │                                      └─> AES-256-CBC
     │                                                      │
     │                                (6) Verify OTP (timing-safe)
     │                                      └─> constant time compare
     │                                                      │
     │                                (7) Create session   │
     │                                (8) Generate tokens  │
     │                                (9) Clear OTP        │
     │                                (10) Reset rate limit│
     │                                (11) Set cookies     │
     │                                                      │
     │  200 OK                                              │
     │  Set-Cookie: accessToken, refreshToken              │
     │<─────────────────────────────────────────────────────┤
     │                                                      │
```

**Steps:**

1. Find admin user by email
2. Validate OTP exists in user document
3. Check OTP not expired (15 minutes)
4. Check attempts < 5 (increment on failure)
5. Decrypt OTP using AES-256-CBC
6. Verify OTP using timing-safe comparison
7. Create session (same as user signin)
8. Generate JWT tokens
9. Clear OTP from user document
10. Reset rate limit for this admin
11. Set HTTP-only cookies

**Response:**

```json
{
  "success": true,
  "data": {
    "user": {
      "id": "...",
      "email": "admin@example.com",
      "role": "admin",
      "isVerified": true
    }
  }
}
```

**Error Scenarios:**

1. **Invalid OTP**: Increment attempts, return error
2. **Expired OTP**: Clear OTP, return error
3. **Max attempts**: Clear OTP, return error
4. **Rate limit**: Return 429 Too Many Requests

## Token Management

### Token Structure

**Access Token Payload:**

```json
{
  "sub": "user-id",
  "email": "user@example.com",
  "role": "user",
  "tokenVersion": 0,
  "type": "access",
  "jti": "uuid-v4",
  "iat": 1234567890,
  "exp": 1234568790
}
```

**Refresh Token Payload:**

```json
{
  "sub": "user-id",
  "sessionId": "session-uuid",
  "type": "refresh",
  "jti": "uuid-v4",
  "iat": 1234567890,
  "exp": 1234999999
}
```

### Token Lifetimes

- **Access Token**: 15 minutes
- **Refresh Token**: 7 days (default) or 30 days (rememberMe)

### Token Refresh Flow (Atomic Rotation)

**Endpoint:** `POST /api/auth/refresh`

**Request:**

```
Cookie: refreshToken=eyJhbGc...
```

**Flow Diagram:**

```
┌─────────┐                                           ┌──────────┐
│  Client │                                           │  Server  │
└────┬────┘                                           └─────┬────┘
     │                                                      │
     │  POST /api/auth/refresh                             │
     │  Cookie: refreshToken                               │
     ├─────────────────────────────────────────────────────>│
     │                                                      │
     │                                (1) Verify JWT signature + expiry
     │                                      └─> jose.jwtVerify()
     │                                                      │
     │                                (2) Hash refresh token
     │                                      └─> SHA256(token)
     │                                                      │
     │                                (3) Atomic find-and-delete session
     │                                      └─> findOneAndDelete()
     │                                      (Replay detection!)
     │                                                      │
     │                                (4) Check revocation (3 levels)
     │                                      - Token level (jti)
     │                                      - Session level (sessionId)
     │                                      - User level (userId + tokenVersion)
     │                                                      │
     │                                (5) Verify user exists
     │                                      └─> Find by ID
     │                                                      │
     │                                (6) Verify tokenVersion matches
     │                                                      │
     │                                (7) Create new session
     │                                      └─> New session ID
     │                                      └─> New JTI
     │                                      └─> Preserve TTL
     │                                                      │
     │                                (8) Generate new tokens
     │                                      └─> New access + refresh
     │                                                      │
     │  200 OK                                              │
     │  Set-Cookie: accessToken, refreshToken              │
     │<─────────────────────────────────────────────────────┤
     │                                                      │
```

**8-Step Verification Chain:**

1. **JWT Signature Verification**
   - Verify RS256 signature using public key
   - Check token not expired
   - Validate token structure

2. **Hash Refresh Token**
   - SHA256 hash for database lookup
   - Prevents storing raw tokens

3. **Atomic Find-and-Delete** (CRITICAL)
   - Use `findOneAndDelete()` for atomicity
   - If session not found → Token already used (replay attack)
   - This is the key to preventing replay attacks

4. **Check Revocation Store** (3 levels)
   - Token-level: Check `revoke:token:${jti}`
   - Session-level: Check `revoke:session:${sessionId}`
   - User-level: Check `revoke:user:${userId}` timestamp

5. **Verify User Exists**
   - User may have been deleted
   - Return 401 if not found

6. **Verify Token Version**
   - Check payload `tokenVersion` matches user's `tokenVersion`
   - Protects against global logout

7. **Create New Session**
   - Generate new session ID (rotation)
   - Generate new JTI
   - Preserve TTL from old session (rememberMe state)
   - Store with new refresh token hash

8. **Generate New Tokens**
   - Issue new access token (15 min)
   - Issue new refresh token (same TTL as old)
   - Old refresh token now invalid

**Response:**

```json
{
  "success": true,
  "data": {
    "message": "Token refreshed"
  }
}
```

**Security Features:**

- **Atomic rotation**: Old token deleted before new one created
- **Replay detection**: Reused tokens immediately detected
- **Triple revocation check**: 3 layers of protection
- **Token version**: Global logout protection
- **TTL preservation**: Maintains rememberMe preference

## Token Revocation

Three levels of token revocation for maximum security.

### Level 1: Token-Level Revocation

Revoke a specific JWT token.

**Use Case:** Single token compromised

**Implementation:**

```typescript
// Store in Redis
key: `revoke:token:${jti}`;
value: "1";
ttl: token.exp - Date.now();
```

**Check:**

```typescript
const isRevoked = await redis.get(`revoke:token:${jti}`);
if (isRevoked) throw new TokenError("Token revoked");
```

### Level 2: Session-Level Revocation

Revoke all tokens in a session (access + refresh).

**Use Case:** User logs out from one device

**Endpoint:** `POST /api/auth/logout`

**Implementation:**

```typescript
// Store in Redis
key: `revoke:session:${sessionId}`
value: "1"
ttl: 30 days

// Delete session from MongoDB
await sessionRepository.deleteBySessionId(sessionId)
```

**Check:**

```typescript
const isRevoked = await redis.get(`revoke:session:${sessionId}`);
if (isRevoked) throw new TokenError("Session revoked");
```

### Level 3: User-Level Revocation

Revoke ALL tokens for a user (global logout).

**Use Case:** User logs out from all devices, password reset, security breach

**Endpoint:** `POST /api/auth/logout-all`

**Implementation:**

```typescript
// 1. Increment tokenVersion in user document
await userRepository.incrementTokenVersion(userId)

// 2. Store revocation timestamp in Redis
key: `revoke:user:${userId}`
value: Date.now().toString()
ttl: 30 days

// 3. Delete all sessions from MongoDB
await sessionRepository.deleteAllByUserId(userId)
```

**Check:**

```typescript
// Check if token was issued before revocation
const revokedAt = await redis.get(`revoke:user:${userId}`);
if (revokedAt && token.iat * 1000 < parseInt(revokedAt)) {
  throw new TokenError("User revoked");
}

// Check tokenVersion matches
if (token.tokenVersion !== user.tokenVersion) {
  throw new TokenError("Token version mismatch");
}
```

**Revocation Matrix:**

| Action         | Token | Session | User | Method                                    |
| -------------- | ----- | ------- | ---- | ----------------------------------------- |
| Logout         | ✓     | ✓       | -    | Redis + MongoDB delete                    |
| Logout All     | ✓     | ✓       | ✓    | tokenVersion + Redis + MongoDB delete all |
| Password Reset | ✓     | ✓       | ✓    | tokenVersion + Redis + MongoDB delete all |

## Session Management

### Session Document Structure

```typescript
{
  _id: ObjectId("..."),
  sessionId: "uuid-v4",
  userId: ObjectId("..."),
  refreshTokenHash: "sha256-hash",
  jti: "uuid-v4",
  expiresAt: Date("2026-02-21T..."),
  createdAt: Date("2026-02-14T...")
}
```

### Session Operations

**Create Session:**

```typescript
const session = new Session({
  sessionId: SessionId.generate(),
  userId: user.id,
  refreshTokenHash: hashRefreshToken(token),
  jti: Jti.generate(),
  expiresAt: rememberMe ? add30Days() : add7Days(),
});
await sessionRepository.save(session);
```

**Find and Delete (Atomic):**

```typescript
const session = await sessionRepository.findOneAndDelete({
  refreshTokenHash: hash,
});
if (!session) throw new TokenError("Invalid refresh token");
```

**Delete All User Sessions:**

```typescript
await sessionRepository.deleteAllByUserId(userId);
```

### Cleanup Strategy

**TTL Indexes:**

- MongoDB automatically deletes expired sessions via TTL index on `expiresAt`
- TTL monitor runs every 60 seconds

**Cron Job:**

- Manual cleanup via `/api/cron/cleanup`
- Runs daily at midnight
- Cleans up:
  - Expired sessions
  - Expired verification tokens
  - Expired reset tokens
  - Expired OTPs
  - Old audit events (90+ days)

## OTP System

### OTP Generation

```typescript
// Generate 8-digit OTP
const otp = crypto.randomInt(10000000, 99999999).toString();
// Result: "12345678"
```

### OTP Encryption

```typescript
// Encrypt using AES-256-CBC
const iv = crypto.randomBytes(16);
const cipher = crypto.createCipheriv("aes-256-cbc", encryptionKey, iv);
const encrypted = Buffer.concat([cipher.update(otp, "utf8"), cipher.final()]);
const encryptedOtp = iv.toString("hex") + ":" + encrypted.toString("hex");
// Result: "iv:encrypted"
```

### OTP Storage

```typescript
// Store in user document
user.otp = {
  encrypted: encryptedOtp,
  expiresAt: new Date(Date.now() + 15 * 60 * 1000), // 15 min
  attempts: 0,
};
```

### OTP Verification

```typescript
// Timing-safe comparison
function verifyOtp(inputOtp: string, storedEncrypted: string): boolean {
  const decrypted = decrypt(storedEncrypted);
  return timingSafeEqual(Buffer.from(inputOtp), Buffer.from(decrypted));
}
```

### OTP Rate Limiting

Escalating backoff per user:

```typescript
// After first OTP request
rate limit: 1 minute

// After second OTP request
rate limit: 5 minutes

// After third OTP request
rate limit: 15 minutes

// After fourth OTP request
rate limit: 1 hour
```

Implementation uses Upstash Ratelimit with sliding window.

### OTP Security

- **Generation**: Cryptographically secure random
- **Encryption**: AES-256-CBC with random IV
- **Expiry**: 15 minutes
- **Max attempts**: 5 attempts before lockout
- **Rate limiting**: Escalating backoff
- **Timing-safe**: Constant-time comparison
- **Single-use**: Cleared after successful verification

## Email Verification

### Verification Token Generation

```typescript
// Generate 64 hex characters (32 bytes)
const token = crypto.randomBytes(32).toString("hex");
// Result: "a1b2c3d4e5f6...64 chars"
```

### Token Storage

```typescript
// Hash for lookup
const hash = crypto.createHash("sha256").update(token).digest("hex");

// Encrypt for additional protection
const encrypted = encrypt(token); // AES-256-CBC

// Store both
user.verificationToken = {
  hash: hash,
  encryptedToken: encrypted,
  expiresAt: new Date(Date.now() + 60 * 60 * 1000), // 1 hour
};
```

### Verification Flow

**Endpoint:** `POST /api/auth/verify-email`

**Request:**

```json
{
  "token": "a1b2c3d4e5f6...64 chars"
}
```

**Steps:**

1. Hash incoming token (SHA256)
2. Find user by `verificationToken.hash`
3. Check token not expired
4. Set `isVerified = true`
5. Clear `verificationToken` (one-time use)
6. Save user

**Response:**

```json
{
  "success": true,
  "data": {
    "message": "Email verified successfully"
  }
}
```

### Resend Verification

**Endpoint:** `POST /api/auth/resend-verification`

**Request:**

```json
{
  "email": "user@example.com"
}
```

**Security:**

- Enumeration protected (same response for all cases)
- Rate limited (3/hour per IP)
- Generates new token (invalidates old)
- Fire-and-forget email sending

## Password Reset Flow

### Request Password Reset

**Endpoint:** `POST /api/auth/forgot-password`

**Request:**

```json
{
  "email": "user@example.com"
}
```

**Flow:**

1. Find user by email (or fake processing if not found)
2. Generate reset token (64 hex chars)
3. Hash token (SHA256)
4. Encrypt token (AES-256-CBC)
5. Store in user document with 1-hour expiry
6. Send reset email (fire-and-forget)
7. Return success (always, enumeration protection)

**Response:**

```json
{
  "success": true,
  "data": {
    "message": "If that email exists, a reset link has been sent."
  }
}
```

### Reset Password

**Endpoint:** `POST /api/auth/reset-password`

**Request:**

```json
{
  "token": "a1b2c3d4e5f6...64 chars",
  "newPassword": "NewPassword123!@#"
}
```

**Flow:**

1. Hash incoming token (SHA256)
2. Find user by `resetToken.hash`
3. Check token not expired
4. Validate new password complexity
5. Hash new password (bcrypt, cost 12)
6. Update user password
7. Increment `tokenVersion` (invalidates all sessions)
8. Store revocation timestamp in Redis
9. Delete all sessions from MongoDB
10. Clear `resetToken` (one-time use)
11. Save user
12. Return success

**Response:**

```json
{
  "success": true,
  "data": {
    "message": "Password reset successful. Please sign in with your new password."
  }
}
```

**Security:**

- Forces re-authentication (all sessions invalidated)
- One-time use token
- Time-limited (1 hour)
- New password must meet complexity requirements

## Rate Limiting Strategy

Implemented using Upstash Ratelimit with sliding window algorithm.

### Rate Limits by Endpoint

| Endpoint                        | Limit      | Window      | Key        |
| ------------------------------- | ---------- | ----------- | ---------- |
| `/api/auth/signup`              | 5          | 1 hour      | IP address |
| `/api/auth/signin`              | 10         | 15 minutes  | IP address |
| `/api/auth/forgot-password`     | 3          | 1 hour      | IP address |
| `/api/auth/resend-verification` | 3          | 1 hour      | IP address |
| `/api/auth/verify-otp`          | Escalating | Per attempt | User email |

### OTP Rate Limiting (Escalating)

```typescript
Attempt 1: Wait 0 seconds
Attempt 2: Wait 60 seconds (1 minute)
Attempt 3: Wait 300 seconds (5 minutes)
Attempt 4: Wait 900 seconds (15 minutes)
Attempt 5: Wait 3600 seconds (1 hour)
```

### Implementation

```typescript
import { Ratelimit } from "@upstash/ratelimit";
import { Redis } from "@upstash/redis";

const redis = new Redis({
  url: process.env.UPSTASH_REDIS_REST_URL!,
  token: process.env.UPSTASH_REDIS_REST_TOKEN!,
});

const signupLimiter = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(5, "1 h"),
  analytics: true,
});

// In middleware
const { success, limit, remaining, reset } = await signupLimiter.limit(ip);

if (!success) {
  throw new RateLimitError("Too many requests. Please try again later.");
}
```

### Rate Limit Headers

Response includes:

```
X-RateLimit-Limit: 5
X-RateLimit-Remaining: 4
X-RateLimit-Reset: 1708012800
```

## Audit Logging

All authentication events are logged to MongoDB for security auditing.

### Event Types

- `signup`: User registration
- `signin`: Successful sign-in
- `signin_failed`: Failed sign-in attempt
- `otp_sent`: OTP sent to admin
- `otp_verified`: OTP successfully verified
- `email_verified`: Email verification completed
- `password_reset_requested`: Password reset requested
- `password_reset_completed`: Password reset completed
- `token_refreshed`: Access token refreshed
- `logout`: User logged out
- `logout_all`: User logged out from all devices

### Event Document Structure

```typescript
{
  _id: ObjectId("..."),
  eventType: "signin",
  userId: ObjectId("..."),       // Optional (not present for failed signin)
  email: "user@example.com",
  ip: "192.168.1.1",
  userAgent: "Mozilla/5.0...",
  requestId: "uuid-v4",
  metadata: {                    // Optional additional data
    success: true,
    reason: "..."
  },
  createdAt: Date("2026-02-14T...")
}
```

### Retention Policy

- Events older than **90 days** are automatically deleted via TTL index
- Can be extended for compliance requirements

### Querying Audit Logs

```javascript
// Recent events for a user
db.authEvents
  .find({ userId: ObjectId("...") })
  .sort({ createdAt: -1 })
  .limit(10);

// Failed signin attempts
db.authEvents.find({
  eventType: "signin_failed",
  createdAt: { $gte: new Date("2026-02-13") },
});

// All events by IP
db.authEvents.find({ ip: "192.168.1.1" }).sort({ createdAt: -1 });
```

## Security Headers

Configured in `vercel.json`:

```json
{
  "headers": [
    {
      "source": "/(.*)",
      "headers": [
        {
          "key": "X-Frame-Options",
          "value": "DENY"
        },
        {
          "key": "X-Content-Type-Options",
          "value": "nosniff"
        },
        {
          "key": "X-XSS-Protection",
          "value": "1; mode=block"
        },
        {
          "key": "Referrer-Policy",
          "value": "strict-origin-when-cross-origin"
        },
        {
          "key": "Content-Security-Policy",
          "value": "default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline';"
        },
        {
          "key": "Strict-Transport-Security",
          "value": "max-age=31536000; includeSubDomains"
        }
      ]
    }
  ]
}
```

### Header Explanations

**X-Frame-Options: DENY**

- Prevents clickjacking attacks
- Page cannot be embedded in iframes

**X-Content-Type-Options: nosniff**

- Prevents MIME type sniffing
- Forces browser to respect Content-Type header

**X-XSS-Protection: 1; mode=block**

- Enables browser XSS filter
- Blocks page if XSS attack detected

**Referrer-Policy: strict-origin-when-cross-origin**

- Sends full URL for same-origin requests
- Sends only origin for cross-origin requests
- No referrer for downgrades (HTTPS → HTTP)

**Content-Security-Policy**

- Restricts resource loading
- Only allows scripts/styles from same origin
- Mitigates XSS and data injection attacks

**Strict-Transport-Security**

- Forces HTTPS connections
- Valid for 1 year
- Includes subdomains

---

## Summary

This authentication service implements:

- **Comprehensive authentication flows** for users and admins
- **Atomic token rotation** with replay detection
- **Triple-layer revocation** (token, session, user levels)
- **Secure session management** with TTL cleanup
- **OTP system** with encryption and rate limiting
- **Email verification** with time-limited tokens
- **Password reset** with forced re-authentication
- **Robust rate limiting** with escalating backoff
- **Comprehensive audit logging** with 90-day retention
- **Security headers** for defense in depth

All features are designed with security-first principles and production-grade implementation.


--------------------------------------------------------------------------------
File: docs\infrastructure.md
--------------------------------------------------------------------------------

# Infrastructure Setup Guide

This document provides comprehensive infrastructure setup instructions for the authentication service, covering MongoDB Atlas, Upstash Redis, Brevo email provider, JWT key generation, and deployment to Vercel.

## Table of Contents

- [MongoDB Atlas Setup](#mongodb-atlas-setup)
- [Upstash Redis Setup](#upstash-redis-setup)
- [Brevo Email Provider Setup](#brevo-email-provider-setup)
- [JWT Key Generation](#jwt-key-generation)
- [Environment Variables](#environment-variables)
- [Vercel Deployment](#vercel-deployment)
- [Custom Domain Setup](#custom-domain-setup)
- [Production Considerations](#production-considerations)

## MongoDB Atlas Setup

### 1. Create MongoDB Atlas Account

1. Go to [MongoDB Atlas](https://www.mongodb.com/cloud/atlas)
2. Sign up for a free account or log in
3. Create a new organization (if needed)
4. Create a new project (e.g., "Portfolio Auth")

### 2. Create Database Cluster

1. Click "Build a Database"
2. Choose deployment option:
   - **Free tier (M0)**: Good for development/testing
   - **Dedicated**: For production with auto-scaling
3. Select cloud provider: **AWS** (recommended)
4. Select region: Choose closest to your Vercel deployment region
5. Cluster name: `auth-cluster` (or your preference)
6. Click "Create"

### 3. Configure Database Access

1. Go to "Database Access" in sidebar
2. Click "Add New Database User"
3. Authentication Method: **Password**
4. Username: `auth-service`
5. Password: Generate strong password (save securely)
6. Database User Privileges: **Read and write to any database**
7. Click "Add User"

### 4. Configure Network Access

1. Go to "Network Access" in sidebar
2. Click "Add IP Address"
3. For development:
   - Click "Allow Access From Anywhere" (0.0.0.0/0)
4. For production:
   - Whitelist Vercel IPs or use Vercel's connection method
5. Click "Confirm"

### 5. Get Connection String

1. Go to "Database" in sidebar
2. Click "Connect" on your cluster
3. Choose "Connect your application"
4. Driver: **Node.js**
5. Version: **6.0 or later**
6. Copy connection string:
   ```
   mongodb+srv://auth-service:<password>@auth-cluster.xxxxx.mongodb.net/?retryWrites=true&w=majority
   ```
7. Replace `<password>` with your database user password

### 6. Create Database

The database will be created automatically when the application starts. Default name: `portfolio`

### 7. Indexes

Indexes are automatically created on application startup via `src/instrumentation.ts`. The following indexes are created:

**Users Collection:**

- `email` (unique)
- `verificationToken.hash`
- `verificationToken.expiresAt` (TTL index, auto-deletes after expiry)
- `resetToken.hash`
- `resetToken.expiresAt` (TTL index)
- `otp.expiresAt` (TTL index)

**Sessions Collection:**

- `sessionId` (unique)
- `userId`
- `refreshTokenHash`
- `jti`
- `expiresAt` (TTL index, auto-deletes expired sessions)

**Auth Events Collection:**

- `userId`
- `eventType`
- `createdAt`
- `createdAt` (TTL index, 90-day retention)

### 8. Verify Setup

Run the health check endpoint to verify MongoDB connection:

```bash
curl http://localhost:3001/api/health
```

Expected response:

```json
{
  "success": true,
  "data": {
    "message": "Service healthy",
    "mongodb": "connected",
    "redis": "connected"
  }
}
```

## Upstash Redis Setup

### 1. Create Upstash Account

1. Go to [Upstash](https://upstash.com)
2. Sign up with GitHub or email
3. Verify your email

### 2. Create Redis Database

1. Click "Create Database"
2. Configuration:
   - **Name**: `auth-revocation-store`
   - **Type**: **Regional** (for better latency)
   - **Region**: Choose closest to your Vercel deployment
   - **Primary Region**: Select one
   - **Read Regions**: Add if needed (for global distribution)
   - **TLS**: Enabled (recommended)
   - **Eviction**: **No eviction** (recommended for auth)
3. Click "Create"

### 3. Get Redis Credentials

1. Go to your database dashboard
2. Scroll to "REST API" section
3. Copy credentials:
   - **UPSTASH_REDIS_REST_URL**: `https://your-instance.upstash.io`
   - **UPSTASH_REDIS_REST_TOKEN**: `AXxxxxxxxxxxxxxxxxxxxxxxxx`

### 4. Configure Rate Limiting

Rate limiting is automatically configured in the application using `@upstash/ratelimit`:

- **Signup**: 5 requests per hour per IP
- **Signin**: 10 requests per 15 minutes per IP
- **OTP**: Escalating backoff per user (1min → 5min → 15min → 1hour)
- **Forgot Password**: 3 requests per hour per IP
- **Resend Verification**: 3 requests per hour per IP

### 5. Revocation Store

The revocation store uses three levels:

**Token-level revocation:**

```
Key: revoke:token:${jti}
Value: "1"
TTL: token expiry time
```

**Session-level revocation:**

```
Key: revoke:session:${sessionId}
Value: "1"
TTL: 30 days
```

**User-level revocation (global logout):**

```
Key: revoke:user:${userId}
Value: timestamp
TTL: 30 days
```

### 6. Monitor Usage

1. Go to Upstash dashboard
2. View metrics:
   - Commands per second
   - Storage usage
   - Connection count
   - Bandwidth usage

### 7. Verify Setup

The health check endpoint automatically tests Redis connectivity.

## Brevo Email Provider Setup

### 1. Create Brevo Account

1. Go to [Brevo](https://www.brevo.com) (formerly SendinBlue)
2. Sign up for free account
3. Verify your email

### 2. Verify Sender Email/Domain

**Option A: Verify Single Email**

1. Go to "Senders" → "Senders"
2. Click "Add a Sender"
3. Enter email: `noreply@yourwebsite.com`
4. Click verification link sent to your email
5. Email is now verified

**Option B: Verify Domain (Recommended for Production)**

1. Go to "Senders" → "Domains"
2. Click "Add a Domain"
3. Enter your domain: `ankurhalder.com`
4. Add DNS records provided by Brevo:
   - SPF record (TXT)
   - DKIM record (TXT)
   - DMARC record (TXT) - optional but recommended
5. Click "Verify Domain"
6. Domain verification can take up to 48 hours

### 3. Get API Key

1. Go to "SMTP & API" → "API Keys"
2. Click "Create a New API Key"
3. Name: `auth-service-production`
4. Copy the API key (starts with `xkeysib-`)
5. Store securely - shown only once

### 4. Email Templates

The application uses inline HTML templates in `src/infrastructure/email/brevo.provider.ts`:

**Verification Email:**

- Subject: "Verify Your Email"
- Color: Purple theme
- Link validity: 1 hour
- Call-to-action: "Verify Email" button

**OTP Email:**

- Subject: "Your Sign-In Code"
- Color: Red theme
- 8-digit OTP code
- Validity: 15 minutes
- Warning: "If you didn't request this, ignore it"

**Password Reset Email:**

- Subject: "Reset Your Password"
- Color: Purple theme
- Link validity: 1 hour
- Call-to-action: "Reset Password" button

### 5. Configure Sender Information

Update environment variables:

```bash
FROM_EMAIL=noreply@yourwebsite.com   # Verified sender
ADMIN_EMAIL=admin@yourwebsite.com    # Receives contact form emails
```

### 6. Test Email Delivery

Send a test email using the signup endpoint:

```bash
curl -X POST http://localhost:3001/api/auth/signup \
  -H "Content-Type: application/json" \
  -d '{
    "email": "test@example.com",
    "password": "Test123!@#"
  }'
```

Check your inbox for the verification email.

### 7. Monitor Email Sending

1. Go to "Statistics" → "Email"
2. View metrics:
   - Delivered
   - Opened
   - Clicked
   - Bounced
   - Spam reports

### 8. Error Handling

The application uses `p-retry` with exponential backoff:

- **Retries**: 3 attempts
- **Backoff**: Exponential
- **Fire-and-forget**: Email failures don't block user operations

## JWT Key Generation

### 1. Generate RSA Key Pairs

The service uses **RS256 (RSA-SHA256)** with **2048-bit keys**.

**Generate Access Token Keys:**

```bash
# Private key
openssl genrsa -out private_key.pem 2048

# Public key
openssl rsa -in private_key.pem -pubout -out public_key.pem
```

**Generate Refresh Token Keys:**

```bash
# Private key
openssl genrsa -out refresh_private_key.pem 2048

# Public key
openssl rsa -in refresh_private_key.pem -pubout -out refresh_public_key.pem
```

### 2. Verify Keys

**View private key:**

```bash
cat private_key.pem
```

Output should start with:

```
-----BEGIN RSA PRIVATE KEY-----
```

**View public key:**

```bash
cat public_key.pem
```

Output should start with:

```
-----BEGIN PUBLIC KEY-----
```

### 3. Key Format for Environment Variables

Copy the entire key including headers/footers:

```bash
JWT_PRIVATE_KEY="-----BEGIN RSA PRIVATE KEY-----
MIIEpAIBAAKCAQEA...
...multiple lines...
...ending with...
-----END RSA PRIVATE KEY-----"
```

**Note:** Preserve line breaks or use `\n` for newlines.

### 4. Key IDs (KID)

Each key pair needs a unique identifier:

```bash
JWT_KID=k1                    # Access token key ID
JWT_REFRESH_KID=r1            # Refresh token key ID
```

### 5. Key Rotation

For key rotation, keep previous keys for a grace period:

```bash
# After rotating keys, add old keys here
JWT_PREVIOUS_KIDS=k0,k-1       # Comma-separated old KIDs
JWT_PREVIOUS_PUBLIC_KEYS=...   # Comma-separated old public keys
```

Grace period: **30 days** (configurable in `src/infrastructure/crypto/jwt.service.ts`)

### 6. Security Best Practices

- **Never commit keys** to version control (use `.gitignore`)
- **Store in environment variables** or secrets manager
- **Rotate keys** every 90 days (recommended)
- **Use different keys** for access and refresh tokens
- **Keep private keys secure** - never share or expose
- **Use 2048-bit or larger** keys (4096-bit for high security)

### 7. JWKS Endpoint

Public keys are automatically served at:

```
https://auth.ankurhalder.com/.well-known/jwks.json
```

Used by client applications to verify JWT signatures.

## Environment Variables

### Complete Environment Configuration

Create `.env.local` in project root:

```bash
# ============================================
# NODE ENVIRONMENT
# ============================================
NODE_ENV=production

# ============================================
# URLS
# ============================================
NEXT_PUBLIC_SITE_URL=https://www.ankurhalder.com
ALLOWED_ORIGINS=https://www.ankurhalder.com,https://ankurhalder.com

# ============================================
# JWT - ACCESS TOKENS
# ============================================
# RS256 algorithm, 2048-bit keys
# Generate: openssl genrsa -out private_key.pem 2048

JWT_PRIVATE_KEY="-----BEGIN RSA PRIVATE KEY-----
MIIEpAIBAAKCAQEA...
-----END RSA PRIVATE KEY-----"

JWT_PUBLIC_KEY="-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA...
-----END PUBLIC KEY-----"

JWT_KID=k1

# ============================================
# JWT - REFRESH TOKENS
# ============================================
# Separate key pair for refresh tokens

JWT_REFRESH_PRIVATE_KEY="-----BEGIN RSA PRIVATE KEY-----
MIIEpAIBAAKCAQEA...
-----END RSA PRIVATE KEY-----"

JWT_REFRESH_PUBLIC_KEY="-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA...
-----END PUBLIC KEY-----"

JWT_REFRESH_KID=r1

# ============================================
# JWT - KEY ROTATION (OPTIONAL)
# ============================================
# Comma-separated previous key IDs and public keys
# Keep for 30-day grace period after rotation

JWT_PREVIOUS_KIDS=
JWT_PREVIOUS_PUBLIC_KEYS=

# ============================================
# MONGODB ATLAS
# ============================================
# Get from: MongoDB Atlas → Connect → Connection String

MONGODB_URI=mongodb+srv://auth-service:PASSWORD@auth-cluster.xxxxx.mongodb.net/?retryWrites=true&w=majority
DB_NAME=portfolio

# ============================================
# UPSTASH REDIS
# ============================================
# Get from: Upstash Dashboard → Database → REST API

UPSTASH_REDIS_REST_URL=https://your-instance.upstash.io
UPSTASH_REDIS_REST_TOKEN=AXxxxxxxxxxxxxxxxxxxxxxxxx

# ============================================
# BREVO EMAIL (SENDINBLUE)
# ============================================
# Get from: Brevo → SMTP & API → API Keys

BREVO_API_KEY=xkeysib-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
ADMIN_EMAIL=admin@ankurhalder.com
FROM_EMAIL=noreply@ankurhalder.com

# ============================================
# ENCRYPTION
# ============================================
# 32-byte hex key for AES-256-CBC encryption
# Generate: node -e "console.log(require('crypto').randomBytes(32).toString('hex'))"

ENCRYPTION_KEY=your-64-character-hex-string-here

# ============================================
# INTERNAL SECRETS
# ============================================
# Cron job secret for /api/cron/cleanup
# Generate: node -e "console.log(require('crypto').randomBytes(32).toString('base64'))"

CRON_SECRET=your-base64-secret-here
```

### Validation

Environment variables are validated on startup in `src/env.ts` using Zod. Invalid configuration will throw an error.

### Security Notes

- **Never commit `.env.local`** to version control
- Add `.env.local` to `.gitignore`
- Use Vercel environment variables for production
- Rotate secrets regularly
- Use different secrets for development/production

## Vercel Deployment

### 1. Install Vercel CLI

```bash
npm install -g vercel
```

### 2. Login to Vercel

```bash
vercel login
```

### 3. Link Project

```bash
cd /path/to/auth
vercel link
```

Select or create project: `auth-service`

### 4. Configure Environment Variables

**Option A: Via Vercel Dashboard**

1. Go to [Vercel Dashboard](https://vercel.com/dashboard)
2. Select project: `auth-service`
3. Go to "Settings" → "Environment Variables"
4. Add all variables from `.env.local`
5. Set environment: **Production**

**Option B: Via Vercel CLI**

```bash
vercel env pull .env.local
vercel env add MONGODB_URI production
# Repeat for all environment variables
```

### 5. Deploy to Production

```bash
vercel --prod
```

### 6. Configure Build Settings

In project settings:

- **Framework Preset**: Next.js
- **Build Command**: `pnpm build`
- **Output Directory**: `.next`
- **Install Command**: `pnpm install`
- **Node Version**: 22.x

### 7. Configure Functions

Next.js API routes become serverless functions automatically. Ensure:

- **Function Region**: Same as MongoDB/Redis region
- **Function Timeout**: 10s (default)
- **Memory**: 1024 MB (recommended)

### 8. Configure Cron Job

In `vercel.json`, cron jobs are configured (if needed):

```json
{
  "crons": [
    {
      "path": "/api/cron/cleanup",
      "schedule": "0 0 * * *"
    }
  ]
}
```

Or use external cron services (cron-job.org, EasyCron, etc.) to hit:

```
POST https://auth.ankurhalder.com/api/cron/cleanup
Authorization: Bearer YOUR_CRON_SECRET
```

### 9. Monitor Deployment

View deployment logs:

```bash
vercel logs
```

Or visit Vercel dashboard → Deployments

## Custom Domain Setup

### 1. Add Domain to Vercel

1. Go to Vercel project settings
2. Click "Domains"
3. Add domain: `auth.ankurhalder.com`
4. Click "Add"

### 2. Configure DNS Records

Add DNS records in your domain registrar:

**Option A: Vercel DNS (Recommended)**

- Vercel provides automatic DNS configuration
- Update nameservers to Vercel's nameservers

**Option B: Custom DNS**
Add these records:

```
Type: A
Name: auth
Value: 76.76.21.21

Type: CNAME
Name: auth
Value: cname.vercel-dns.com
```

### 3. Wait for DNS Propagation

DNS changes can take up to 48 hours to propagate globally. Check status:

```bash
dig auth.ankurhalder.com
```

### 4. SSL/TLS Certificate

Vercel automatically provisions SSL certificates via Let's Encrypt. Once DNS propagates:

- Certificate issued automatically
- HTTPS enforced automatically
- HTTP → HTTPS redirect enabled

### 5. Update Environment Variables

Update `NEXT_PUBLIC_SITE_URL` and `ALLOWED_ORIGINS`:

```bash
NEXT_PUBLIC_SITE_URL=https://www.ankurhalder.com
ALLOWED_ORIGINS=https://www.ankurhalder.com,https://ankurhalder.com
```

### 6. Verify Domain

Visit:

```
https://auth.ankurhalder.com/api/health
```

Should return `200 OK` with SSL.

## Production Considerations

### Performance

1. **Database Indexes**: Automatically created on startup
2. **Redis TTL**: Expired keys automatically deleted
3. **Connection Pooling**: MongoDB uses connection pooling
4. **Caching**: JWKS endpoint cached for 24 hours

### Security

1. **HTTPS**: Enforced by Vercel
2. **Security Headers**: Configured in `vercel.json`
3. **CORS**: Strict origin validation
4. **Rate Limiting**: Implemented via Upstash
5. **Secrets**: Never committed to Git

### Monitoring

1. **Health Check**: `/api/health` for uptime monitoring
2. **Error Tracking**: Consider adding Sentry
3. **Performance**: Vercel Analytics
4. **Audit Logs**: MongoDB auth events collection

### Backups

1. **MongoDB**: Enable continuous backups in Atlas
2. **Redis**: Upstash provides daily backups
3. **Environment Variables**: Keep secure backup of all secrets

### Scaling

1. **MongoDB**: Auto-scaling available in Atlas
2. **Redis**: Upstash auto-scales
3. **Vercel Functions**: Auto-scale by default
4. **Rate Limits**: Adjust based on traffic patterns

### Cost Optimization

1. **MongoDB**: Free M0 tier for development, paid tiers for production
2. **Upstash**: Free tier available, pay-per-request pricing
3. **Brevo**: 300 emails/day free, paid plans for more
4. **Vercel**: Hobby plan free, Pro for production

---

## Summary

Infrastructure setup checklist:

- [ ] MongoDB Atlas cluster created
- [ ] Database user created with strong password
- [ ] Network access configured
- [ ] Connection string obtained
- [ ] Upstash Redis database created
- [ ] Redis credentials obtained
- [ ] Brevo account created
- [ ] Sender email/domain verified
- [ ] Brevo API key obtained
- [ ] JWT key pairs generated (RS256, 2048-bit)
- [ ] All environment variables configured
- [ ] `.env.local` created (never committed)
- [ ] Vercel project linked
- [ ] Environment variables added to Vercel
- [ ] Custom domain configured
- [ ] SSL certificate provisioned
- [ ] Health check verified
- [ ] Cron job scheduled

For troubleshooting, see [README.md](../README.md#troubleshooting).


--------------------------------------------------------------------------------
File: docs\request-flow.md
--------------------------------------------------------------------------------

# Request Flow Documentation

Complete documentation of the request lifecycle from HTTP request to response, including middleware chain, use case execution, and error handling.

## Table of Contents

- [Complete Request Lifecycle](#complete-request-lifecycle)
- [Middleware Chain](#middleware-chain)
- [Use Case Execution Flow](#use-case-execution-flow)
- [Error Handling Flow](#error-handling-flow)
- [Response Formatting](#response-formatting)
- [Cookie Management](#cookie-management)
- [Token Verification Steps](#token-verification-steps)

## Complete Request Lifecycle

### Overview Diagram

```
┌─────────┐
│ Client  │
└────┬────┘
     │
     │ HTTP Request (POST /api/auth/signup)
     │ Headers: Origin, User-Agent, Content-Type
     │ Body: { email, password }
     │
     ↓
┌──────────────────────────────────────────────────────┐
│            Presentation Layer (Route Handler)        │
├──────────────────────────────────────────────────────┤
│                                                      │
│  [1] Middleware Chain                               │
│      ├─→ CORS Validation                            │
│      ├─→ Rate Limiting                              │
│      ├─→ CSRF Validation (if needed)                │
│      └─→ Auth Validation (for protected routes)     │
│                                                      │
│  [2] Request Parsing & Validation                   │
│      ├─→ Parse JSON body                            │
│      ├─→ Validate with Zod schema                   │
│      └─→ Build request context (IP, User-Agent, ID) │
│                                                      │
│  [3] Dependency Injection                           │
│      ├─→ Get MongoDB connection                     │
│      ├─→ Create repository instances                │
│      ├─→ Create service instances                   │
│      └─→ Wire use case with dependencies            │
│                                                      │
└──────────────┬───────────────────────────────────────┘
               │
               ↓
┌──────────────────────────────────────────────────────┐
│              Application Layer (Use Case)            │
├──────────────────────────────────────────────────────┤
│                                                      │
│  [4] Use Case Execution                             │
│      ├─→ Validate business rules                    │
│      ├─→ Load domain entities from repositories     │
│      ├─→ Execute domain logic                       │
│      ├─→ Call infrastructure services               │
│      └─→ Save changes via repositories              │
│                                                      │
└──────────────┬───────────────────────────────────────┘
               │
               ↓
┌──────────────────────────────────────────────────────┐
│        Infrastructure Layer (Repositories)           │
├──────────────────────────────────────────────────────┤
│                                                      │
│  [5] Data Persistence                               │
│      ├─→ Map domain entities to DB schemas          │
│      ├─→ Execute MongoDB operations                 │
│      ├─→ Execute Redis operations                   │
│      ├─→ Send emails (fire-and-forget)              │
│      └─→ Map DB schemas to domain entities          │
│                                                      │
└──────────────┬───────────────────────────────────────┘
               │
               ↓
┌──────────────────────────────────────────────────────┐
│            Presentation Layer (Response)             │
├──────────────────────────────────────────────────────┤
│                                                      │
│  [6] Response Formatting                            │
│      ├─→ Format success/error response              │
│      ├─→ Set cookies (if applicable)                │
│      ├─→ Set headers (rate limit, security)         │
│      └─→ Return NextResponse                        │
│                                                      │
└──────────────┬───────────────────────────────────────┘
               │
               │ HTTP Response (201 Created)
               │ Headers: Set-Cookie, X-RateLimit-*
               │ Body: { success: true, data: {...} }
               │
               ↓
          ┌─────────┐
          │ Client  │
          └─────────┘
```

### Step-by-Step Breakdown

#### Step 1: Middleware Chain

Middleware are applied in order:

```typescript
// app/api/auth/signup/route.ts
export async function POST(request: NextRequest): Promise<NextResponse> {
  try {
    // 1a. CORS Validation
    const corsResult = await corsMiddleware(request);
    if (corsResult) return corsResult; // Early return if CORS fails

    // 1b. Rate Limiting
    const rateLimitResult = await rateLimitMiddleware(request);
    if (rateLimitResult) return rateLimitResult; // Early return if rate limited

    // 1c. CSRF (for state-changing operations)
    const csrfResult = await csrfMiddleware(request);
    if (csrfResult) return csrfResult;

    // Continue to step 2...
  } catch (error) {
    return handleDomainError(error);
  }
}
```

#### Step 2: Request Parsing & Validation

```typescript
// 2a. Parse request body
const body = await request.json();

// 2b. Validate with Zod
const input = SignupSchema.parse(body);
// Throws ZodError if invalid

// 2c. Build request context
const context = buildRequestContext(request);
// Returns: { ip, userAgent, requestId }
```

#### Step 3: Dependency Injection

```typescript
// 3a. Get infrastructure
const db = await getDatabase();
const redis = getRedisClient();

// 3b. Create repositories
const userRepository = new UserRepositoryImpl(db);
const authEventRepository = new AuthEventRepositoryImpl(db);

// 3c. Create services
const passwordService = new PasswordService();
const emailProvider = new BrevoEmailProvider(env.BREVO_API_KEY);

// 3d. Create use case
const useCase = new SignupUseCase(
  userRepository,
  passwordService,
  emailProvider,
  authEventRepository
);
```

#### Step 4: Use Case Execution

```typescript
// 4. Execute use case
const output = await useCase.execute({
  ...input,
  context,
});

// Use case handles:
// - Business validation
// - Entity creation
// - Repository calls
// - Email sending
// - Event logging
```

#### Step 5: Data Persistence

```typescript
// Inside use case...

// 5a. Save user
await this.userRepository.save(user);
// → Maps User entity to MongoDB schema
// → Executes insertOne()
// → Returns void

// 5b. Send email (fire-and-forget)
this.emailProvider
  .sendVerificationEmail(email, token)
  .catch((err) => console.error("Email failed:", err));
// → Does not block response
// → Retries with exponential backoff

// 5c. Log event
await this.authEventRepository.logEvent({
  eventType: "signup",
  email,
  ...context,
});
```

#### Step 6: Response Formatting

```typescript
// 6a. Format response
const response = successResponse(output, 201);

// 6b. Set cookies (if applicable)
if (output.accessToken) {
  setAuthCookies(response, output.accessToken, output.refreshToken);
}

// 6c. Return
return response;
```

## Middleware Chain

### Execution Order

```
Request
  ↓
CORS Middleware
  ↓
Rate Limit Middleware
  ↓
CSRF Middleware
  ↓
Auth Middleware (protected routes only)
  ↓
Route Handler
```

### 1. CORS Middleware

**Purpose:** Validate request origin against allowed origins

**Implementation:**

```typescript
// src/presentation/middleware/cors.ts
export async function corsMiddleware(
  request: NextRequest
): Promise<NextResponse | null> {
  const origin = request.headers.get("origin");
  const allowedOrigins = env.ALLOWED_ORIGINS.split(",");

  // Check if origin is allowed
  if (origin && !allowedOrigins.includes(origin)) {
    return NextResponse.json(
      {
        success: false,
        error: {
          code: "CORS_ERROR",
          message: "Origin not allowed",
        },
      },
      { status: 403 }
    );
  }

  // Return null to continue
  return null;
}
```

**Headers Set:**

- `Access-Control-Allow-Origin`: Matched origin or `*`
- `Access-Control-Allow-Methods`: `GET, POST, PUT, DELETE`
- `Access-Control-Allow-Headers`: `Content-Type, Authorization`
- `Access-Control-Allow-Credentials`: `true`

### 2. Rate Limit Middleware

**Purpose:** Prevent abuse by limiting requests per time window

**Implementation:**

```typescript
// src/presentation/middleware/rate-limit.ts
import { Ratelimit } from "@upstash/ratelimit";

export async function rateLimitMiddleware(
  request: NextRequest,
  limit: number,
  window: string
): Promise<NextResponse | null> {
  const ip = getClientIp(request);

  const limiter = new Ratelimit({
    redis,
    limiter: Ratelimit.slidingWindow(limit, window),
  });

  const { success, limit: max, remaining, reset } = await limiter.limit(ip);

  if (!success) {
    return NextResponse.json(
      {
        success: false,
        error: {
          code: "RATE_LIMIT_EXCEEDED",
          message: "Too many requests. Please try again later.",
          retryAfter: reset,
        },
      },
      {
        status: 429,
        headers: {
          "X-RateLimit-Limit": max.toString(),
          "X-RateLimit-Remaining": remaining.toString(),
          "X-RateLimit-Reset": reset.toString(),
        },
      }
    );
  }

  return null; // Continue
}
```

**Rate Limits:**

- Signup: 5/hour
- Signin: 10/15min
- Forgot Password: 3/hour
- Resend Verification: 3/hour

### 3. CSRF Middleware

**Purpose:** Prevent cross-site request forgery attacks

**Implementation:**

```typescript
// src/presentation/middleware/csrf.ts
export async function csrfMiddleware(
  request: NextRequest
): Promise<NextResponse | null> {
  // Skip for GET, HEAD, OPTIONS
  if (["GET", "HEAD", "OPTIONS"].includes(request.method)) {
    return null;
  }

  const origin = request.headers.get("origin");
  const host = request.headers.get("host");

  // Validate origin header
  if (!origin) {
    return NextResponse.json(
      {
        success: false,
        error: {
          code: "CSRF_ERROR",
          message: "Missing origin header",
        },
      },
      { status: 403 }
    );
  }

  // Ensure origin matches host
  const originHost = new URL(origin).host;
  if (originHost !== host) {
    return NextResponse.json(
      {
        success: false,
        error: {
          code: "CSRF_ERROR",
          message: "Origin mismatch",
        },
      },
      { status: 403 }
    );
  }

  return null;
}
```

### 4. Auth Middleware (Protected Routes)

**Purpose:** Verify JWT access token for protected endpoints

**Implementation:**

```typescript
// src/presentation/middleware/auth.ts
export async function authMiddleware(request: NextRequest): Promise<
  | {
      userId: string;
      email: string;
      role: string;
    }
  | NextResponse
> {
  try {
    // 1. Extract token from cookie
    const token = request.cookies.get("accessToken")?.value;
    if (!token) {
      throw new AuthenticationError("No access token provided");
    }

    // 2-8. Verify token (see Token Verification Steps below)
    const payload = await jwtService.verifyAccessToken(token);

    // 3. Check revocation
    const isRevoked = await revocationStore.isTokenRevoked(payload.jti);
    if (isRevoked) {
      throw new TokenError("Token revoked");
    }

    // 4. Return user info
    return {
      userId: payload.sub,
      email: payload.email,
      role: payload.role,
    };
  } catch (error) {
    return NextResponse.json(
      {
        success: false,
        error: {
          code: "UNAUTHORIZED",
          message: "Authentication required",
        },
      },
      { status: 401 }
    );
  }
}
```

## Use Case Execution Flow

### Generic Use Case Pattern

```typescript
export class UseCase<TInput, TOutput> {
  constructor(private readonly dependencies: Dependencies) {}

  async execute(input: TInput): Promise<TOutput> {
    // 1. Validate input (business rules)
    this.validateInput(input);

    // 2. Load entities from repositories
    const entity = await this.repository.find(...);

    // 3. Execute domain logic
    const result = entity.someBusinessMethod();

    // 4. Call infrastructure services
    await this.service.doSomething();

    // 5. Save changes
    await this.repository.save(result);

    // 6. Return output
    return this.buildOutput(result);
  }

  private validateInput(input: TInput): void {
    // Business validation
    if (!this.isValid(input)) {
      throw new ValidationError('Invalid input');
    }
  }

  private buildOutput(result: any): TOutput {
    // Map to DTO
    return { /* ... */ };
  }
}
```

### Example: Signin Use Case

```typescript
export class SigninUseCase {
  async execute(input: SigninInput): Promise<SigninOutput> {
    // 1. Find user
    const user = await this.userRepository.findByEmail(new Email(input.email));
    if (!user) {
      throw new AuthenticationError("Invalid credentials");
    }

    // 2. Check email verified
    if (!user.isVerified) {
      throw new AuthenticationError("Email not verified");
    }

    // 3. Verify password
    const isValid = await this.passwordService.verify(
      input.password,
      user.password
    );
    if (!isValid) {
      throw new AuthenticationError("Invalid credentials");
    }

    // 4. Check if admin (OTP path)
    if (user.role === "admin") {
      return await this.handleAdminFlow(user, input.context);
    }

    // 5. Create session (user path)
    const session = await this.createSession(user, input.rememberMe);

    // 6. Generate tokens
    const { accessToken, refreshToken } =
      await this.tokenService.generateTokens(user, session);

    // 7. Log event
    await this.authEventRepository.logEvent({
      eventType: "signin",
      userId: user.id,
      ...input.context,
    });

    // 8. Return output
    return {
      user: this.mapUserToDTO(user),
      accessToken,
      refreshToken,
      requiresOtp: false,
    };
  }
}
```

## Error Handling Flow

### Error Hierarchy

```
Error (Native)
  ↓
DomainError (Base)
  ├─→ ValidationError
  ├─→ AuthenticationError
  ├─→ AuthorizationError
  ├─→ NotFoundError
  ├─→ ConflictError
  ├─→ TokenError
  └─→ RateLimitError
```

### Error to HTTP Status Mapping

```typescript
// src/presentation/helpers/response.ts
export function mapDomainErrorToHttp(error: Error): number {
  if (error instanceof ValidationError) return 400;
  if (error instanceof AuthenticationError) return 401;
  if (error instanceof AuthorizationError) return 403;
  if (error instanceof NotFoundError) return 404;
  if (error instanceof ConflictError) return 409;
  if (error instanceof RateLimitError) return 429;
  if (error instanceof TokenError) return 401;

  // Unknown error
  return 500;
}
```

### Error Response Format

```typescript
export function errorResponse(error: Error): NextResponse {
  const status = mapDomainErrorToHttp(error);

  return NextResponse.json(
    {
      success: false,
      error: {
        code: error.name.replace("Error", "").toUpperCase(),
        message: error.message,
      },
    },
    { status }
  );
}
```

### Error Handling in Route

```typescript
export async function POST(request: NextRequest): Promise<NextResponse> {
  try {
    // ... middleware, validation, use case execution
    return successResponse(output, 201);
  } catch (error) {
    // Log error (in production, use proper logging)
    console.error("Signup error:", error);

    // Return formatted error response
    return handleDomainError(error);
  }
}
```

## Response Formatting

### Success Response

```typescript
export function successResponse<T>(
  data: T,
  status: number = 200
): NextResponse {
  return NextResponse.json(
    {
      success: true,
      data,
    },
    { status }
  );
}
```

**Example:**

```json
{
  "success": true,
  "data": {
    "user": {
      "id": "123",
      "email": "user@example.com",
      "role": "user"
    },
    "message": "Signed in successfully"
  }
}
```

### Error Response

```typescript
export function errorResponse(
  error: Error,
  status: number = 500
): NextResponse {
  return NextResponse.json(
    {
      success: false,
      error: {
        code: getErrorCode(error),
        message: error.message,
      },
    },
    { status }
  );
}
```

**Example:**

```json
{
  "success": false,
  "error": {
    "code": "AUTHENTICATION_FAILED",
    "message": "Invalid credentials"
  }
}
```

## Cookie Management

### Setting Auth Cookies

```typescript
// src/presentation/helpers/cookies.ts
export function setAuthCookies(
  response: NextResponse,
  accessToken: string,
  refreshToken: string,
  rememberMe: boolean = false
): void {
  const isProduction = process.env.NODE_ENV === "production";
  const domain = isProduction ? ".ankurhalder.com" : undefined;

  // Access token cookie (15 minutes)
  response.cookies.set("accessToken", accessToken, {
    httpOnly: true,
    secure: isProduction,
    sameSite: "lax",
    domain,
    path: "/",
    maxAge: 15 * 60, // 15 minutes
  });

  // Refresh token cookie (7 or 30 days)
  const refreshMaxAge = rememberMe
    ? 30 * 24 * 60 * 60 // 30 days
    : 7 * 24 * 60 * 60; // 7 days

  response.cookies.set("refreshToken", refreshToken, {
    httpOnly: true,
    secure: isProduction,
    sameSite: "lax",
    domain,
    path: "/",
    maxAge: refreshMaxAge,
  });
}
```

### Clearing Auth Cookies

```typescript
export function clearAuthCookies(response: NextResponse): void {
  const isProduction = process.env.NODE_ENV === "production";
  const domain = isProduction ? ".ankurhalder.com" : undefined;

  response.cookies.set("accessToken", "", {
    httpOnly: true,
    secure: isProduction,
    sameSite: "lax",
    domain,
    path: "/",
    maxAge: 0, // Immediate expiry
  });

  response.cookies.set("refreshToken", "", {
    httpOnly: true,
    secure: isProduction,
    sameSite: "lax",
    domain,
    path: "/",
    maxAge: 0,
  });
}
```

## Token Verification Steps

### 8-Step Verification Chain

When a protected endpoint is accessed, the access token undergoes 8 verification steps:

```typescript
export async function verifyAccessToken(
  token: string
): Promise<AccessTokenPayload> {
  // Step 1: JWT Signature Verification
  const { payload } = await jwtVerify(token, publicKey, {
    algorithms: ["RS256"],
    issuer: env.NEXT_PUBLIC_SITE_URL,
  });
  // Throws if signature invalid or expired

  // Step 2: Token Type Check
  if (payload.type !== "access") {
    throw new TokenError("Invalid token type");
  }

  // Step 3: JTI Validation
  if (!payload.jti || typeof payload.jti !== "string") {
    throw new TokenError("Missing or invalid JTI");
  }

  // Step 4: Token-Level Revocation Check
  const isTokenRevoked = await redis.get(`revoke:token:${payload.jti}`);
  if (isTokenRevoked) {
    throw new TokenError("Token revoked");
  }

  // Step 5: Session-Level Revocation Check (if sessionId present)
  if (payload.sessionId) {
    const isSessionRevoked = await redis.get(
      `revoke:session:${payload.sessionId}`
    );
    if (isSessionRevoked) {
      throw new TokenError("Session revoked");
    }
  }

  // Step 6: User-Level Revocation Check
  const userRevokedAt = await redis.get(`revoke:user:${payload.sub}`);
  if (userRevokedAt) {
    const tokenIssuedAt = payload.iat * 1000; // Convert to ms
    const revokedTimestamp = parseInt(userRevokedAt);

    if (tokenIssuedAt < revokedTimestamp) {
      throw new TokenError("User revoked all tokens");
    }
  }

  // Step 7: User Exists Check
  const user = await userRepository.findById(payload.sub);
  if (!user) {
    throw new NotFoundError("User not found");
  }

  // Step 8: Token Version Check
  if (payload.tokenVersion !== user.tokenVersion.value) {
    throw new TokenError("Token version mismatch");
  }

  // All checks passed
  return payload as AccessTokenPayload;
}
```

### Verification Steps Summary

1. **JWT Signature Verification**: Verify RS256 signature with public key
2. **Token Type Check**: Ensure token type is "access"
3. **JTI Validation**: Validate JWT ID is present
4. **Token-Level Revocation**: Check if specific token revoked
5. **Session-Level Revocation**: Check if session revoked
6. **User-Level Revocation**: Check if all user tokens revoked
7. **User Exists**: Verify user still exists in database
8. **Token Version**: Verify token version matches user's current version

All steps must pass for token to be valid.

---

## Summary

Request flow overview:

1. **Middleware Chain**: CORS → Rate Limit → CSRF → Auth
2. **Request Parsing**: JSON → Zod validation → Context building
3. **Dependency Injection**: Wire repositories and services
4. **Use Case Execution**: Business logic orchestration
5. **Data Persistence**: MongoDB + Redis operations
6. **Response Formatting**: Success/error responses with cookies

**Key Principles:**

- Middleware runs in sequence with early returns
- Use cases are framework-agnostic
- Errors are mapped to HTTP status codes
- Cookies are HttpOnly, Secure, SameSite=Lax
- Token verification is comprehensive (8 steps)

For implementation details, see:

- [Architecture](architecture.md)
- [Features](features.md)
- [Security Headers](features.md#security-headers)


--------------------------------------------------------------------------------
File: eslint.config.mjs
--------------------------------------------------------------------------------

import { defineConfig, globalIgnores } from "eslint/config";
import nextVitals from "eslint-config-next/core-web-vitals";
import nextTs from "eslint-config-next/typescript";

const eslintConfig = defineConfig([
  ...nextVitals,
  ...nextTs,

  
  {
    files: ["src/domain/**/*.ts"],
    rules: {
      "no-restricted-imports": [
        "error",
        {
          patterns: [
            {
              group: ["@app/*", "@infra/*", "@presentation/*"],
              message:
                "Domain layer must not import from Application, Infrastructure, or Presentation.",
            },
            {
              group: ["next/*", "mongodb", "@upstash/*", "@getbrevo/*"],
              message:
                "Domain layer must not depend on framework or infrastructure packages.",
            },
          ],
        },
      ],
    },
  },
  {
    files: ["src/application/**/*.ts"],
    rules: {
      "no-restricted-imports": [
        "error",
        {
          patterns: [
            {
              group: ["@infra/database/*", "@infra/email/*", "@presentation/*"],
              message:
                "Application layer must not import from Infrastructure (database/email) or Presentation. " +
                "Crypto utilities (@infra/crypto/*) and rate limiters are allowed as shared utilities.",
            },
          ],
        },
      ],
    },
  },
  {
    files: ["src/infrastructure/**/*.ts"],
    rules: {
      "no-restricted-imports": [
        "error",
        {
          patterns: [
            {
              group: ["@presentation/*"],
              message:
                "Infrastructure layer must not import from Presentation.",
            },
          ],
        },
      ],
    },
  },


  globalIgnores([

    ".next/**",
    "out/**",
    "build/**",
    "next-env.d.ts",
    "scripts/**",
  ]),
]);

export default eslintConfig;


--------------------------------------------------------------------------------
File: next-env.d.ts
--------------------------------------------------------------------------------

/// <reference types="next" />
/// <reference types="next/image-types/global" />
import "./.next/types/routes.d.ts";

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.


--------------------------------------------------------------------------------
File: next.config.ts
--------------------------------------------------------------------------------

import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  reactStrictMode: false,

  async headers() {
    return [
      {
        source: "/api/:path*",
        headers: [
          {
            key: "X-Content-Type-Options",
            value: "nosniff",
          },
          {
            key: "X-Frame-Options",
            value: "DENY",
          },
          {
            key: "X-XSS-Protection",
            value: "0",
          },
          {
            key: "Referrer-Policy",
            value: "strict-origin-when-cross-origin",
          },
          {
            key: "Permissions-Policy",
            value:
              "camera=(), microphone=(), geolocation=(), interest-cohort=()",
          },
          {
            key: "Strict-Transport-Security",
            value: "max-age=63072000; includeSubDomains; preload",
          },
          {
            key: "Content-Security-Policy",
            value: "default-src 'none'; frame-ancestors 'none'",
          },
        ],
      },
      {
        source: "/.well-known/jwks.json",
        headers: [
          {
            key: "Cache-Control",
            value: "public, max-age=86400, s-maxage=86400",
          },
          {
            key: "Access-Control-Allow-Origin",
            value: "*",
          },
        ],
      },
    ];
  },

  async redirects() {
    return [
      {
        source: "/",
        destination: "/api/health",
        permanent: false,
      },
    ];
  },

  logging: {
    fetches: {
      fullUrl: true,
    },
  },

  serverExternalPackages: ["bcrypt"],
};

export default nextConfig;


--------------------------------------------------------------------------------
File: package.json
--------------------------------------------------------------------------------

{
  "name": "ankurhalder-auth",
  "version": "1.0.1",
  "private": true,
  "description": "Authentication service for auth.ankurhalder.com",
  "scripts": {
    "dev": "next dev --turbopack --port 3001",
    "build": "next build",
    "start": "next start",
    "lint": "eslint",
    "format": "prettier --write \"**/*.{ts,tsx,js,jsx,json,md}\"",
    "type-check": "tsc --noEmit",
    "test": "vitest run",
    "test:watch": "vitest",
    "test:coverage": "vitest run --coverage",
    "prepare": "husky"
  },
  "dependencies": {
    "@getbrevo/brevo": "^3.0.1",
    "@upstash/ratelimit": "^2.0.0",
    "@upstash/redis": "^1.34.0",
    "bcrypt": "^6.0.0",
    "jose": "^6.0.0",
    "mongodb": "^6.12.0",
    "next": "16.1.6",
    "p-retry": "^6.2.0",
    "react": "19.2.3",
    "react-dom": "19.2.3",
    "uuid": "^11.0.0",
    "zod": "^3.24.0"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4",
    "@types/bcrypt": "^5.0.2",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "@types/uuid": "^10.0.0",
    "@vitest/coverage-v8": "^3.0.0",
    "eslint": "^9",
    "eslint-config-next": "16.1.6",
    "husky": "^9.1.7",
    "prettier": "^3.8.1",
    "tailwindcss": "^4",
    "typescript": "^5",
    "vitest": "^3.0.0"
  },
  "engines": {
    "node": ">=22.0.0",
    "pnpm": ">=9.0.0"
  },
  "packageManager": "pnpm@9.15.0"
}


--------------------------------------------------------------------------------
File: postcss.config.mjs
--------------------------------------------------------------------------------

const config = {
  plugins: {
    "@tailwindcss/postcss": {},
  },
};

export default config;


--------------------------------------------------------------------------------
File: README.md
--------------------------------------------------------------------------------

# Authentication Service

Enterprise-grade authentication service for [auth.ankurhalder.com](https://auth.ankurhalder.com), built with Domain-Driven Design (DDD) architecture and production-ready security features.

## Table of Contents

- [Overview](#overview)
- [Key Features](#key-features)
- [Architecture](#architecture)
- [Quick Start](#quick-start)
- [API Endpoints](#api-endpoints)
- [Authentication Flows](#authentication-flows)
- [Security Features](#security-features)
- [Database Schema](#database-schema)
- [Development](#development)
- [Testing](#testing)
- [Production Checklist](#production-checklist)
- [Troubleshooting](#troubleshooting)
- [Documentation](#documentation)

## Overview

This authentication service provides secure user authentication and authorization with JWT tokens (RS256), session management, OTP verification for admin users, email verification, and password reset functionality. Built on Next.js 16 with a clean 4-layer DDD architecture.

**Live Service:** [auth.ankurhalder.com](https://auth.ankurhalder.com)

### Tech Stack

- **Framework:** Next.js 16 (App Router, Turbopack)
- **Runtime:** Node.js 22+
- **Package Manager:** pnpm 9+
- **Database:** MongoDB Atlas
- **Cache/Session Store:** Upstash Redis
- **Email Provider:** Brevo (SendinBlue)
- **JWT Library:** jose (RS256 signing)
- **Validation:** Zod
- **Encryption:** Node.js crypto (AES-256-CBC)
- **Hashing:** bcrypt (cost 12)

## Key Features

### Core Authentication

- **User Registration** with email verification
- **User Sign-in** with password authentication
- **Admin Sign-in** with OTP verification (2FA for admins)
- **JWT Token Management** (Access + Refresh tokens, RS256)
- **Token Rotation** with atomic refresh and replay detection
- **Session Management** with Redis-backed revocation store
- **Email Verification** with time-limited tokens
- **Password Reset** with secure one-time tokens
- **Remember Me** functionality (7 vs 30 days)

### Security Features

- **RS256 JWT Signing** with separate key pairs for access/refresh tokens
- **Key Rotation Support** with 30-day grace period
- **8-Step Token Verification** chain with multiple security checks
- **Triple-Layer Token Revocation** (token, session, user levels)
- **OTP Security** with AES-256-CBC encryption and rate limiting
- **Password Security** with bcrypt (cost 12) and complexity validation
- **Token Storage** with SHA256 hashing in database
- **Rate Limiting** with Upstash Ratelimit (sliding window)
- **CSRF Protection** with double-submit cookie pattern
- **CORS Configuration** with allowed origins
- **Security Headers** (CSP, HSTS, X-Frame-Options, etc.)
- **Audit Logging** for all authentication events

### Developer Experience

- **DDD Architecture** with enforced layer boundaries
- **ESLint Rules** preventing architectural violations
- **TypeScript Strict Mode** with comprehensive type safety
- **Path Aliases** for clean imports (@domain, @app, @infra, @presentation)
- **Fire-and-Forget Pattern** for emails and audit logs
- **Dependency Injection** for testability
- **Zero External Dependencies** in domain layer

## Architecture

This service follows a **4-layer Domain-Driven Design (DDD)** architecture with strict layer boundaries enforced by ESLint and TypeScript path aliases.

```
┌──────────────────────────────────────────────────┐
│           Presentation Layer                     │
│  (API Routes, Middleware, Validation, Helpers)   │
│              ↓ Uses All Layers                   │
└──────────────────────────────────────────────────┘
                       ↓
┌──────────────────────────────────────────────────┐
│         Infrastructure Layer                     │
│   (Database, Redis, Email, Crypto, External)     │
│        ↓ Implements Domain Interfaces            │
└──────────────────────────────────────────────────┘
                       ↓
┌──────────────────────────────────────────────────┐
│          Application Layer                       │
│    (Use Cases, DTOs, Port Interfaces)            │
│         ↓ Orchestrates Domain Logic              │
└──────────────────────────────────────────────────┘
                       ↓
┌──────────────────────────────────────────────────┐
│            Domain Layer                          │
│  (Entities, Value Objects, Repository Ports)     │
│         ↓ Pure Business Logic (No Deps)          │
└──────────────────────────────────────────────────┘
```

### Dependency Rules

- **Domain Layer:** No dependencies on outer layers (pure business logic)
- **Application Layer:** Can import from Domain only
- **Infrastructure Layer:** Can import from Domain and Application
- **Presentation Layer:** Can import from all layers

**See:** [docs/architecture.md](docs/architecture.md) for detailed architecture documentation.

## Quick Start

### Prerequisites

- Node.js 22.0.0 or higher
- pnpm 9.0.0 or higher
- MongoDB Atlas account
- Upstash Redis account
- Brevo API key

### Installation

1. **Clone the repository**

   ```bash
   git clone https://github.com/ankurhalder/auth.git
   cd auth
   ```

2. **Install dependencies**

   ```bash
   pnpm install
   ```

3. **Generate JWT keys** (RS256, 2048-bit)

   ```bash
   # Generate access token key pair
   openssl genrsa -out private_key.pem 2048
   openssl rsa -in private_key.pem -pubout -out public_key.pem

   # Generate refresh token key pair
   openssl genrsa -out refresh_private_key.pem 2048
   openssl rsa -in refresh_private_key.pem -pubout -out refresh_public_key.pem
   ```

4. **Set up environment variables**

   ```bash
   cp .env.example .env.local
   # Edit .env.local with your credentials
   ```

5. **Run development server**

   ```bash
   pnpm dev
   ```

   Server starts at `http://localhost:3001`

### Environment Variables

See [.env.example](.env.example) for all required environment variables. Key variables:

```bash
NODE_ENV=development
NEXT_PUBLIC_SITE_URL=https://www.ankurhalder.com
ALLOWED_ORIGINS=https://www.ankurhalder.com,http://localhost:3000

# JWT Keys (paste contents from .pem files)
JWT_PRIVATE_KEY="-----BEGIN RSA PRIVATE KEY-----..."
JWT_PUBLIC_KEY="-----BEGIN PUBLIC KEY-----..."
JWT_KID=k1

JWT_REFRESH_PRIVATE_KEY="-----BEGIN RSA PRIVATE KEY-----..."
JWT_REFRESH_PUBLIC_KEY="-----BEGIN PUBLIC KEY-----..."
JWT_REFRESH_KID=r1

# MongoDB
MONGODB_URI=mongodb+srv://user:pass@cluster.mongodb.net/
DB_NAME=portfolio

# Upstash Redis
UPSTASH_REDIS_REST_URL=https://your-instance.upstash.io
UPSTASH_REDIS_REST_TOKEN=your-token-here

# Brevo Email
BREVO_API_KEY=xkeysib-your-api-key
ADMIN_EMAIL=admin@yourwebsite.com
FROM_EMAIL=noreply@yourwebsite.com

# Encryption (32-byte hex)
ENCRYPTION_KEY=your-64-character-hex-key

# Cron Secret
CRON_SECRET=your-cron-secret
```

**See:** [docs/infrastructure.md](docs/infrastructure.md) for detailed setup instructions.

## API Endpoints

All endpoints use JSON for request/response bodies and return standard formats.

### Public Endpoints

| Method | Endpoint                        | Description               |
| ------ | ------------------------------- | ------------------------- |
| POST   | `/api/auth/signup`              | Register new user         |
| POST   | `/api/auth/signin`              | Sign in user/admin        |
| POST   | `/api/auth/verify-otp`          | Verify admin OTP          |
| POST   | `/api/auth/verify-email`        | Verify email with token   |
| POST   | `/api/auth/forgot-password`     | Request password reset    |
| POST   | `/api/auth/reset-password`      | Reset password with token |
| POST   | `/api/auth/resend-verification` | Resend verification email |
| GET    | `/.well-known/jwks.json`        | Get public JWKS           |
| GET    | `/api/health`                   | Health check              |

### Protected Endpoints (Require Access Token)

| Method | Endpoint               | Description             |
| ------ | ---------------------- | ----------------------- |
| GET    | `/api/auth/me`         | Get current user        |
| POST   | `/api/auth/refresh`    | Refresh access token    |
| POST   | `/api/auth/logout`     | Logout (revoke session) |
| POST   | `/api/auth/logout-all` | Logout all sessions     |

### Cron Endpoints (Require Cron Secret)

| Method | Endpoint            | Description                     |
| ------ | ------------------- | ------------------------------- |
| POST   | `/api/cron/cleanup` | Cleanup expired sessions/tokens |

### Request/Response Format

**Success Response:**

```json
{
  "success": true,
  "data": {
    "user": { "id": "...", "email": "..." },
    "message": "Operation successful"
  }
}
```

**Error Response:**

```json
{
  "success": false,
  "error": {
    "code": "AUTHENTICATION_FAILED",
    "message": "Invalid credentials"
  }
}
```

## Authentication Flows

### User Registration Flow

```
1. User submits email + password
2. System validates password complexity
3. System checks email uniqueness
4. System hashes password (bcrypt, cost 12)
5. System generates verification token
6. System stores user with hashed token
7. System sends verification email
8. User clicks email link
9. System verifies token and activates account
```

### User Sign-In Flow

```
1. User submits email + password
2. System verifies email is verified
3. System validates password (bcrypt compare)
4. System creates session record
5. System generates JWT access + refresh tokens
6. System sets HttpOnly cookies
7. User receives tokens and can access protected resources
```

### Admin Sign-In Flow (2FA with OTP)

```
1. Admin submits email + password
2. System validates credentials
3. System generates 8-digit OTP
4. System encrypts OTP (AES-256-CBC)
5. System applies rate limiting
6. System sends OTP via email
7. Admin submits OTP
8. System verifies OTP (timing-safe)
9. System creates session and issues tokens
```

### Token Refresh Flow (Atomic Rotation)

```
1. Client sends refresh token
2. System atomically finds and deletes session (findOneAndDelete)
3. System verifies JWT signature + expiry
4. System checks revocation store (3 levels)
5. System validates user exists + tokenVersion
6. System creates new session with new ID
7. System issues new access + refresh tokens
8. Old refresh token is now invalid (replay detection)
```

### Password Reset Flow

```
1. User requests password reset
2. System generates reset token (64 hex chars)
3. System hashes + encrypts token
4. System sends reset email
5. User clicks email link
6. User submits new password
7. System verifies token + expiry
8. System hashes new password
9. System increments tokenVersion (invalidates all sessions)
10. User must sign in again
```

**See:** [docs/features.md](docs/features.md) for detailed feature documentation.

## Security Features

### JWT (JSON Web Tokens)

- **Algorithm:** RS256 (RSA-SHA256)
- **Key Size:** 2048-bit RSA
- **Access Token:** 15 minutes expiry
- **Refresh Token:** 7 days (30 with rememberMe)
- **Separate Key Pairs:** Access and refresh tokens use different keys
- **Key Rotation:** Supports previous keys with 30-day grace period
- **8-Step Verification:** Comprehensive validation chain
- **JWKS Endpoint:** Public keys served at `/.well-known/jwks.json`

### Password Security

- **Hashing:** bcrypt with cost factor 12
- **Legacy Support:** PBKDF2-SHA512 with auto-migration
- **Complexity:** 8+ chars, upper, lower, digit, special
- **Timing Safety:** Constant-time comparison to prevent timing attacks

### OTP Security

- **Generation:** crypto.randomInt (8 digits)
- **Encryption:** AES-256-CBC with 32-byte key
- **Expiry:** 15 minutes
- **Max Attempts:** 5 attempts before lockout
- **Rate Limiting:** Escalating backoff (1min → 5min → 15min → 1hour)
- **Timing Safety:** Constant-time comparison

### Token Storage

- **Refresh Tokens:** SHA256 hashed in MongoDB
- **Verification Tokens:** SHA256 hashed + AES-256-CBC encrypted
- **Reset Tokens:** SHA256 hashed + AES-256-CBC encrypted
- **OTP:** AES-256-CBC encrypted with attempt counter

### Session Management

- **Revocation Store:** Redis with 3 revocation levels
  - **Token Level:** Individual token revocation
  - **Session Level:** All tokens in a session
  - **User Level:** All user sessions (global logout)
- **Atomic Rotation:** findOneAndDelete for replay detection
- **TTL Preservation:** Maintains rememberMe preference across refreshes

### Rate Limiting

Implemented with Upstash Ratelimit (sliding window):

- **Signup:** 5 requests per hour per IP
- **Signin:** 10 requests per 15 minutes per IP
- **OTP:** Escalating backoff per user
- **Forgot Password:** 3 requests per hour per IP
- **Resend Verification:** 3 requests per hour per IP

### Security Headers

Configured in `vercel.json`:

```
X-Frame-Options: DENY
X-Content-Type-Options: nosniff
X-XSS-Protection: 1; mode=block
Referrer-Policy: strict-origin-when-cross-origin
Content-Security-Policy: default-src 'self'
Strict-Transport-Security: max-age=31536000; includeSubDomains
```

### CORS & CSRF

- **CORS:** Strict origin validation from `ALLOWED_ORIGINS`
- **CSRF:** Double-submit cookie pattern with origin validation

### Audit Logging

All authentication events are logged to MongoDB with:

- Event type (signup, signin, logout, etc.)
- User ID
- IP address
- User agent
- Request ID
- Timestamp

**See:** [docs/request-flow.md](docs/request-flow.md) for complete request flow documentation.

## Database Schema

### Users Collection

```typescript
{
  _id: ObjectId,
  email: string (unique, lowercase),
  password: string (bcrypt hash),
  role: "user" | "admin",
  isVerified: boolean,
  tokenVersion: number,
  verificationToken?: {
    hash: string (SHA256),
    encryptedToken: string (AES-256-CBC),
    expiresAt: Date
  },
  resetToken?: {
    hash: string (SHA256),
    encryptedToken: string (AES-256-CBC),
    expiresAt: Date
  },
  otp?: {
    encrypted: string (AES-256-CBC),
    expiresAt: Date,
    attempts: number
  },
  createdAt: Date,
  updatedAt: Date
}

Indexes:
- email (unique)
- verificationToken.hash
- verificationToken.expiresAt (TTL)
- resetToken.hash
- resetToken.expiresAt (TTL)
- otp.expiresAt (TTL)
```

### Sessions Collection

```typescript
{
  _id: ObjectId,
  sessionId: string (UUID v4, unique),
  userId: ObjectId,
  refreshTokenHash: string (SHA256),
  jti: string,
  expiresAt: Date,
  createdAt: Date
}

Indexes:
- sessionId (unique)
- userId
- refreshTokenHash
- jti
- expiresAt (TTL)
```

### Auth Events Collection (Audit Log)

```typescript
{
  _id: ObjectId,
  eventType: string,
  userId?: ObjectId,
  email?: string,
  ip: string,
  userAgent: string,
  requestId: string,
  metadata?: object,
  createdAt: Date
}

Indexes:
- userId
- eventType
- createdAt
- createdAt (TTL, 90 days)
```

### Redis Revocation Store

```typescript
// Token-level revocation
key: `revoke:token:${jti}`
value: "1"
ttl: token expiry

// Session-level revocation
key: `revoke:session:${sessionId}`
value: "1"
ttl: 30 days

// User-level revocation
key: `revoke:user:${userId}`
value: timestamp
ttl: 30 days
```

## Development

### Project Structure

```
auth/
├── app/                          # Next.js app directory
│   ├── api/                      # API routes
│   │   ├── .well-known/
│   │   │   └── jwks.json/        # JWKS endpoint
│   │   ├── auth/                 # Authentication endpoints
│   │   │   ├── signup/
│   │   │   ├── signin/
│   │   │   ├── refresh/
│   │   │   ├── logout/
│   │   │   └── ...
│   │   ├── cron/                 # Cron jobs
│   │   └── health/               # Health check
│   ├── layout.tsx
│   └── page.tsx
├── src/                          # DDD layers
│   ├── domain/                   # Domain layer (pure)
│   │   ├── entities/             # Business entities
│   │   ├── value-objects/        # Value objects
│   │   ├── repositories/         # Repository interfaces
│   │   └── errors/               # Domain errors
│   ├── application/              # Application layer
│   │   ├── use-cases/            # Use case implementations
│   │   ├── dtos/                 # Data transfer objects
│   │   └── interfaces/           # Port interfaces
│   ├── infrastructure/           # Infrastructure layer
│   │   ├── database/             # MongoDB implementations
│   │   ├── redis/                # Redis implementations
│   │   ├── email/                # Email provider
│   │   └── crypto/               # Crypto services
│   ├── presentation/             # Presentation layer
│   │   ├── middleware/           # Express-style middleware
│   │   ├── helpers/              # Request/response helpers
│   │   └── validation/           # Zod schemas
│   ├── env.ts                    # Environment validation
│   └── instrumentation.ts        # Server initialization
├── docs/                         # Documentation
├── scripts/                      # Utility scripts
├── public/                       # Static assets
├── .env.example                  # Environment template
├── eslint.config.mjs             # ESLint configuration
├── tsconfig.json                 # TypeScript configuration
├── next.config.ts                # Next.js configuration
├── vercel.json                   # Vercel deployment config
└── package.json                  # Dependencies and scripts
```

### Available Scripts

```bash
# Development
pnpm dev                 # Start dev server with Turbopack on port 3001
pnpm build               # Build for production
pnpm start               # Start production server

# Code Quality
pnpm lint                # Run ESLint
pnpm type-check          # Run TypeScript type checking

# Testing
pnpm test                # Run tests
pnpm test:watch          # Run tests in watch mode
pnpm test:coverage       # Run tests with coverage
```

### Path Aliases

```typescript
import { User } from "@domain/entities/user.entity";
import { SignupUseCase } from "@app/use-cases/signup.use-case";
import { JWTService } from "@infra/crypto/jwt.service";
import { withAuth } from "@presentation/middleware/auth";
```

### Layer Boundary Rules

ESLint will error if you violate these rules:

- Domain cannot import from Application, Infrastructure, or Presentation
- Application cannot import from Infrastructure or Presentation
- Infrastructure cannot import from Presentation
- Presentation can import from all layers

**See:** [docs/dependency-rule.md](docs/dependency-rule.md) for detailed dependency rules.

## Testing

### Unit Tests

Test use cases and services in isolation:

```bash
pnpm test
```

### Integration Tests

Test API routes with real infrastructure:

```bash
pnpm test:integration
```

### E2E Tests

Test complete authentication flows:

```bash
pnpm test:e2e
```

### Test Coverage

```bash
pnpm test:coverage
```

Coverage reports generated in `coverage/` directory.

## Production Checklist

Before deploying to production:

### Environment

- [ ] Set `NODE_ENV=production`
- [ ] Configure production URLs in `NEXT_PUBLIC_SITE_URL` and `ALLOWED_ORIGINS`
- [ ] Generate production JWT keys (RS256, 2048-bit)
- [ ] Set strong `ENCRYPTION_KEY` (32-byte hex)
- [ ] Set strong `CRON_SECRET` (32-byte base64)
- [ ] Use production MongoDB cluster
- [ ] Use production Upstash Redis instance
- [ ] Configure Brevo API key with production sender

### Infrastructure

- [ ] MongoDB Atlas production cluster with replicas
- [ ] MongoDB indexes created (runs automatically via instrumentation.ts)
- [ ] Upstash Redis with high availability
- [ ] Vercel deployment configured
- [ ] Custom domain configured (auth.ankurhalder.com)
- [ ] SSL/TLS certificates active
- [ ] Cron job scheduled for `/api/cron/cleanup`

### Security

- [ ] JWT keys stored securely (never committed)
- [ ] Environment variables in Vercel dashboard (not .env files)
- [ ] Security headers configured in vercel.json
- [ ] CORS origins whitelisted correctly
- [ ] Rate limiting tested and tuned
- [ ] CSRF protection enabled
- [ ] Content Security Policy tested

### Monitoring

- [ ] Health check endpoint monitored (`/api/health`)
- [ ] Error tracking configured (e.g., Sentry)
- [ ] Performance monitoring enabled
- [ ] Audit logs reviewed regularly
- [ ] Database backups scheduled

### Testing

- [ ] All tests passing (`pnpm test`)
- [ ] Type checking clean (`pnpm type-check`)
- [ ] Linting clean (`pnpm lint`)
- [ ] Build succeeds (`pnpm build`)
- [ ] Manual testing of all flows
- [ ] Load testing completed

## Troubleshooting

### Common Issues

#### Build Errors

**Problem:** TypeScript errors during build

```bash
pnpm type-check
```

Fix type errors and rebuild.

**Problem:** ESLint errors during build

```bash
pnpm lint
```

Fix linting errors. Check for layer boundary violations.

#### Runtime Errors

**Problem:** "Invalid JWT signature"

- Verify `JWT_PRIVATE_KEY` and `JWT_PUBLIC_KEY` match
- Ensure keys are in PEM format with headers/footers
- Check key rotation configuration

**Problem:** "Failed to connect to MongoDB"

- Verify `MONGODB_URI` is correct
- Check IP whitelist in MongoDB Atlas
- Ensure network connectivity

**Problem:** "Redis connection failed"

- Verify `UPSTASH_REDIS_REST_URL` and `UPSTASH_REDIS_REST_TOKEN`
- Check Upstash Redis instance is active

**Problem:** "Email not sending"

- Verify `BREVO_API_KEY` is valid
- Check Brevo sender is verified
- Review Brevo dashboard for errors

#### Authentication Issues

**Problem:** "Email verification not working"

- Check email delivery in Brevo dashboard
- Verify link format and token expiry
- Check `NEXT_PUBLIC_SITE_URL` is correct

**Problem:** "OTP not received"

- Check admin user role in database
- Verify Brevo email delivery
- Check OTP rate limiting

**Problem:** "Token refresh failing"

- Verify refresh token cookie is sent
- Check session exists in database
- Review revocation store in Redis

### Debug Mode

Enable debug logging (in development):

```typescript
// src/presentation/middleware/auth.ts
console.log('Token verification:', { jti, userId, ... })
```

### Health Check

Monitor service health:

```bash
curl https://auth.ankurhalder.com/api/health
```

Response should return `200 OK` with:

```json
{ "success": true, "data": { "message": "Service healthy" } }
```

### Database Queries

Useful MongoDB queries for debugging:

```javascript
// Find user by email
db.users.findOne({ email: "user@example.com" });

// Check sessions for user
db.sessions.find({ userId: ObjectId("...") });

// Review recent auth events
db.authEvents.find().sort({ createdAt: -1 }).limit(10);

// Check expired sessions (should be cleaned by cron)
db.sessions.find({ expiresAt: { $lt: new Date() } });
```

## Documentation

Comprehensive documentation is available in the [docs/](docs/) directory:

- [**Architecture**](docs/architecture.md) - DDD architecture, layers, dependency rules
- [**Infrastructure**](docs/infrastructure.md) - Setup guides for MongoDB, Redis, Brevo, Vercel
- [**Features**](docs/features.md) - Detailed feature documentation, flows, diagrams
- [**Dependency Rules**](docs/dependency-rule.md) - Layer boundary rules and enforcement
- [**Development**](docs/development.md) - Development workflow, setup, guidelines
- [**Enforcement**](docs/enforcement.md) - ESLint rules, TypeScript strict mode
- [**Request Flow**](docs/request-flow.md) - Complete request lifecycle documentation

---

## License

MIT License

## Contact

For questions or support:

- **Email:** admin@ankurhalder.com
- **Website:** [ankurhalder.com](https://ankurhalder.com)

---

**Built with clean architecture principles and production-grade security.**


--------------------------------------------------------------------------------
File: scripts\crawl-project.js
--------------------------------------------------------------------------------

const fs = require("fs");
const path = require("path");

const CONFIG = {
  rootDir: path.join(__dirname, ".."),

  outputFile: "complete-codebase.txt",

  skipDirs: [
    "node_modules",
    ".next",
    ".git",
    "coverage",
    "dist",
    "build",
    "out",
    ".vercel",
    ".husky",
  ],

  skipFiles: [
    "package-lock.json",
    "pnpm-lock.yaml",
    "yarn.lock",
    "complete-codebase.txt",
    ".DS_Store",
    "tsconfig.tsbuildinfo",
  ],

  skipExtensions: [
    ".pem",
    ".key",
    ".jpg",
    ".jpeg",
    ".png",
    ".gif",
    ".svg",
    ".ico",
    ".woff",
    ".woff2",
    ".ttf",
    ".eot",
    ".mp4",
    ".webm",
    ".mp3",
    ".wav",
    ".pdf",
    ".zip",
    ".tar",
    ".gz",
    ".backup",
    ".tmp",
    ".log",
  ],

  includeExtensions: [
    ".ts",
    ".tsx",
    ".js",
    ".jsx",
    ".mjs",
    ".cjs",
    ".json",
    ".md",
    ".txt",
    ".env.example",
    ".gitignore",
    ".eslintrc",
    ".prettierrc",
    "Dockerfile",
    ".sh",
    ".yml",
    ".yaml",
  ],
};

function shouldSkip(filePath, stats) {
  const basename = path.basename(filePath);

  if (stats.isDirectory()) {
    return (
      CONFIG.skipDirs.includes(basename) || basename.startsWith("tmpclaude-")
    );
  }

  if (CONFIG.skipFiles.includes(basename)) {
    return true;
  }

  const ext = path.extname(filePath).toLowerCase();
  if (CONFIG.skipExtensions.includes(ext)) {
    return true;
  }

  if (CONFIG.includeExtensions.length > 0) {
    const hasValidExt = CONFIG.includeExtensions.some((validExt) => {
      if (validExt.startsWith(".")) {
        return ext === validExt;
      }
      return basename === validExt;
    });

    if (!hasValidExt) {
      return true;
    }
  }

  return false;
}

function generateTree(dir, prefix = "", isLast = true) {
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  const filtered = entries.filter((entry) => {
    const fullPath = path.join(dir, entry.name);
    return !shouldSkip(fullPath, entry);
  });

  let output = "";

  filtered.forEach((entry, index) => {
    const isLastEntry = index === filtered.length - 1;
    const connector = isLastEntry ? "└── " : "├── ";
    const fullPath = path.join(dir, entry.name);

    output += `${prefix}${connector}${entry.name}\n`;

    if (entry.isDirectory()) {
      const newPrefix = prefix + (isLastEntry ? "    " : "│   ");
      output += generateTree(fullPath, newPrefix, isLastEntry);
    }
  });

  return output;
}

function crawlDirectory(dir, files = []) {
  const entries = fs.readdirSync(dir, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);

    if (shouldSkip(fullPath, entry)) {
      continue;
    }

    if (entry.isDirectory()) {
      crawlDirectory(fullPath, files);
    } else if (entry.isFile()) {
      files.push(fullPath);
    }
  }

  return files;
}

function readFileContent(filePath) {
  try {
    return fs.readFileSync(filePath, "utf8");
  } catch (error) {
    return `[Error reading file: ${error.message}]`;
  }
}

function getRelativePath(filePath) {
  return path.relative(CONFIG.rootDir, filePath);
}

function crawlProject() {
  console.log("🔍 Starting project crawl...\n");

  const startTime = Date.now();
  const outputPath = path.join(CONFIG.rootDir, CONFIG.outputFile);

  console.log("📂 Scanning directories...");
  const files = crawlDirectory(CONFIG.rootDir);
  console.log(`   Found ${files.length} files\n`);

  console.log("🌳 Generating directory tree...");
  const projectName = path.basename(CONFIG.rootDir);
  const tree = `${projectName}/\n${generateTree(CONFIG.rootDir)}`;

  console.log("📝 Building output file...");
  let output = "";

  output += "=".repeat(80) + "\n";
  output += "COMPLETE CODEBASE\n";
  output += "=".repeat(80) + "\n";
  output += `Generated: ${new Date().toISOString()}\n`;
  output += `Project: ${projectName}\n`;
  output += `Total Files: ${files.length}\n`;
  output += "=".repeat(80) + "\n\n";

  output += "=".repeat(80) + "\n";
  output += "DIRECTORY STRUCTURE\n";
  output += "=".repeat(80) + "\n\n";
  output += tree + "\n\n";

  output += "=".repeat(80) + "\n";
  output += "FILE CONTENTS\n";
  output += "=".repeat(80) + "\n\n";

  files.forEach((file, index) => {
    const relativePath = getRelativePath(file);
    const content = readFileContent(file);

    output += "-".repeat(80) + "\n";
    output += `File: ${relativePath}\n`;
    output += "-".repeat(80) + "\n\n";
    output += content;
    output += "\n\n";

    if ((index + 1) % 50 === 0) {
      console.log(`   Processed ${index + 1}/${files.length} files...`);
    }
  });

  output += "=".repeat(80) + "\n";
  output += "END OF CODEBASE\n";
  output += "=".repeat(80) + "\n";

  console.log(`\n💾 Writing output to ${CONFIG.outputFile}...`);
  fs.writeFileSync(outputPath, output, "utf8");

  const duration = ((Date.now() - startTime) / 1000).toFixed(2);
  const sizeKB = (fs.statSync(outputPath).size / 1024).toFixed(2);

  console.log("\n✅ Project crawl complete!");
  console.log(`   Files processed: ${files.length}`);
  console.log(`   Output size: ${sizeKB} KB`);
  console.log(`   Duration: ${duration}s`);
  console.log(`   Output file: ${outputPath}\n`);
}

if (require.main === module) {
  try {
    crawlProject();
  } catch (error) {
    console.error("\n❌ Error during crawl:", error.message);
    console.error(error.stack);
    process.exit(1);
  }
}

module.exports = { crawlProject };


--------------------------------------------------------------------------------
File: scripts\pre-commit.js
--------------------------------------------------------------------------------

const { execSync } = require("child_process");
const fs = require("fs");
const path = require("path");

const colors = {
  reset: "\x1b[0m",
  bright: "\x1b[1m",
  red: "\x1b[31m",
  green: "\x1b[32m",
  yellow: "\x1b[33m",
  blue: "\x1b[34m",
  magenta: "\x1b[35m",
  cyan: "\x1b[36m",
};

const CONFIG = {
  skipRemoveComments: false,
  skipFormat: false,
  skipLint: false,
  skipTypeCheck: false,
  skipBuild: false,
  skipCrawl: false,
  skipArchValidation: false,
};

function log(message, color = "reset") {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

function logStep(step, total, message) {
  log(`\n[${step}/${total}] ${message}`, "cyan");
  log("─".repeat(60), "cyan");
}

function exec(command, description) {
  try {
    execSync(command, {
      stdio: "inherit",
      cwd: path.join(__dirname, ".."),
    });
    log(`✓ ${description} passed`, "green");
    return true;
  } catch (error) {
    log(`✗ ${description} failed`, "red");
    throw error;
  }
}

function hasStagedSourceChanges() {
  try {
    const output = execSync("git diff --cached --name-only", {
      cwd: path.join(__dirname, ".."),
      encoding: "utf8",
    });

    const stagedFiles = output.trim().split("\n").filter(Boolean);

    const sourceExtensions = [".ts", ".tsx", ".js", ".jsx", ".mjs", ".cjs"];
    return stagedFiles.some((file) =>
      sourceExtensions.some((ext) => file.endsWith(ext))
    );
  } catch (error) {
    return false;
  }
}

async function removeComments() {
  if (CONFIG.skipRemoveComments) {
    log("⊘ Skipping comment removal", "yellow");
    return;
  }

  const scriptPath = path.join(__dirname, "remove_comments.js");

  if (fs.existsSync(scriptPath)) {
    exec(`node "${scriptPath}"`, "Comment removal");
  } else {
    log("⊘ remove_comments.js not found, skipping", "yellow");
  }
}

async function formatCode() {
  if (CONFIG.skipFormat) {
    log("⊘ Skipping code formatting", "yellow");
    return;
  }

  const packageJson = require(path.join(__dirname, "..", "package.json"));

  if (packageJson.scripts && packageJson.scripts.format) {
    exec("npm run format", "Code formatting");
  } else {
    log("⊘ No format script found, skipping", "yellow");
  }
}

async function lintCode() {
  if (CONFIG.skipLint) {
    log("⊘ Skipping linting", "yellow");
    return;
  }

  exec("npx eslint . --max-warnings=0", "ESLint validation");
}

async function typeCheck() {
  if (CONFIG.skipTypeCheck) {
    log("⊘ Skipping type check", "yellow");
    return;
  }

  exec("npm run type-check", "TypeScript type checking");
}

async function buildProject() {
  if (CONFIG.skipBuild) {
    log("⊘ Skipping build", "yellow");
    return;
  }

  if (!hasStagedSourceChanges()) {
    log("⊘ No source changes, skipping build", "yellow");
    return;
  }

  exec("npm run build", "Next.js build");
}

async function generateProjectTree() {
  if (CONFIG.skipCrawl) {
    log("⊘ Skipping project crawl", "yellow");
    return;
  }

  const scriptPath = path.join(__dirname, "crawl-project.js");

  if (fs.existsSync(scriptPath)) {
    exec(`node "${scriptPath}"`, "Project tree generation");
  } else {
    log("⊘ crawl-project.js not found, skipping", "yellow");
  }
}

async function validateArchitecturalBoundaries() {
  if (CONFIG.skipArchValidation) {
    log("⊘ Skipping architectural validation", "yellow");
    return;
  }

  log("Validating DDD layer boundaries...", "cyan");

  const glob = require("glob");
  const violations = [];

  const rootDir = path.join(__dirname, "..");

  function checkImports(
    filePath,
    allowedPatterns,
    restrictedPatterns,
    layerName
  ) {
    if (!fs.existsSync(filePath)) return;

    const content = fs.readFileSync(filePath, "utf8");
    const lines = content.split("\n");

    lines.forEach((line, index) => {
      restrictedPatterns.forEach((pattern) => {
        const regex = new RegExp(`from\\s+['"]${pattern}`, "i");
        if (regex.test(line)) {
          violations.push({
            file: path.relative(rootDir, filePath),
            line: index + 1,
            message: `${layerName} layer cannot import from ${pattern}`,
            code: line.trim(),
          });
        }
      });
    });
  }

  const domainFiles = glob.sync("src/domain/**/*.ts", { cwd: rootDir });
  domainFiles.forEach((file) => {
    checkImports(
      path.join(rootDir, file),
      [],
      [
        "@app/",
        "@infra/",
        "@presentation/",
        "next/",
        "mongodb",
        "@upstash/",
        "@getbrevo/",
      ],
      "Domain"
    );
  });

  const appFiles = glob.sync("src/application/**/*.ts", { cwd: rootDir });
  appFiles.forEach((file) => {
    checkImports(
      path.join(rootDir, file),
      ["@domain/"],
      [
        "@infra/database/",
        "@infra/email/",
        "@presentation/",
        "next/",
        "mongodb",
        "@upstash/",
      ],
      "Application"
    );
  });

  const infraFiles = glob.sync("src/infrastructure/**/*.ts", { cwd: rootDir });
  infraFiles.forEach((file) => {
    checkImports(
      path.join(rootDir, file),
      ["@domain/", "@app/"],
      ["@presentation/"],
      "Infrastructure"
    );
  });

  if (violations.length > 0) {
    log("", "reset");
    log("✗ Architectural boundary violations detected:", "red");
    log("", "reset");

    violations.forEach((v) => {
      log(`  ${v.file}:${v.line}`, "yellow");
      log(`    ${v.message}`, "red");
      log(`    ${v.code}`, "magenta");
      log("", "reset");
    });

    throw new Error(`Found ${violations.length} architectural violations`);
  }

  log("✓ No architectural boundary violations", "green");
}

async function preCommit() {
  const startTime = Date.now();

  log("", "reset");
  log("═".repeat(60), "bright");
  log("  PRE-COMMIT VALIDATION", "bright");
  log("═".repeat(60), "bright");
  log("", "reset");

  const totalSteps = 7;
  let currentStep = 0;

  try {
    logStep(++currentStep, totalSteps, "Removing comments");
    await removeComments();

    logStep(++currentStep, totalSteps, "Formatting code");
    await formatCode();

    logStep(++currentStep, totalSteps, "Linting code");
    await lintCode();

    logStep(++currentStep, totalSteps, "Type checking");
    await typeCheck();

    logStep(++currentStep, totalSteps, "Building project");
    await buildProject();

    logStep(++currentStep, totalSteps, "Generating project tree");
    await generateProjectTree();

    logStep(++currentStep, totalSteps, "Validating architectural boundaries");
    await validateArchitecturalBoundaries();

    const duration = ((Date.now() - startTime) / 1000).toFixed(2);

    log("", "reset");
    log("═".repeat(60), "green");
    log("  ✅ ALL CHECKS PASSED!", "green");
    log(`  Duration: ${duration}s`, "green");
    log("═".repeat(60), "green");
    log("", "reset");

    process.exit(0);
  } catch (error) {
    const duration = ((Date.now() - startTime) / 1000).toFixed(2);

    log("", "reset");
    log("═".repeat(60), "red");
    log("  ❌ PRE-COMMIT VALIDATION FAILED", "red");
    log(`  Duration: ${duration}s`, "red");
    log("═".repeat(60), "red");
    log("", "reset");

    log("Please fix the errors above before committing.", "yellow");
    log("", "reset");

    process.exit(1);
  }
}

if (require.main === module) {
  try {
    require("glob");
  } catch (error) {
    log("⚠️  glob package not found. Install dependencies first:", "yellow");
    log("   npm install", "yellow");
    log("", "reset");
    process.exit(1);
  }

  preCommit().catch((error) => {
    log("", "reset");
    log("❌ Unexpected error:", "red");
    log(error.message, "red");
    log("", "reset");
    process.exit(1);
  });
}

module.exports = { preCommit };


--------------------------------------------------------------------------------
File: scripts\remove_comments.js
--------------------------------------------------------------------------------

const fs = require("fs");
const path = require("path");

const CONFIG = {
  rootDir: path.join(__dirname, ".."),
  targetDirs: ["src", "app", "scripts"],
  skipDirs: [
    "node_modules",
    ".next",
    ".git",
    "coverage",
    "dist",
    "build",
    "out",
    ".vercel",
    ".husky",
  ],
  srcExtensions: [".ts", ".tsx"],
  appExtensions: [".ts", ".tsx"],
  scriptExtensions: [".js", ".mjs"],
  excludeFiles: ["next-env.d.ts"],
  preservePatterns: [
    "@ts-expect-error",
    "@ts-ignore",
    "@ts-nocheck",
    "@deprecated",
    "@internal",
    "eslint-disable",
    "eslint-enable",
    "eslint-disable-next-line",
    "prettier-ignore",
    "prettier-disable",
    "prettier-enable",
    "TODO",
    "FIXME",
    "HACK",
    "XXX",
    "NOTE",
    "IMPORTANT",
  ],
  dryRun: false,
};

function shouldSkipDir(dirName) {
  return CONFIG.skipDirs.includes(dirName) || dirName.startsWith("tmpclaude-");
}

function shouldProcess(filePath) {
  const basename = path.basename(filePath);

  if (CONFIG.excludeFiles.includes(basename)) {
    return false;
  }

  if (basename.endsWith(".d.ts")) {
    return false;
  }

  const ext = path.extname(filePath);
  const relPath = path.relative(CONFIG.rootDir, filePath);
  const isInSrc = relPath.startsWith("src");
  const isInApp = relPath.startsWith("app");
  const isInScripts = relPath.startsWith("scripts");

  if (isInSrc || isInApp) {
    return (
      CONFIG.srcExtensions.includes(ext) || CONFIG.appExtensions.includes(ext)
    );
  }

  if (isInScripts) {
    return CONFIG.scriptExtensions.includes(ext);
  }

  return false;
}

function shouldPreserveComment(comment) {
  return CONFIG.preservePatterns.some((pattern) => comment.includes(pattern));
}

function removeComments(code) {
  let result = "";
  let i = 0;

  while (i < code.length) {
    const char = code[i];

    if (char === '"' || char === "'" || char === "`") {
      const quote = char;
      result += char;
      i++;

      while (i < code.length) {
        if (code[i] === "\\") {
          result += code[i];
          i++;
          if (i < code.length) {
            result += code[i];
            i++;
          }
        } else if (code[i] === quote) {
          result += code[i];
          i++;
          break;
        } else {
          result += code[i];
          i++;
        }
      }
      continue;
    }

    if (code[i] === "/" && i + 1 < code.length && code[i + 1] === "*") {
      let comment = "";
      let startPos = i;
      let j = i;

      while (j < code.length) {
        comment += code[j];
        if (code[j] === "*" && j + 1 < code.length && code[j + 1] === "/") {
          comment += code[++j];
          j++;
          break;
        }
        j++;
      }

      if (shouldPreserveComment(comment)) {
        result += comment;
      } else {
        const newlines = (comment.match(/\n/g) || []).length;
        result += "\n".repeat(newlines);
      }
      i = j;
      continue;
    }

    if (code[i] === "/" && i + 1 < code.length && code[i + 1] === "/") {
      let comment = "";
      let j = i;

      while (j < code.length && code[j] !== "\n") {
        comment += code[j];
        j++;
      }

      if (shouldPreserveComment(comment)) {
        result += comment;
        if (j < code.length && code[j] === "\n") {
          result += "\n";
          j++;
        }
      } else {
        if (j < code.length && code[j] === "\n") {
          j++;
        }
      }
      i = j;
      continue;
    }

    result += char;
    i++;
  }

  return result;
}

function removeEmptyLines(code) {
  const lines = code.split("\n");
  const result = [];

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const trimmed = line.trim();

    if (trimmed === "") {
      if (i === 0 || i === lines.length - 1) {
        if (i === 0) {
          result.push(line);
        } else {
          result.push(line);
        }
      } else {
        if (result.length > 0 && result[result.length - 1].trim() !== "") {
          result.push(line);
        }
      }
    } else {
      result.push(line);
    }
  }

  while (result.length > 0 && result[result.length - 1].trim() === "") {
    result.pop();
  }

  return result.join("\n");
}

function processFile(filePath) {
  try {
    const originalCode = fs.readFileSync(filePath, "utf8");
    let processedCode = removeComments(originalCode);
    processedCode = removeEmptyLines(processedCode);

    if (originalCode === processedCode) {
      return { modified: false };
    }

    const originalComments = (
      originalCode.match(/\/\*[\s\S]*?\*\/|\/\/.*/g) || []
    ).filter((c) => !shouldPreserveComment(c)).length;

    if (!CONFIG.dryRun) {
      fs.writeFileSync(filePath, processedCode, "utf8");
    }

    return { modified: true, commentsRemoved: originalComments };
  } catch (error) {
    return { error: error.message };
  }
}

function getFileList(dir, extensions, baseDir = "") {
  const files = [];
  const entries = fs.readdirSync(dir, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    const relativePath = baseDir ? path.join(baseDir, entry.name) : entry.name;

    if (entry.isDirectory()) {
      if (!shouldSkipDir(entry.name)) {
        files.push(...getFileList(fullPath, extensions, relativePath));
      }
    } else if (entry.isFile()) {
      const ext = path.extname(fullPath);
      if (extensions.includes(ext) && shouldProcess(fullPath)) {
        files.push(fullPath);
      }
    }
  }

  return files;
}

function processDirectory(dir) {
  const stats = {
    processed: 0,
    modified: 0,
    errors: 0,
    commentsRemoved: 0,
    modifiedFiles: [],
  };

  const srcDir = path.join(dir, "src");
  const appDir = path.join(dir, "app");
  const scriptsDir = path.join(dir, "scripts");

  const filesToProcess = [];

  if (fs.existsSync(srcDir)) {
    filesToProcess.push(...getFileList(srcDir, CONFIG.srcExtensions));
  }

  if (fs.existsSync(appDir)) {
    filesToProcess.push(...getFileList(appDir, CONFIG.appExtensions));
  }

  if (fs.existsSync(scriptsDir)) {
    filesToProcess.push(...getFileList(scriptsDir, CONFIG.scriptExtensions));
  }

  for (const filePath of filesToProcess) {
    const result = processFile(filePath);
    stats.processed++;

    if (result.error) {
      console.log(`   ✗ ${path.relative(dir, filePath)}: ${result.error}`);
      stats.errors++;
    } else if (result.modified) {
      const relPath = path.relative(dir, filePath);
      console.log(`   ✓ ${relPath}`);
      stats.modified++;
      stats.commentsRemoved += result.commentsRemoved || 0;
      stats.modifiedFiles.push(relPath);
    }
  }

  return stats;
}

function main() {
  console.log("Removing comments from source files...\n");

  if (CONFIG.dryRun) {
    console.log("DRY RUN MODE - No files will be modified\n");
  }

  const startTime = Date.now();
  const stats = processDirectory(CONFIG.rootDir);
  const duration = ((Date.now() - startTime) / 1000).toFixed(2);

  console.log("\nComment removal complete!");
  console.log(`Files processed: ${stats.processed}`);
  console.log(`Files modified: ${stats.modified}`);
  console.log(`Comments removed: ${stats.commentsRemoved}`);
  console.log(`Errors: ${stats.errors}`);
  console.log(`Duration: ${duration}s\n`);

  if (stats.modified > 0) {
    console.log("Modified files:");
    stats.modifiedFiles.forEach((file) => {
      console.log(`  - ${file}`);
    });
    console.log();
  }

  if (stats.errors > 0) {
    process.exit(1);
  }
}

if (require.main === module) {
  try {
    main();
  } catch (error) {
    console.error("Error removing comments:", error.message);
    console.error(error.stack);
    process.exit(1);
  }
}

module.exports = { removeComments, processFile };


--------------------------------------------------------------------------------
File: scripts\version-increment.js
--------------------------------------------------------------------------------

import {
  readFileSync,
  writeFileSync,
  existsSync,
  copyFileSync,
  unlinkSync,
} from "fs";
import { execSync } from "child_process";

const packageJsonPath = "./package.json";

function validatePrerequisites() {
  if (!existsSync(packageJsonPath)) {
    console.error(`❌ ERROR: package.json not found at ${packageJsonPath}`);
    process.exit(1);
  }

  try {
    execSync("git --version", { stdio: "ignore" });
  } catch {
    console.error("❌ ERROR: Git is not available in PATH");
    process.exit(1);
  }

  try {
    execSync("git rev-parse --git-dir", { stdio: "ignore" });
  } catch {
    console.error("❌ ERROR: Not in a git repository");
    process.exit(1);
  }
}

function loadPackageJson() {
  try {
    const content = readFileSync(packageJsonPath, "utf8");
    const packageJson = JSON.parse(content);

    if (!packageJson.version) {
      console.error("❌ ERROR: package.json does not contain a version field");
      process.exit(1);
    }

    return packageJson;
  } catch (err) {
    if (err instanceof SyntaxError) {
      console.error("❌ ERROR: package.json contains invalid JSON");
      console.error(`   ${err.message}`);
    } else {
      console.error("❌ ERROR: Failed to read package.json");
      console.error(`   ${err.message}`);
    }
    process.exit(1);
  }
}

function parseVersion(version) {
  if (typeof version !== "string") {
    console.error(`❌ ERROR: Version must be a string, got ${typeof version}`);
    process.exit(1);
  }

  const versionRegex = /^(\d+)\.(\d+)\.(\d+)$/;
  const match = version.match(versionRegex);

  if (!match) {
    console.error(`❌ ERROR: Invalid version format: ${version}`);
    console.error("   Expected format: X.Y.Z (e.g., 1.0.0)");
    process.exit(1);
  }

  return {
    major: parseInt(match[1], 10),
    minor: parseInt(match[2], 10),
    patch: parseInt(match[3], 10),
  };
}

function incrementVersion(version) {
  const { major } = version;
  let { minor, patch } = version;

  patch += 1;

  if (patch >= 10) {
    patch = 0;
    minor += 1;
  }

  return `${major}.${minor}.${patch}`;
}

function safeWritePackageJson(packageJson) {
  const tempPath = `${packageJsonPath}.tmp`;
  const backupPath = `${packageJsonPath}.backup`;

  try {
    if (existsSync(packageJsonPath)) {
      copyFileSync(packageJsonPath, backupPath);
    }

    const content = JSON.stringify(packageJson, null, 2) + "\n";
    writeFileSync(tempPath, content, "utf8");

    const written = readFileSync(tempPath, "utf8");
    if (written !== content) {
      throw new Error("File content verification failed");
    }

    try {
      JSON.parse(written);
    } catch {
      throw new Error("Generated file contains invalid JSON");
    }

    if (existsSync(packageJsonPath)) {
      unlinkSync(packageJsonPath);
    }
    copyFileSync(tempPath, packageJsonPath);
    unlinkSync(tempPath);

    if (existsSync(backupPath)) {
      unlinkSync(backupPath);
    }
  } catch (err) {
    if (existsSync(backupPath)) {
      if (existsSync(packageJsonPath)) {
        unlinkSync(packageJsonPath);
      }
      copyFileSync(backupPath, packageJsonPath);
      unlinkSync(backupPath);
    }

    if (existsSync(tempPath)) {
      unlinkSync(tempPath);
    }

    throw err;
  }
}

function stagePackageJson() {
  try {
    execSync("git add package.json", { stdio: "pipe" });
  } catch (err) {
    console.error("❌ ERROR: Failed to stage package.json");
    console.error(`   ${err.message}`);
    throw err;
  }
}

function main() {
  console.warn(
    "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
  );
  console.warn("  VERSION INCREMENT");
  console.warn(
    "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
  );
  console.warn("");

  try {
    validatePrerequisites();

    const packageJson = loadPackageJson();
    const currentVersion = packageJson.version;

    console.warn(`Current version: ${currentVersion}`);

    const parsedVersion = parseVersion(currentVersion);

    const newVersion = incrementVersion(parsedVersion);

    console.warn(`New version:     ${newVersion}`);

    packageJson.version = newVersion;

    safeWritePackageJson(packageJson);

    stagePackageJson();

    console.warn("");
    console.warn(
      "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    );
    console.warn(`✅ SUCCESS: Version incremented`);
    console.warn(`   ${currentVersion} → ${newVersion}`);
    console.warn(
      "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    );
    console.warn("");

    process.exit(0);
  } catch (err) {
    console.warn("");
    console.warn(
      "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    );
    console.error("❌ FAILED: Version increment failed");
    console.error(`   ${err.message}`);
    if (err.stack) {
      console.error(`   Stack: ${err.stack}`);
    }
    console.warn(
      "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    );
    console.warn("");

    process.exit(1);
  }
}

main();


--------------------------------------------------------------------------------
File: src\application\dtos\auth.dto.ts
--------------------------------------------------------------------------------

export interface SignupInput {
  email: string;
  password: string;
  name?: string;
}

export interface SignupOutput {
  success: true;
  message: string;
}

export interface SigninInput {
  email: string;
  password: string;
  rememberMe?: boolean;
}

export interface SigninOutputAuthenticated {
  isAuthenticated: true;
  requiresOtp: false;
  user: {
    id: string;
    email: string;
    role: "admin" | "user";
    tier: "free" | "pro";
  };

  accessToken: string;

  refreshToken: string;
}

export interface SigninOutputOtpRequired {
  isAuthenticated: false;
  requiresOtp: true;
  otpSent: true;
  message: string;
}

export type SigninOutput = SigninOutputAuthenticated | SigninOutputOtpRequired;

export interface VerifyOtpInput {
  email: string;
  otp: string;
}

export interface VerifyOtpOutput {
  isAuthenticated: true;
  user: {
    id: string;
    email: string;
    role: "admin" | "user";
    tier: "free" | "pro";
  };
  accessToken: string;
  refreshToken: string;
}

export interface RefreshTokenInput {
  refreshToken: string;
}

export interface RefreshTokenOutput {
  success: true;
  accessToken: string;
  refreshToken: string;
}

export interface LogoutInput {
  sessionId: string;
  userId: string;
}

export interface LogoutOutput {
  success: true;
  message: string;
}

export interface GlobalLogoutInput {
  userId: string;
}

export interface GlobalLogoutOutput {
  success: true;
  message: string;
  sessionsRevoked: number;
}

export interface RequestContext {
  requestId: string;

  ipAddress: string;

  userAgent: string;
}


--------------------------------------------------------------------------------
File: src\application\dtos\user.dto.ts
--------------------------------------------------------------------------------

export interface CurrentUserOutput {
  id: string;
  email: string;
  role: "admin" | "user";
  tier: "free" | "pro";
  isVerified: boolean;
  createdAt: string;
}


--------------------------------------------------------------------------------
File: src\application\interfaces\email.provider.ts
--------------------------------------------------------------------------------

export interface IEmailProvider {
  sendVerificationEmail(to: string, token: string): Promise<void>;

  sendOtpEmail(to: string, otp: string): Promise<void>;

  sendPasswordResetEmail(to: string, token: string): Promise<void>;

  sendContactFormEmail(
    from: string,
    name: string,
    subject: string,
    message: string
  ): Promise<void>;
}


--------------------------------------------------------------------------------
File: src\application\interfaces\revocation.store.ts
--------------------------------------------------------------------------------

export interface IRevocationStore {
  revokeToken(jti: string, ttlSeconds: number): Promise<void>;

  isTokenRevoked(jti: string): Promise<boolean>;

  revokeSession(sessionId: string, ttlSeconds: number): Promise<void>;

  isSessionRevoked(sessionId: string): Promise<boolean>;

  revokeAllUserSessions(userId: string, ttlSeconds: number): Promise<void>;

  getUserRevocationTimestamp(userId: string): Promise<number | null>;
}


--------------------------------------------------------------------------------
File: src\application\interfaces\token.service.ts
--------------------------------------------------------------------------------

export interface AccessTokenPayload {
  sub: string;

  email: string;

  role: "admin" | "user";

  sessionId: string;

  jti: string;

  tv: number;

  iat: number;

  exp: number;
}

export interface RefreshTokenPayload {
  sub: string;

  sessionId: string;

  jti: string;

  tv: number;

  iat: number;

  exp: number;
}

export interface GeneratedToken {
  token: string;

  jti: string;
}

export interface ITokenService {
  generateAccessToken(payload: {
    userId: string;
    email: string;
    role: "admin" | "user";
    sessionId: string;
    tokenVersion: number;
  }): Promise<GeneratedToken>;

  generateRefreshToken(payload: {
    userId: string;
    sessionId: string;
    tokenVersion: number;
    ttlSeconds: number;
  }): Promise<GeneratedToken>;

  verifyAccessToken(token: string): Promise<AccessTokenPayload | null>;

  verifyRefreshToken(token: string): Promise<RefreshTokenPayload | null>;

  getJwksData(): Promise<JsonWebKeySet>;
}

export interface JsonWebKeySet {
  keys: JsonWebKey[];
}

export interface JsonWebKey {
  kty: string;
  kid: string;
  alg: string;
  use: string;
  n: string;
  e: string;
}


--------------------------------------------------------------------------------
File: src\application\use-cases\forgot-password.use-case.ts
--------------------------------------------------------------------------------

import type { IUserRepository } from "@domain/repositories/user.repository";
import type { IAuthEventRepository } from "@domain/repositories/auth-event.repository";
import type { IEmailProvider } from "@app/interfaces/email.provider";
import type { RequestContext } from "@app/dtos/auth.dto";
import { generateRandomToken, sha256Hash } from "@infra/crypto/hash";
import { encryptOtp } from "@infra/crypto/otp.service";

export interface ForgotPasswordInput {
  email: string;
}

export interface ForgotPasswordOutput {
  success: true;
  message: string;
}

const RESET_TOKEN_EXPIRY_MS = 60 * 60 * 1000;

export class ForgotPasswordUseCase {
  constructor(
    private readonly userRepository: IUserRepository,
    private readonly authEventRepository: IAuthEventRepository,
    private readonly emailProvider: IEmailProvider
  ) {}

  async execute(
    input: ForgotPasswordInput,
    ctx: RequestContext
  ): Promise<ForgotPasswordOutput> {
    const email = input.email.toLowerCase().trim();

    const genericResponse: ForgotPasswordOutput = {
      success: true,
      message:
        "If an account exists with this email, a password reset link has been sent.",
    };

    const user = await this.userRepository.findByEmail(email);

    if (!user) {
      void this.authEventRepository.create({
        eventType: "PASSWORD_RESET_REQUESTED",
        email,
        ipAddress: ctx.ipAddress,
        userAgent: ctx.userAgent,
        timestamp: new Date(),
        success: false,
        failureReason: "user_not_found",
        serviceId: "auth-service",
        requestId: ctx.requestId,
      });

      return genericResponse;
    }

    const rawResetToken = generateRandomToken(32);

    const resetTokenHash = sha256Hash(rawResetToken);

    const encryptedResetToken = encryptOtp(rawResetToken);

    const resetTokenExpiry = new Date(Date.now() + RESET_TOKEN_EXPIRY_MS);

    await this.userRepository.updatePasswordResetToken(user.id, {
      passwordResetToken: encryptedResetToken,
      passwordResetTokenHash: resetTokenHash,
      passwordResetTokenExpiry: resetTokenExpiry,
    });

    this.emailProvider
      .sendPasswordResetEmail(user.email, rawResetToken)
      .catch((error: unknown) => {
        console.error(
          `[ForgotPasswordUseCase] Failed to send reset email to ${user.email}:`,
          error instanceof Error ? error.message : "Unknown error"
        );
      });

    void this.authEventRepository.create({
      eventType: "PASSWORD_RESET_REQUESTED",
      userId: user.id,
      email: user.email,
      ipAddress: ctx.ipAddress,
      userAgent: ctx.userAgent,
      timestamp: new Date(),
      success: true,
      serviceId: "auth-service",
      requestId: ctx.requestId,
    });

    return genericResponse;
  }
}


--------------------------------------------------------------------------------
File: src\application\use-cases\get-current-user.use-case.ts
--------------------------------------------------------------------------------

import type { IUserRepository } from "@domain/repositories/user.repository";
import type { CurrentUserOutput } from "@app/dtos/user.dto";
import { NotFoundError } from "@domain/errors/not-found.error";

export interface GetCurrentUserInput {
  userId: string;
}

export class GetCurrentUserUseCase {
  constructor(private readonly userRepository: IUserRepository) {}

  async execute(input: GetCurrentUserInput): Promise<CurrentUserOutput> {
    const user = await this.userRepository.findById(input.userId);

    if (!user) {
      throw new NotFoundError("User not found");
    }

    return {
      id: user.id,
      email: user.email,
      role: user.role,
      tier: user.tier,
      isVerified: user.isVerified,
      createdAt: user.createdAt.toISOString(),
    };
  }
}


--------------------------------------------------------------------------------
File: src\application\use-cases\global-logout.use-case.ts
--------------------------------------------------------------------------------

import type { IUserRepository } from "@domain/repositories/user.repository";
import type { ISessionRepository } from "@domain/repositories/session.repository";
import type { IAuthEventRepository } from "@domain/repositories/auth-event.repository";
import type { IRevocationStore } from "@app/interfaces/revocation.store";
import type {
  GlobalLogoutInput,
  GlobalLogoutOutput,
  RequestContext,
} from "@app/dtos/auth.dto";
import { NotFoundError } from "@domain/errors/not-found.error";
import { UserMethods } from "@domain/entities/user.entity";

const USER_REVOCATION_TTL_SECONDS = 30 * 24 * 60 * 60;

export class GlobalLogoutUseCase {
  constructor(
    private readonly userRepository: IUserRepository,
    private readonly sessionRepository: ISessionRepository,
    private readonly authEventRepository: IAuthEventRepository,
    private readonly revocationStore: IRevocationStore
  ) {}

  async execute(
    input: GlobalLogoutInput,
    ctx: RequestContext
  ): Promise<GlobalLogoutOutput> {
    const user = await this.userRepository.findById(input.userId);
    if (!user) {
      throw new NotFoundError("User not found");
    }

    const newTokenVersion = UserMethods.incrementTokenVersion(user);
    await this.userRepository.updateTokenVersion(user.id, newTokenVersion);

    await this.revocationStore.revokeAllUserSessions(
      user.id,
      USER_REVOCATION_TTL_SECONDS
    );

    const deletedCount = await this.sessionRepository.deleteAllForUser(user.id);

    void this.authEventRepository.create({
      eventType: "GLOBAL_LOGOUT",
      userId: user.id,
      email: user.email,
      ipAddress: ctx.ipAddress,
      userAgent: ctx.userAgent,
      timestamp: new Date(),
      success: true,
      metadata: {
        sessionsDeleted: deletedCount,
        newTokenVersion,
      },
      serviceId: "auth-service",
      requestId: ctx.requestId,
    });

    return {
      success: true,
      message: "All sessions have been revoked",
      sessionsRevoked: deletedCount,
    };
  }
}


--------------------------------------------------------------------------------
File: src\application\use-cases\logout.use-case.ts
--------------------------------------------------------------------------------

import type { ISessionRepository } from "@domain/repositories/session.repository";
import type { IAuthEventRepository } from "@domain/repositories/auth-event.repository";
import type { IRevocationStore } from "@app/interfaces/revocation.store";
import type {
  LogoutInput,
  LogoutOutput,
  RequestContext,
} from "@app/dtos/auth.dto";

const SESSION_REVOCATION_TTL_SECONDS = 7 * 24 * 60 * 60;

export class LogoutUseCase {
  constructor(
    private readonly sessionRepository: ISessionRepository,
    private readonly authEventRepository: IAuthEventRepository,
    private readonly revocationStore: IRevocationStore
  ) {}

  async execute(
    input: LogoutInput,
    ctx: RequestContext
  ): Promise<LogoutOutput> {
    await this.revocationStore.revokeSession(
      input.sessionId,
      SESSION_REVOCATION_TTL_SECONDS
    );

    await this.sessionRepository.delete(input.sessionId);

    void this.authEventRepository.create({
      eventType: "LOGOUT",
      userId: input.userId,
      sessionId: input.sessionId,
      ipAddress: ctx.ipAddress,
      userAgent: ctx.userAgent,
      timestamp: new Date(),
      success: true,
      serviceId: "auth-service",
      requestId: ctx.requestId,
    });

    return {
      success: true,
      message: "Logged out successfully",
    };
  }
}


--------------------------------------------------------------------------------
File: src\application\use-cases\refresh-token.use-case.ts
--------------------------------------------------------------------------------

import { v4 as uuidv4 } from "uuid";
import type { IUserRepository } from "@domain/repositories/user.repository";
import type { ISessionRepository } from "@domain/repositories/session.repository";
import type { IAuthEventRepository } from "@domain/repositories/auth-event.repository";
import type { ITokenService } from "@app/interfaces/token.service";
import type { IRevocationStore } from "@app/interfaces/revocation.store";
import type {
  RefreshTokenInput,
  RefreshTokenOutput,
  RequestContext,
} from "@app/dtos/auth.dto";
import { TokenError } from "@domain/errors/token.error";
import { sha256Hash } from "@infra/crypto/hash";

const DEFAULT_SESSION_TTL_SECONDS = 7 * 24 * 60 * 60;

export class RefreshTokenUseCase {
  constructor(
    private readonly userRepository: IUserRepository,
    private readonly sessionRepository: ISessionRepository,
    private readonly authEventRepository: IAuthEventRepository,
    private readonly tokenService: ITokenService,
    private readonly revocationStore: IRevocationStore
  ) {}

  async execute(
    input: RefreshTokenInput,
    ctx: RequestContext
  ): Promise<RefreshTokenOutput> {
    const tokenHash = sha256Hash(input.refreshToken);

    const oldSession =
      await this.sessionRepository.findAndDeleteByRefreshTokenHash(tokenHash);

    if (!oldSession) {
      void this.authEventRepository.create({
        eventType: "TOKEN_REFRESH_FAILED",
        ipAddress: ctx.ipAddress,
        userAgent: ctx.userAgent,
        timestamp: new Date(),
        success: false,
        failureReason: "session_not_found",
        serviceId: "auth-service",
        requestId: ctx.requestId,
      });
      throw new TokenError("invalid_signature", "Invalid refresh token");
    }

    const refreshPayload = await this.tokenService.verifyRefreshToken(
      input.refreshToken
    );

    if (!refreshPayload) {
      void this.authEventRepository.create({
        eventType: "TOKEN_REFRESH_FAILED",
        userId: oldSession.userId,
        sessionId: oldSession.sessionId,
        ipAddress: ctx.ipAddress,
        userAgent: ctx.userAgent,
        timestamp: new Date(),
        success: false,
        failureReason: "jwt_verification_failed",
        serviceId: "auth-service",
        requestId: ctx.requestId,
      });
      throw new TokenError("invalid_signature", "Invalid refresh token");
    }

    const [sessionRevoked, userRevocationTs] = await Promise.all([
      this.revocationStore.isSessionRevoked(refreshPayload.sessionId),
      this.revocationStore.getUserRevocationTimestamp(refreshPayload.sub),
    ]);

    if (sessionRevoked) {
      throw new TokenError("revoked", "Session has been revoked");
    }

    if (
      userRevocationTs !== null &&
      refreshPayload.iat * 1000 < userRevocationTs
    ) {
      throw new TokenError("revoked", "All sessions have been revoked");
    }

    const user = await this.userRepository.findById(refreshPayload.sub);

    if (!user) {
      throw new TokenError("user_not_found", "User no longer exists");
    }

    if (!user.isVerified) {
      throw new TokenError("user_not_verified", "User is not verified");
    }

    if (refreshPayload.tv !== user.tokenVersion) {
      throw new TokenError("version_mismatch", "Token version mismatch");
    }

    const newSessionId = uuidv4();

    const remainingMs = oldSession.expiresAt.getTime() - Date.now();
    const remainingSeconds = Math.max(
      Math.ceil(remainingMs / 1000),
      DEFAULT_SESSION_TTL_SECONDS
    );

    const [newAccessResult, newRefreshResult] = await Promise.all([
      this.tokenService.generateAccessToken({
        userId: user.id,
        email: user.email,
        role: user.role,
        sessionId: newSessionId,
        tokenVersion: user.tokenVersion,
      }),
      this.tokenService.generateRefreshToken({
        userId: user.id,
        sessionId: newSessionId,
        tokenVersion: user.tokenVersion,
        ttlSeconds: remainingSeconds,
      }),
    ]);

    const newRefreshTokenHash = sha256Hash(newRefreshResult.token);

    await this.sessionRepository.create({
      sessionId: newSessionId,
      userId: user.id,
      refreshTokenHash: newRefreshTokenHash,
      ipAddress: ctx.ipAddress,
      userAgent: ctx.userAgent,
      expiresAt: new Date(Date.now() + remainingSeconds * 1000),
      lastUsedAt: new Date(),
    });

    void this.authEventRepository.create({
      eventType: "TOKEN_REFRESH",
      userId: user.id,
      email: user.email,
      sessionId: newSessionId,
      ipAddress: ctx.ipAddress,
      userAgent: ctx.userAgent,
      timestamp: new Date(),
      success: true,
      metadata: {
        oldSessionId: oldSession.sessionId,
        newSessionId,
      },
      serviceId: "auth-service",
      requestId: ctx.requestId,
    });

    return {
      success: true,
      accessToken: newAccessResult.token,
      refreshToken: newRefreshResult.token,
    };
  }
}


--------------------------------------------------------------------------------
File: src\application\use-cases\resend-verification.use-case.ts
--------------------------------------------------------------------------------

import type { IUserRepository } from "@domain/repositories/user.repository";
import type { IAuthEventRepository } from "@domain/repositories/auth-event.repository";
import type { IEmailProvider } from "@app/interfaces/email.provider";
import type { RequestContext } from "@app/dtos/auth.dto";
import { ValidationError } from "@domain/errors/validation.error";
import { generateRandomToken, sha256Hash } from "@infra/crypto/hash";
import { encryptOtp } from "@infra/crypto/otp.service";

export interface ResendVerificationInput {
  email: string;
}

export interface ResendVerificationOutput {
  success: true;
  message: string;
}

const VERIFICATION_TOKEN_EXPIRY_MS = 60 * 60 * 1000;

export class ResendVerificationUseCase {
  constructor(
    private readonly userRepository: IUserRepository,
    private readonly authEventRepository: IAuthEventRepository,
    private readonly emailProvider: IEmailProvider
  ) {}

  async execute(
    input: ResendVerificationInput,
    ctx: RequestContext
  ): Promise<ResendVerificationOutput> {
    const email = input.email.toLowerCase().trim();

    const user = await this.userRepository.findByEmail(email);

    if (!user) {
      return {
        success: true,
        message:
          "If an account exists with this email, a verification link has been sent.",
      };
    }

    if (user.isVerified) {
      throw new ValidationError("This email address is already verified");
    }

    const rawVerificationToken = generateRandomToken(32);
    const verificationTokenHash = sha256Hash(rawVerificationToken);
    const verificationTokenExpiry = new Date(
      Date.now() + VERIFICATION_TOKEN_EXPIRY_MS
    );
    const encryptedVerificationToken = encryptOtp(rawVerificationToken);

    await this.userRepository.updateVerificationToken(user.id, {
      verificationToken: encryptedVerificationToken,
      verificationTokenHash,
      verificationTokenExpiry,
    });

    this.emailProvider
      .sendVerificationEmail(user.email, rawVerificationToken)
      .catch((error: unknown) => {
        console.error(
          `[ResendVerificationUseCase] Failed to send verification email to ${user.email}:`,
          error instanceof Error ? error.message : "Unknown error"
        );
      });

    void this.authEventRepository.create({
      eventType: "VERIFICATION_RESENT",
      userId: user.id,
      email: user.email,
      ipAddress: ctx.ipAddress,
      userAgent: ctx.userAgent,
      timestamp: new Date(),
      success: true,
      serviceId: "auth-service",
      requestId: ctx.requestId,
    });

    return {
      success: true,
      message:
        "If an account exists with this email, a verification link has been sent.",
    };
  }
}


--------------------------------------------------------------------------------
File: src\application\use-cases\reset-password.use-case.ts
--------------------------------------------------------------------------------

import type { IUserRepository } from "@domain/repositories/user.repository";
import type { ISessionRepository } from "@domain/repositories/session.repository";
import type { IAuthEventRepository } from "@domain/repositories/auth-event.repository";
import type { IRevocationStore } from "@app/interfaces/revocation.store";
import type { RequestContext } from "@app/dtos/auth.dto";
import { TokenError } from "@domain/errors/token.error";
import { ValidationError } from "@domain/errors/validation.error";
import { UserMethods } from "@domain/entities/user.entity";
import {
  hashPassword,
  validatePasswordComplexity,
} from "@infra/crypto/password.service";
import { sha256Hash } from "@infra/crypto/hash";

export interface ResetPasswordInput {
  token: string;

  newPassword: string;
}

export interface ResetPasswordOutput {
  success: true;
  message: string;
}

const USER_REVOCATION_TTL_SECONDS = 30 * 24 * 60 * 60;

export class ResetPasswordUseCase {
  constructor(
    private readonly userRepository: IUserRepository,
    private readonly sessionRepository: ISessionRepository,
    private readonly authEventRepository: IAuthEventRepository,
    private readonly revocationStore: IRevocationStore
  ) {}

  async execute(
    input: ResetPasswordInput,
    ctx: RequestContext
  ): Promise<ResetPasswordOutput> {
    const tokenHash = sha256Hash(input.token);

    const user =
      await this.userRepository.findByPasswordResetTokenHash(tokenHash);

    if (!user) {
      void this.authEventRepository.create({
        eventType: "PASSWORD_RESET_FAILED",
        ipAddress: ctx.ipAddress,
        userAgent: ctx.userAgent,
        timestamp: new Date(),
        success: false,
        failureReason: "token_not_found",
        serviceId: "auth-service",
        requestId: ctx.requestId,
      });

      throw new TokenError(
        "invalid_signature",
        "Invalid or expired password reset link"
      );
    }

    if (
      user.passwordResetTokenExpiry &&
      user.passwordResetTokenExpiry < new Date()
    ) {
      await this.userRepository.clearPasswordResetToken(user.id);

      void this.authEventRepository.create({
        eventType: "PASSWORD_RESET_FAILED",
        userId: user.id,
        email: user.email,
        ipAddress: ctx.ipAddress,
        userAgent: ctx.userAgent,
        timestamp: new Date(),
        success: false,
        failureReason: "token_expired",
        serviceId: "auth-service",
        requestId: ctx.requestId,
      });

      throw new TokenError(
        "expired",
        "Password reset link has expired. Please request a new one."
      );
    }

    const passwordIssue = validatePasswordComplexity(input.newPassword);
    if (passwordIssue) {
      throw new ValidationError(passwordIssue);
    }

    const newHashedPassword = await hashPassword(input.newPassword);

    const newTokenVersion = UserMethods.incrementTokenVersion(user);
    await this.userRepository.updatePassword(
      user.id,
      newHashedPassword,
      newTokenVersion
    );

    await this.userRepository.clearPasswordResetToken(user.id);

    await this.revocationStore.revokeAllUserSessions(
      user.id,
      USER_REVOCATION_TTL_SECONDS
    );

    const deletedSessions = await this.sessionRepository.deleteAllForUser(
      user.id
    );

    void this.authEventRepository.create({
      eventType: "PASSWORD_RESET_COMPLETED",
      userId: user.id,
      email: user.email,
      ipAddress: ctx.ipAddress,
      userAgent: ctx.userAgent,
      timestamp: new Date(),
      success: true,
      metadata: {
        sessionsRevoked: deletedSessions,
        newTokenVersion,
      },
      serviceId: "auth-service",
      requestId: ctx.requestId,
    });

    return {
      success: true,
      message:
        "Password has been reset successfully. Please sign in with your new password.",
    };
  }
}


--------------------------------------------------------------------------------
File: src\application\use-cases\signin.use-case.ts
--------------------------------------------------------------------------------

import { v4 as uuidv4 } from "uuid";
import type { IUserRepository } from "@domain/repositories/user.repository";
import type { ISessionRepository } from "@domain/repositories/session.repository";
import type { IAuthEventRepository } from "@domain/repositories/auth-event.repository";
import type { ITokenService } from "@app/interfaces/token.service";
import type { IEmailProvider } from "@app/interfaces/email.provider";
import type {
  SigninInput,
  SigninOutput,
  RequestContext,
} from "@app/dtos/auth.dto";
import { AuthenticationError } from "@domain/errors/authentication.error";
import { ValidationError } from "@domain/errors/validation.error";
import { UserMethods } from "@domain/entities/user.entity";
import { verifyPassword, hashPassword } from "@infra/crypto/password.service";
import { sha256Hash } from "@infra/crypto/hash";
import {
  generateOtp,
  encryptOtp,
  OTP_EXPIRY_MS,
} from "@infra/crypto/otp.service";
import { checkOtpRateLimit } from "@infra/redis/otp-rate-limiter";

const DEFAULT_SESSION_TTL_SECONDS = 7 * 24 * 60 * 60;

const REMEMBER_ME_SESSION_TTL_SECONDS = 30 * 24 * 60 * 60;

export class SigninUseCase {
  constructor(
    private readonly userRepository: IUserRepository,
    private readonly sessionRepository: ISessionRepository,
    private readonly authEventRepository: IAuthEventRepository,
    private readonly tokenService: ITokenService,
    private readonly emailProvider: IEmailProvider
  ) {}

  async execute(
    input: SigninInput,
    ctx: RequestContext
  ): Promise<SigninOutput> {
    const email = input.email.toLowerCase().trim();

    const user = await this.userRepository.findByEmail(email);

    if (!user) {
      void this.authEventRepository.create({
        eventType: "SIGNIN_FAILED",
        email,
        ipAddress: ctx.ipAddress,
        userAgent: ctx.userAgent,
        timestamp: new Date(),
        success: false,
        failureReason: "user_not_found",
        serviceId: "auth-service",
        requestId: ctx.requestId,
      });
      throw new AuthenticationError("Invalid credentials");
    }

    if (!user.isVerified) {
      void this.authEventRepository.create({
        eventType: "SIGNIN_FAILED",
        userId: user.id,
        email,
        ipAddress: ctx.ipAddress,
        userAgent: ctx.userAgent,
        timestamp: new Date(),
        success: false,
        failureReason: "email_not_verified",
        serviceId: "auth-service",
        requestId: ctx.requestId,
      });
      throw new ValidationError(
        "Please verify your email address before signing in"
      );
    }

    const { valid, needsRehash } = await verifyPassword(
      input.password,
      user.hashedPassword
    );

    if (!valid) {
      void this.authEventRepository.create({
        eventType: "SIGNIN_FAILED",
        userId: user.id,
        email,
        ipAddress: ctx.ipAddress,
        userAgent: ctx.userAgent,
        timestamp: new Date(),
        success: false,
        failureReason: "invalid_password",
        serviceId: "auth-service",
        requestId: ctx.requestId,
      });
      throw new AuthenticationError("Invalid credentials");
    }

    if (needsRehash) {
      hashPassword(input.password)
        .then((newHash) => this.userRepository.updatePassword(user.id, newHash))
        .catch((error: unknown) => {
          console.error(
            `[SigninUseCase] Failed to migrate password hash for ${user.id}:`,
            error instanceof Error ? error.message : "Unknown error"
          );
        });
    }

    if (UserMethods.isAdmin(user)) {
      return this.handleAdminSignin(user, ctx);
    }

    return this.handleStandardSignin(user, input.rememberMe ?? false, ctx);
  }

  private async handleAdminSignin(
    user: {
      id: string;
      email: string;
      role: "admin" | "user";
      tier: "free" | "pro";
    },
    ctx: RequestContext
  ): Promise<SigninOutput> {
    const otpLimit = await checkOtpRateLimit(user.id);
    if (!otpLimit.allowed) {
      void this.authEventRepository.create({
        eventType: "OTP_SENT",
        userId: user.id,
        email: user.email,
        ipAddress: ctx.ipAddress,
        userAgent: ctx.userAgent,
        timestamp: new Date(),
        success: false,
        failureReason: `otp_rate_limited:${otpLimit.retryAfterSeconds}s`,
        serviceId: "auth-service",
        requestId: ctx.requestId,
      });
      throw new AuthenticationError(
        `Too many OTP requests. Please try again in ${otpLimit.retryAfterSeconds} seconds.`
      );
    }

    const plainOtp = generateOtp();
    const encryptedOtp = encryptOtp(plainOtp);
    const otpExpiry = new Date(Date.now() + OTP_EXPIRY_MS);

    await this.userRepository.updateOtp(user.id, {
      otpSecret: encryptedOtp,
      otpExpiry,
      otpAttempts: 0,
    });

    this.emailProvider
      .sendOtpEmail(user.email, plainOtp)
      .catch((error: unknown) => {
        console.error(
          `[SigninUseCase] Failed to send OTP email to ${user.email}:`,
          error instanceof Error ? error.message : "Unknown error"
        );
      });

    void this.authEventRepository.create({
      eventType: "OTP_SENT",
      userId: user.id,
      email: user.email,
      ipAddress: ctx.ipAddress,
      userAgent: ctx.userAgent,
      timestamp: new Date(),
      success: true,
      serviceId: "auth-service",
      requestId: ctx.requestId,
    });

    return {
      isAuthenticated: false,
      requiresOtp: true,
      otpSent: true,
      message: "Verification code sent to your email",
    };
  }

  private async handleStandardSignin(
    user: {
      id: string;
      email: string;
      role: "admin" | "user";
      tier: "free" | "pro";
      tokenVersion: number;
    },
    rememberMe: boolean,
    ctx: RequestContext
  ): Promise<SigninOutput> {
    const sessionId = uuidv4();
    const ttlSeconds = rememberMe
      ? REMEMBER_ME_SESSION_TTL_SECONDS
      : DEFAULT_SESSION_TTL_SECONDS;

    const [accessResult, refreshResult] = await Promise.all([
      this.tokenService.generateAccessToken({
        userId: user.id,
        email: user.email,
        role: user.role,
        sessionId,
        tokenVersion: user.tokenVersion,
      }),
      this.tokenService.generateRefreshToken({
        userId: user.id,
        sessionId,
        tokenVersion: user.tokenVersion,
        ttlSeconds,
      }),
    ]);

    const refreshTokenHash = sha256Hash(refreshResult.token);

    await this.sessionRepository.create({
      sessionId,
      userId: user.id,
      refreshTokenHash,
      ipAddress: ctx.ipAddress,
      userAgent: ctx.userAgent,
      expiresAt: new Date(Date.now() + ttlSeconds * 1000),
      lastUsedAt: new Date(),
    });

    void this.authEventRepository.create({
      eventType: "SIGNIN",
      userId: user.id,
      email: user.email,
      sessionId,
      ipAddress: ctx.ipAddress,
      userAgent: ctx.userAgent,
      timestamp: new Date(),
      success: true,
      metadata: { rememberMe },
      serviceId: "auth-service",
      requestId: ctx.requestId,
    });

    return {
      isAuthenticated: true,
      requiresOtp: false,
      user: {
        id: user.id,
        email: user.email,
        role: user.role,
        tier: user.tier,
      },
      accessToken: accessResult.token,
      refreshToken: refreshResult.token,
    };
  }
}


--------------------------------------------------------------------------------
File: src\application\use-cases\signup.use-case.ts
--------------------------------------------------------------------------------

import type { IUserRepository } from "@domain/repositories/user.repository";
import type { IAuthEventRepository } from "@domain/repositories/auth-event.repository";
import type { IEmailProvider } from "@app/interfaces/email.provider";
import type {
  SignupInput,
  SignupOutput,
  RequestContext,
} from "@app/dtos/auth.dto";
import { ValidationError } from "@domain/errors/validation.error";
import { ConflictError } from "@domain/errors/conflict.error";
import {
  hashPassword,
  validatePasswordComplexity,
} from "@infra/crypto/password.service";
import { generateRandomToken, sha256Hash } from "@infra/crypto/hash";
import { encryptOtp } from "@infra/crypto/otp.service";

export class SignupUseCase {
  constructor(
    private readonly userRepository: IUserRepository,
    private readonly authEventRepository: IAuthEventRepository,
    private readonly emailProvider: IEmailProvider
  ) {}

  async execute(
    input: SignupInput,
    ctx: RequestContext
  ): Promise<SignupOutput> {
    const passwordIssue = validatePasswordComplexity(input.password);
    if (passwordIssue) {
      throw new ValidationError(passwordIssue);
    }

    const existing = await this.userRepository.findByEmail(
      input.email.toLowerCase().trim()
    );
    if (existing) {
      throw new ConflictError("An account with this email already exists");
    }

    const hashedPassword = await hashPassword(input.password);

    const rawVerificationToken = generateRandomToken(32);
    const verificationTokenHash = sha256Hash(rawVerificationToken);
    const verificationTokenExpiry = new Date(Date.now() + 60 * 60 * 1000);

    const encryptedVerificationToken = encryptOtp(rawVerificationToken);

    const user = await this.userRepository.create({
      email: input.email.toLowerCase().trim(),
      hashedPassword,
      role: "user",
      isVerified: false,
      tokenVersion: 0,
      tier: "free",
      verificationToken: encryptedVerificationToken,
      verificationTokenHash,
      verificationTokenExpiry,
    });

    this.emailProvider
      .sendVerificationEmail(user.email, rawVerificationToken)
      .catch((error: unknown) => {
        console.error(
          `[SignupUseCase] Failed to send verification email to ${user.email}:`,
          error instanceof Error ? error.message : "Unknown error"
        );
      });

    void this.authEventRepository.create({
      eventType: "SIGNUP",
      userId: user.id,
      email: user.email,
      ipAddress: ctx.ipAddress,
      userAgent: ctx.userAgent,
      timestamp: new Date(),
      success: true,
      serviceId: "auth-service",
      requestId: ctx.requestId,
    });

    return {
      success: true,
      message:
        "Account created. Please check your email to verify your address.",
    };
  }
}


--------------------------------------------------------------------------------
File: src\application\use-cases\verify-email.use-case.ts
--------------------------------------------------------------------------------

import type { IUserRepository } from "@domain/repositories/user.repository";
import type { IAuthEventRepository } from "@domain/repositories/auth-event.repository";
import type { RequestContext } from "@app/dtos/auth.dto";
import { TokenError } from "@domain/errors/token.error";
import { sha256Hash } from "@infra/crypto/hash";

export interface VerifyEmailInput {
  token: string;
}

export interface VerifyEmailOutput {
  success: true;
  message: string;
}

export class VerifyEmailUseCase {
  constructor(
    private readonly userRepository: IUserRepository,
    private readonly authEventRepository: IAuthEventRepository
  ) {}

  async execute(
    input: VerifyEmailInput,
    ctx: RequestContext
  ): Promise<VerifyEmailOutput> {
    const tokenHash = sha256Hash(input.token);

    const user =
      await this.userRepository.findByVerificationTokenHash(tokenHash);

    if (!user) {
      void this.authEventRepository.create({
        eventType: "EMAIL_VERIFICATION_FAILED",
        ipAddress: ctx.ipAddress,
        userAgent: ctx.userAgent,
        timestamp: new Date(),
        success: false,
        failureReason: "token_not_found",
        serviceId: "auth-service",
        requestId: ctx.requestId,
      });

      throw new TokenError(
        "invalid_signature",
        "Invalid or expired verification link"
      );
    }

    if (
      user.verificationTokenExpiry &&
      user.verificationTokenExpiry < new Date()
    ) {
      await this.userRepository.updateVerification(user.id, {
        isVerified: false,
        verificationToken: null,
        verificationTokenHash: null,
        verificationTokenExpiry: null,
      });

      void this.authEventRepository.create({
        eventType: "EMAIL_VERIFICATION_FAILED",
        userId: user.id,
        email: user.email,
        ipAddress: ctx.ipAddress,
        userAgent: ctx.userAgent,
        timestamp: new Date(),
        success: false,
        failureReason: "token_expired",
        serviceId: "auth-service",
        requestId: ctx.requestId,
      });

      throw new TokenError(
        "expired",
        "Verification link has expired. Please request a new one."
      );
    }

    await this.userRepository.updateVerification(user.id, {
      isVerified: true,
      verificationToken: null,
      verificationTokenHash: null,
      verificationTokenExpiry: null,
    });

    void this.authEventRepository.create({
      eventType: "EMAIL_VERIFIED",
      userId: user.id,
      email: user.email,
      ipAddress: ctx.ipAddress,
      userAgent: ctx.userAgent,
      timestamp: new Date(),
      success: true,
      serviceId: "auth-service",
      requestId: ctx.requestId,
    });

    return {
      success: true,
      message: "Email verified successfully. You can now sign in.",
    };
  }
}


--------------------------------------------------------------------------------
File: src\application\use-cases\verify-otp.use-case.ts
--------------------------------------------------------------------------------

import { v4 as uuidv4 } from "uuid";
import type { IUserRepository } from "@domain/repositories/user.repository";
import type { ISessionRepository } from "@domain/repositories/session.repository";
import type { IAuthEventRepository } from "@domain/repositories/auth-event.repository";
import type { ITokenService } from "@app/interfaces/token.service";
import type {
  VerifyOtpInput,
  VerifyOtpOutput,
  RequestContext,
} from "@app/dtos/auth.dto";
import { AuthenticationError } from "@domain/errors/authentication.error";
import { UserMethods } from "@domain/entities/user.entity";
import { verifyOtp } from "@infra/crypto/otp.service";
import { sha256Hash } from "@infra/crypto/hash";
import { resetOtpRateLimit } from "@infra/redis/otp-rate-limiter";

const ADMIN_SESSION_TTL_SECONDS = 7 * 24 * 60 * 60;

export class VerifyOtpUseCase {
  constructor(
    private readonly userRepository: IUserRepository,
    private readonly sessionRepository: ISessionRepository,
    private readonly authEventRepository: IAuthEventRepository,
    private readonly tokenService: ITokenService
  ) {}

  async execute(
    input: VerifyOtpInput,
    ctx: RequestContext
  ): Promise<VerifyOtpOutput> {
    const email = input.email.toLowerCase().trim();

    const user = await this.userRepository.findByEmail(email);
    if (!user) {
      throw new AuthenticationError("Invalid credentials");
    }

    const precondition = UserMethods.validateOtpAttempt(user);

    switch (precondition.status) {
      case "noOtp":
        throw new AuthenticationError(
          "No verification code found. Please sign in again."
        );

      case "expired":
        await this.userRepository.clearOtp(user.id);
        void this.authEventRepository.create({
          eventType: "OTP_FAILED",
          userId: user.id,
          email,
          ipAddress: ctx.ipAddress,
          userAgent: ctx.userAgent,
          timestamp: new Date(),
          success: false,
          failureReason: "otp_expired",
          serviceId: "auth-service",
          requestId: ctx.requestId,
        });
        throw new AuthenticationError(
          "Verification code has expired. Please sign in again."
        );

      case "maxAttempts":
        await this.userRepository.clearOtp(user.id);
        void this.authEventRepository.create({
          eventType: "OTP_FAILED",
          userId: user.id,
          email,
          ipAddress: ctx.ipAddress,
          userAgent: ctx.userAgent,
          timestamp: new Date(),
          success: false,
          failureReason: "otp_max_attempts",
          serviceId: "auth-service",
          requestId: ctx.requestId,
        });
        throw new AuthenticationError(
          "Too many failed attempts. Please sign in again to receive a new code."
        );

      case "valid":
        break;
    }

    const otpMatches = verifyOtp(input.otp, user.otpSecret!);

    if (!otpMatches) {
      await this.userRepository.updateOtp(user.id, {
        otpSecret: user.otpSecret!,
        otpExpiry: user.otpExpiry!,
        otpAttempts: (user.otpAttempts ?? 0) + 1,
      });

      void this.authEventRepository.create({
        eventType: "OTP_FAILED",
        userId: user.id,
        email,
        ipAddress: ctx.ipAddress,
        userAgent: ctx.userAgent,
        timestamp: new Date(),
        success: false,
        failureReason: "otp_mismatch",
        metadata: { attempt: (user.otpAttempts ?? 0) + 1 },
        serviceId: "auth-service",
        requestId: ctx.requestId,
      });

      const remainingAttempts = 5 - ((user.otpAttempts ?? 0) + 1);
      throw new AuthenticationError(
        `Invalid verification code. ${remainingAttempts} attempt${remainingAttempts !== 1 ? "s" : ""} remaining.`
      );
    }

    await this.userRepository.clearOtp(user.id);

    await resetOtpRateLimit(user.id);

    const sessionId = uuidv4();

    const [accessResult, refreshResult] = await Promise.all([
      this.tokenService.generateAccessToken({
        userId: user.id,
        email: user.email,
        role: user.role,
        sessionId,
        tokenVersion: user.tokenVersion,
      }),
      this.tokenService.generateRefreshToken({
        userId: user.id,
        sessionId,
        tokenVersion: user.tokenVersion,
        ttlSeconds: ADMIN_SESSION_TTL_SECONDS,
      }),
    ]);

    const refreshTokenHash = sha256Hash(refreshResult.token);

    await this.sessionRepository.create({
      sessionId,
      userId: user.id,
      refreshTokenHash,
      ipAddress: ctx.ipAddress,
      userAgent: ctx.userAgent,
      expiresAt: new Date(Date.now() + ADMIN_SESSION_TTL_SECONDS * 1000),
      lastUsedAt: new Date(),
    });

    void this.authEventRepository.create({
      eventType: "OTP_VERIFIED",
      userId: user.id,
      email,
      sessionId,
      ipAddress: ctx.ipAddress,
      userAgent: ctx.userAgent,
      timestamp: new Date(),
      success: true,
      serviceId: "auth-service",
      requestId: ctx.requestId,
    });

    return {
      isAuthenticated: true,
      user: {
        id: user.id,
        email: user.email,
        role: user.role,
        tier: user.tier,
      },
      accessToken: accessResult.token,
      refreshToken: refreshResult.token,
    };
  }
}


--------------------------------------------------------------------------------
File: src\domain\entities\auth-event.entity.ts
--------------------------------------------------------------------------------

export type AuthEventType =
  | "SIGNUP"
  | "SIGNIN"
  | "SIGNIN_FAILED"
  | "OTP_SENT"
  | "OTP_VERIFIED"
  | "OTP_FAILED"
  | "TOKEN_REFRESH"
  | "TOKEN_REFRESH_FAILED"
  | "LOGOUT"
  | "GLOBAL_LOGOUT"
  | "EMAIL_VERIFIED"
  | "EMAIL_VERIFICATION_FAILED"
  | "PASSWORD_RESET_REQUESTED"
  | "PASSWORD_RESET_COMPLETED"
  | "PASSWORD_RESET_FAILED"
  | "VERIFICATION_RESENT"
  | "CONTACT_FORM_SUBMITTED"
  | "RATE_LIMITED"
  | "TOKEN_REVOKED"
  | "SESSION_REVOKED"
  | "SUSPICIOUS_ACTIVITY";

export interface AuthEventEntity {
  readonly id: string;

  eventType: AuthEventType;

  userId?: string;

  email?: string;

  sessionId?: string;

  ipAddress?: string;

  userAgent?: string;

  timestamp: Date;

  success: boolean;

  failureReason?: string;

  metadata?: Record<string, unknown>;

  serviceId: string;

  requestId: string;
}


--------------------------------------------------------------------------------
File: src\domain\entities\session.entity.ts
--------------------------------------------------------------------------------

export interface SessionEntity {
  readonly id: string;

  sessionId: string;

  userId: string;

  refreshTokenHash: string;

  ipAddress?: string;

  userAgent?: string;

  expiresAt: Date;

  readonly createdAt: Date;

  lastUsedAt: Date;
}

export const SessionMethods = {
  isExpired(session: SessionEntity): boolean {
    return session.expiresAt < new Date();
  },

  getUpdatedLastUsed(): Date {
    return new Date();
  },
} as const;


--------------------------------------------------------------------------------
File: src\domain\entities\user.entity.ts
--------------------------------------------------------------------------------

export type UserRole = "admin" | "user";

export type UserTier = "free" | "pro";

export interface UserEntity {
  readonly id: string;

  email: string;

  hashedPassword: string;

  role: UserRole;

  isVerified: boolean;

  tokenVersion: number;

  tier: UserTier;

  verificationToken?: string;

  verificationTokenHash?: string;

  verificationTokenExpiry?: Date;

  passwordResetToken?: string;

  passwordResetTokenHash?: string;

  passwordResetTokenExpiry?: Date;

  otpSecret?: string;

  otpExpiry?: Date;

  otpAttempts?: number;

  readonly createdAt: Date;
  updatedAt: Date;
}

export const UserMethods = {
  incrementTokenVersion(user: UserEntity): number {
    return user.tokenVersion + 1;
  },

  isAdmin(user: UserEntity): boolean {
    return user.role === "admin";
  },

  canRequestOtp(user: UserEntity): boolean {
    if (user.role !== "admin") return false;
    if (user.otpExpiry && user.otpExpiry > new Date()) return false;
    return true;
  },

  validateOtpAttempt(user: UserEntity): {
    status: "valid" | "expired" | "maxAttempts" | "invalid" | "noOtp";
  } {
    if (!user.otpSecret || !user.otpExpiry) {
      return { status: "noOtp" };
    }

    if (user.otpExpiry < new Date()) {
      return { status: "expired" };
    }

    if ((user.otpAttempts ?? 0) >= 5) {
      return { status: "maxAttempts" };
    }

    return { status: "valid" };
  },
} as const;


--------------------------------------------------------------------------------
File: src\domain\errors\authentication.error.ts
--------------------------------------------------------------------------------

import { DomainError } from "./base.error";

export class AuthenticationError extends DomainError {
  readonly code = "AUTHENTICATION_ERROR" as const;
  readonly statusCode = 401;

  constructor(message: string = "Invalid credentials") {
    super(message);
  }
}


--------------------------------------------------------------------------------
File: src\domain\errors\authorization.error.ts
--------------------------------------------------------------------------------

import { DomainError } from "./base.error";

export class AuthorizationError extends DomainError {
  readonly code = "AUTHORIZATION_ERROR" as const;
  readonly statusCode = 403;

  constructor(message: string = "Insufficient permissions") {
    super(message);
  }
}


--------------------------------------------------------------------------------
File: src\domain\errors\base.error.ts
--------------------------------------------------------------------------------

export abstract class DomainError extends Error {
  abstract readonly code: string;

  abstract readonly statusCode: number;

  constructor(message: string) {
    super(message);
    this.name = this.constructor.name;

    Object.setPrototypeOf(this, new.target.prototype);
  }

  toJSON(): { code: string; message: string } {
    return {
      code: this.code,
      message: this.message,
    };
  }
}


--------------------------------------------------------------------------------
File: src\domain\errors\conflict.error.ts
--------------------------------------------------------------------------------

import { DomainError } from "./base.error";

export class ConflictError extends DomainError {
  readonly code = "CONFLICT_ERROR" as const;
  readonly statusCode = 409;

  constructor(message: string = "Resource already exists") {
    super(message);
  }
}


--------------------------------------------------------------------------------
File: src\domain\errors\not-found.error.ts
--------------------------------------------------------------------------------

import { DomainError } from "./base.error";

export class NotFoundError extends DomainError {
  readonly code = "NOT_FOUND_ERROR" as const;
  readonly statusCode = 404;

  constructor(message: string = "Resource not found") {
    super(message);
  }
}


--------------------------------------------------------------------------------
File: src\domain\errors\rate-limit.error.ts
--------------------------------------------------------------------------------

import { DomainError } from "./base.error";

export class RateLimitError extends DomainError {
  readonly code = "RATE_LIMIT_ERROR" as const;
  readonly statusCode = 429;

  readonly retryAfter: number;

  constructor(retryAfter: number = 60) {
    super("Too many requests. Please try again later.");
    this.retryAfter = retryAfter;
  }
}


--------------------------------------------------------------------------------
File: src\domain\errors\token.error.ts
--------------------------------------------------------------------------------

import { DomainError } from "./base.error";

export type TokenErrorReason =
  | "expired"
  | "revoked"
  | "invalid_signature"
  | "invalid_format"
  | "missing"
  | "version_mismatch"
  | "user_not_found"
  | "user_not_verified"
  | "role_drift";

export class TokenError extends DomainError {
  readonly code = "TOKEN_ERROR" as const;
  readonly statusCode = 401;

  readonly reason: TokenErrorReason;

  constructor(
    reason: TokenErrorReason,
    message: string = "Invalid or expired token"
  ) {
    super(message);
    this.reason = reason;
  }
}


--------------------------------------------------------------------------------
File: src\domain\errors\validation.error.ts
--------------------------------------------------------------------------------

import { DomainError } from "./base.error";

export class ValidationError extends DomainError {
  readonly code = "VALIDATION_ERROR" as const;
  readonly statusCode = 400;

  readonly fields?: Record<string, string>;

  constructor(message: string, fields?: Record<string, string>) {
    super(message);
    this.fields = fields;
  }

  override toJSON(): {
    code: string;
    message: string;
    fields?: Record<string, string>;
  } {
    return {
      ...super.toJSON(),
      ...(this.fields && { fields: this.fields }),
    };
  }
}


--------------------------------------------------------------------------------
File: src\domain\index.ts
--------------------------------------------------------------------------------

export type { UserEntity, UserRole, UserTier } from "./entities/user.entity";
export { UserMethods } from "./entities/user.entity";
export type { SessionEntity } from "./entities/session.entity";
export { SessionMethods } from "./entities/session.entity";
export type {
  AuthEventEntity,
  AuthEventType,
} from "./entities/auth-event.entity";

export { Email } from "./value-objects/email.vo";
export { HashedPassword } from "./value-objects/hashed-password.vo";
export { TokenVersion } from "./value-objects/token-version.vo";
export { SessionId } from "./value-objects/session-id.vo";
export { JTI } from "./value-objects/jti.vo";

export { DomainError } from "./errors/base.error";
export { AuthenticationError } from "./errors/authentication.error";
export { AuthorizationError } from "./errors/authorization.error";
export { ValidationError } from "./errors/validation.error";
export { ConflictError } from "./errors/conflict.error";
export { NotFoundError } from "./errors/not-found.error";
export { RateLimitError } from "./errors/rate-limit.error";
export { TokenError } from "./errors/token.error";
export type { TokenErrorReason } from "./errors/token.error";

export type { IUserRepository } from "./repositories/user.repository";
export type { ISessionRepository } from "./repositories/session.repository";
export type { IAuthEventRepository } from "./repositories/auth-event.repository";


--------------------------------------------------------------------------------
File: src\domain\repositories\auth-event.repository.ts
--------------------------------------------------------------------------------

import type {
  AuthEventEntity,
  AuthEventType,
} from "@domain/entities/auth-event.entity";

/**
 * Port: Audit event data access.
 * Implemented by infrastructure/database/auth-event.repository.impl.ts
 *
 * IMPORTANT: The `create` method is always called fire-and-forget.
 * Audit logging failures MUST NOT block or fail auth operations.
 */
export interface IAuthEventRepository {
  create(event: Omit<AuthEventEntity, "id">): Promise<void>;

  findByUserId(
    userId: string,
    options?: { limit?: number; offset?: number; eventType?: AuthEventType }
  ): Promise<AuthEventEntity[]>;

  findByIp(
    ipAddress: string,
    options?: { limit?: number; since?: Date }
  ): Promise<AuthEventEntity[]>;
}


--------------------------------------------------------------------------------
File: src\domain\repositories\session.repository.ts
--------------------------------------------------------------------------------

import type { SessionEntity } from "@domain/entities/session.entity";

export interface ISessionRepository {
  create(
    session: Omit<SessionEntity, "id" | "createdAt">
  ): Promise<SessionEntity>;

  findByRefreshTokenHash(hash: string): Promise<SessionEntity | null>;

  findBySessionId(sessionId: string): Promise<SessionEntity | null>;

  findByUserId(userId: string): Promise<SessionEntity[]>;

  delete(sessionId: string): Promise<boolean>;

  deleteAllForUser(userId: string): Promise<number>;

  findAndDeleteByRefreshTokenHash(hash: string): Promise<SessionEntity | null>;

  updateLastUsed(sessionId: string, lastUsedAt: Date): Promise<void>;

  deleteExpiredSessions(): Promise<number>;
}


--------------------------------------------------------------------------------
File: src\domain\repositories\user.repository.ts
--------------------------------------------------------------------------------

import type { UserEntity } from "@domain/entities/user.entity";

export interface IUserRepository {
  findByEmail(email: string): Promise<UserEntity | null>;

  findById(id: string): Promise<UserEntity | null>;

  create(
    user: Omit<UserEntity, "id" | "createdAt" | "updatedAt">
  ): Promise<UserEntity>;

  updatePassword(
    userId: string,
    hashedPassword: string,
    tokenVersion?: number
  ): Promise<void>;

  updateTokenVersion(userId: string, tokenVersion: number): Promise<void>;

  updateVerification(
    userId: string,
    update: {
      isVerified: boolean;
      verificationToken?: string | null;
      verificationTokenHash?: string | null;
      verificationTokenExpiry?: Date | null;
    }
  ): Promise<void>;

  updateOtp(
    userId: string,
    update: {
      otpSecret: string;
      otpExpiry: Date;
      otpAttempts: number;
    }
  ): Promise<void>;

  clearOtp(userId: string): Promise<void>;

  findByVerificationTokenHash(hash: string): Promise<UserEntity | null>;

  findByPasswordResetTokenHash(hash: string): Promise<UserEntity | null>;

  updatePasswordResetToken(
    userId: string,
    update: {
      passwordResetToken: string;
      passwordResetTokenHash: string;
      passwordResetTokenExpiry: Date;
    }
  ): Promise<void>;

  clearPasswordResetToken(userId: string): Promise<void>;

  updateVerificationToken(
    userId: string,
    update: {
      verificationToken: string;
      verificationTokenHash: string;
      verificationTokenExpiry: Date;
    }
  ): Promise<void>;

  incrementOtpAttempts(userId: string): Promise<void>;
}


--------------------------------------------------------------------------------
File: src\domain\value-objects\email.vo.ts
--------------------------------------------------------------------------------

import { ValidationError } from "@domain/errors/validation.error";

export class Email {
  private static readonly EMAIL_REGEX =
    /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;

  private static readonly MAX_LENGTH = 254; // RFC 5321

  readonly value: string;

  private constructor(email: string) {
    this.value = email;
  }

  /**
   * Creates a validated, normalized Email.
   * @throws ValidationError if the email is invalid.
   */
  static create(raw: string): Email {
    const trimmed = raw.trim().toLowerCase();

    if (trimmed.length === 0) {
      throw new ValidationError("Email is required");
    }

    if (trimmed.length > Email.MAX_LENGTH) {
      throw new ValidationError(
        `Email must not exceed ${Email.MAX_LENGTH} characters`
      );
    }

    if (!Email.EMAIL_REGEX.test(trimmed)) {
      throw new ValidationError("Invalid email format");
    }

    return new Email(trimmed);
  }

  /**
   * Creates an Email from an already-validated string (e.g., from database).
   * Skips validation. Use only when the source is trusted.
   */
  static fromTrusted(email: string): Email {
    return new Email(email);
  }

  equals(other: Email): boolean {
    return this.value === other.value;
  }

  toString(): string {
    return this.value;
  }
}


--------------------------------------------------------------------------------
File: src\domain\value-objects\hashed-password.vo.ts
--------------------------------------------------------------------------------

import { ValidationError } from "@domain/errors/validation.error";

export class HashedPassword {
  private static readonly BCRYPT_PREFIX = "$2b$";
  private static readonly BCRYPT_MIN_LENGTH = 59;

  readonly value: string;

  private constructor(hash: string) {
    this.value = hash;
  }

  static create(hash: string): HashedPassword {
    if (!hash || hash.length < 10) {
      throw new ValidationError("Invalid password hash");
    }

    const isBcrypt =
      hash.startsWith(HashedPassword.BCRYPT_PREFIX) &&
      hash.length >= HashedPassword.BCRYPT_MIN_LENGTH;

    const isLegacyPbkdf2 = hash.includes(":");

    if (!isBcrypt && !isLegacyPbkdf2) {
      throw new ValidationError(
        "Password hash must be bcrypt or PBKDF2 format"
      );
    }

    return new HashedPassword(hash);
  }

  isLegacy(): boolean {
    return !this.value.startsWith(HashedPassword.BCRYPT_PREFIX);
  }

  toString(): string {
    return "[REDACTED]";
  }
}


--------------------------------------------------------------------------------
File: src\domain\value-objects\jti.vo.ts
--------------------------------------------------------------------------------

import { ValidationError } from "@domain/errors/validation.error";

export class JTI {
  private static readonly HEX_128_REGEX = /^[0-9a-f]{32}$/;

  readonly value: string;

  private constructor(jti: string) {
    this.value = jti;
  }

  static create(jti: string): JTI {
    const lower = jti.toLowerCase();
    if (!JTI.HEX_128_REGEX.test(lower)) {
      throw new ValidationError("JTI must be a 32-character hex string");
    }
    return new JTI(lower);
  }

  static fromTrusted(jti: string): JTI {
    return new JTI(jti.toLowerCase());
  }

  equals(other: JTI): boolean {
    return this.value === other.value;
  }

  toString(): string {
    return this.value;
  }
}


--------------------------------------------------------------------------------
File: src\domain\value-objects\session-id.vo.ts
--------------------------------------------------------------------------------

import { ValidationError } from "@domain/errors/validation.error";

export class SessionId {
  private static readonly UUID_V4_REGEX =
    /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;

  readonly value: string;

  private constructor(id: string) {
    this.value = id;
  }

  static create(id: string): SessionId {
    if (!SessionId.UUID_V4_REGEX.test(id)) {
      throw new ValidationError("Session ID must be a valid UUID v4");
    }
    return new SessionId(id);
  }

  static fromTrusted(id: string): SessionId {
    return new SessionId(id);
  }

  equals(other: SessionId): boolean {
    return this.value === other.value;
  }

  toString(): string {
    return this.value;
  }
}


--------------------------------------------------------------------------------
File: src\domain\value-objects\token-version.vo.ts
--------------------------------------------------------------------------------

import { ValidationError } from "@domain/errors/validation.error";

export class TokenVersion {
  readonly value: number;

  private constructor(version: number) {
    this.value = version;
  }

  static create(version: number): TokenVersion {
    if (!Number.isInteger(version) || version < 0) {
      throw new ValidationError("Token version must be a non-negative integer");
    }
    return new TokenVersion(version);
  }

  increment(): TokenVersion {
    return new TokenVersion(this.value + 1);
  }

  equals(other: TokenVersion): boolean {
    return this.value === other.value;
  }
}


--------------------------------------------------------------------------------
File: src\env.ts
--------------------------------------------------------------------------------

import { z } from "zod";

const envSchema = z.object({
  NODE_ENV: z
    .enum(["development", "production", "test"])
    .default("development"),

  NEXT_PUBLIC_SITE_URL: z.string().url().default("https://www.ankurhalder.com"),
  ALLOWED_ORIGINS: z
    .string()
    .transform((s) => s.split(",").map((o) => o.trim()))
    .default("https://www.ankurhalder.com,https://ankurhalder.com"),

  JWT_PRIVATE_KEY: z
    .string()
    .min(100, "JWT_PRIVATE_KEY must be a PEM-encoded RSA private key"),
  JWT_PUBLIC_KEY: z
    .string()
    .min(100, "JWT_PUBLIC_KEY must be a PEM-encoded RSA public key"),
  JWT_KID: z.string().default("k1"),

  JWT_REFRESH_PRIVATE_KEY: z
    .string()
    .min(100, "JWT_REFRESH_PRIVATE_KEY must be a PEM-encoded RSA private key"),
  JWT_REFRESH_PUBLIC_KEY: z
    .string()
    .min(100, "JWT_REFRESH_PUBLIC_KEY must be a PEM-encoded RSA public key"),
  JWT_REFRESH_KID: z.string().default("r1"),

  JWT_PREVIOUS_KIDS: z
    .string()
    .transform((s) => (s ? s.split(",").map((k) => k.trim()) : []))
    .default(""),
  JWT_PREVIOUS_PUBLIC_KEYS: z
    .string()
    .transform((s) => (s ? s.split(",").map((k) => k.trim()) : []))
    .default(""),

  MONGODB_URI: z
    .string()
    .startsWith(
      "mongodb",
      "MONGODB_URI must be a valid MongoDB connection string"
    ),
  DB_NAME: z.string().default("portfolio"),

  UPSTASH_REDIS_REST_URL: z.string().url(),
  UPSTASH_REDIS_REST_TOKEN: z.string().min(1),

  BREVO_API_KEY: z.string().min(1, "BREVO_API_KEY is required"),
  ADMIN_EMAIL: z.string().email("ADMIN_EMAIL must be a valid email"),
  FROM_EMAIL: z.string().email("FROM_EMAIL must be a valid email"),

  ENCRYPTION_KEY: z
    .string()
    .length(64, "ENCRYPTION_KEY must be exactly 64 hex characters (32 bytes)"),

  CRON_SECRET: z.string().min(16, "CRON_SECRET must be at least 16 characters"),
});

function validateEnv(): z.infer<typeof envSchema> {
  const result = envSchema.safeParse(process.env);

  if (!result.success) {
    const formatted = result.error.issues
      .map((issue) => `  - ${issue.path.join(".")}: ${issue.message}`)
      .join("\n");

    console.error(`\n❌ Environment validation failed:\n${formatted}\n`);
    throw new Error("Invalid environment variables. See above for details.");
  }

  return result.data;
}

export const env = validateEnv();

export type Env = z.infer<typeof envSchema>;


--------------------------------------------------------------------------------
File: src\infrastructure\crypto\hash.ts
--------------------------------------------------------------------------------

import crypto from "node:crypto";

export function sha256Hash(raw: string): string {
  return crypto.createHash("sha256").update(raw).digest("hex");
}

export function generateRandomToken(bytes: number = 32): string {
  return crypto.randomBytes(bytes).toString("hex");
}


--------------------------------------------------------------------------------
File: src\infrastructure\crypto\jwks.ts
--------------------------------------------------------------------------------

import { exportJWK, type JWK } from "jose";
import { env } from "@/env";

export interface JsonWebKeySet {
  keys: JWK[];
}

export async function getJwksData(): Promise<JsonWebKeySet> {
  const [accessPublicKey, refreshPublicKey] = await Promise.all([
    crypto.subtle.importKey(
      "spki",
      Buffer.from(
        env.JWT_PUBLIC_KEY.replace(
          /-----BEGIN PUBLIC KEY-----|\n|-----END PUBLIC KEY-----/g,
          ""
        ),
        "base64"
      ),
      { name: "RSASSA-PKCS1-v1_5", hash: "SHA-256" },
      true,
      ["verify"]
    ),
    crypto.subtle.importKey(
      "spki",
      Buffer.from(
        env.JWT_REFRESH_PUBLIC_KEY.replace(
          /-----BEGIN PUBLIC KEY-----|\n|-----END PUBLIC KEY-----/g,
          ""
        ),
        "base64"
      ),
      { name: "RSASSA-PKCS1-v1_5", hash: "SHA-256" },
      true,
      ["verify"]
    ),
  ]);

  const [accessJwk, refreshJwk] = await Promise.all([
    exportJWK(accessPublicKey),
    exportJWK(refreshPublicKey),
  ]);

  return {
    keys: [
      {
        ...accessJwk,
        kid: "access-token-key",
        alg: "RS256",
        use: "sig",
      },
      {
        ...refreshJwk,
        kid: "refresh-token-key",
        alg: "RS256",
        use: "sig",
      },
    ],
  };
}


--------------------------------------------------------------------------------
File: src\infrastructure\crypto\jwt.service.ts
--------------------------------------------------------------------------------

import * as jose from "jose";
import crypto from "node:crypto";
import type {
  ITokenService,
  AccessTokenPayload,
  RefreshTokenPayload,
  GeneratedToken,
  JsonWebKeySet,
  JsonWebKey,
} from "@app/interfaces/token.service";
import { env } from "@/env";

const ALGORITHM = "RS256" as const;
const ACCESS_TOKEN_TTL_SECONDS = 15 * 60;

// eslint-disable-next-line @typescript-eslint/no-explicit-any
type CryptoKey = any;

interface KeySet {
  privateKey: CryptoKey;
  publicKey: CryptoKey;
  kid: string;
}

let accessKeySet: KeySet | null = null;
let refreshKeySet: KeySet | null = null;
let previousKeys: Array<{
  publicKey: CryptoKey;
  kid: string;
}> = [];
let previousKeysExpiry: number = 0;

async function getAccessKeySet(): Promise<KeySet> {
  if (accessKeySet) return accessKeySet;

  const privateKey = await jose.importPKCS8(
    env.JWT_PRIVATE_KEY.replace(/\\n/g, "\n"),
    ALGORITHM
  );
  const publicKey = await jose.importSPKI(
    env.JWT_PUBLIC_KEY.replace(/\\n/g, "\n"),
    ALGORITHM
  );

  accessKeySet = { privateKey, publicKey, kid: env.JWT_KID };
  return accessKeySet;
}

async function getRefreshKeySet(): Promise<KeySet> {
  if (refreshKeySet) return refreshKeySet;

  const privateKey = await jose.importPKCS8(
    env.JWT_REFRESH_PRIVATE_KEY.replace(/\\n/g, "\n"),
    ALGORITHM
  );
  const publicKey = await jose.importSPKI(
    env.JWT_REFRESH_PUBLIC_KEY.replace(/\\n/g, "\n"),
    ALGORITHM
  );

  refreshKeySet = { privateKey, publicKey, kid: env.JWT_REFRESH_KID };
  return refreshKeySet;
}

async function getPreviousKeys(): Promise<
  Array<{ publicKey: CryptoKey; kid: string }>
> {
  if (previousKeys.length > 0) return previousKeys;

  const kids = env.JWT_PREVIOUS_KIDS;
  const publicKeyPems = env.JWT_PREVIOUS_PUBLIC_KEYS;

  if (kids.length === 0 || publicKeyPems.length === 0) return [];
  if (kids.length !== publicKeyPems.length) {
    console.error(
      "[JWT] JWT_PREVIOUS_KIDS and JWT_PREVIOUS_PUBLIC_KEYS have different lengths"
    );
    return [];
  }

  previousKeys = await Promise.all(
    kids.map(async (kid, i) => {
      const pem = publicKeyPems[i]!;
      const publicKey = await jose.importSPKI(
        pem.replace(/\\n/g, "\n"),
        ALGORITHM
      );
      return { publicKey, kid };
    })
  );

  previousKeysExpiry = Date.now() + 30 * 24 * 60 * 60 * 1000;

  return previousKeys;
}

async function findPublicKeyByKid(
  kid: string,
  type: "access" | "refresh"
): Promise<CryptoKey | null> {
  const current =
    type === "access" ? await getAccessKeySet() : await getRefreshKeySet();
  if (current.kid === kid) {
    return current.publicKey;
  }

  if (Date.now() < previousKeysExpiry) {
    const prev = await getPreviousKeys();
    const match = prev.find((k) => k.kid === kid);
    if (match) return match.publicKey;
  }

  return null;
}

function generateJti(): string {
  return crypto.randomBytes(16).toString("hex");
}

export class JwtServiceImpl implements ITokenService {
  async generateAccessToken(payload: {
    userId: string;
    email: string;
    role: "admin" | "user";
    sessionId: string;
    tokenVersion: number;
  }): Promise<GeneratedToken> {
    const { privateKey, kid } = await getAccessKeySet();
    const jti = generateJti();

    const token = await new jose.SignJWT({
      email: payload.email,
      role: payload.role,
      sessionId: payload.sessionId,
      jti,
      tv: payload.tokenVersion,
    })
      .setProtectedHeader({ alg: ALGORITHM, kid })
      .setSubject(payload.userId)
      .setIssuedAt()
      .setExpirationTime(`${ACCESS_TOKEN_TTL_SECONDS}s`)
      .sign(privateKey);

    return { token, jti };
  }

  async generateRefreshToken(payload: {
    userId: string;
    sessionId: string;
    tokenVersion: number;
    ttlSeconds: number;
  }): Promise<GeneratedToken> {
    const { privateKey, kid } = await getRefreshKeySet();
    const jti = generateJti();

    const token = await new jose.SignJWT({
      sessionId: payload.sessionId,
      jti,
      tv: payload.tokenVersion,
    })
      .setProtectedHeader({ alg: ALGORITHM, kid })
      .setSubject(payload.userId)
      .setIssuedAt()
      .setExpirationTime(`${payload.ttlSeconds}s`)
      .sign(privateKey);

    return { token, jti };
  }

  async verifyAccessToken(token: string): Promise<AccessTokenPayload | null> {
    try {
      const header = jose.decodeProtectedHeader(token);
      if (!header.kid || header.alg !== ALGORITHM) {
        return null;
      }

      const publicKey = await findPublicKeyByKid(header.kid, "access");
      if (!publicKey) {
        return null;
      }

      const { payload } = await jose.jwtVerify(token, publicKey, {
        algorithms: [ALGORITHM],
      });

      if (
        typeof payload.sub !== "string" ||
        typeof payload.email !== "string" ||
        typeof payload.role !== "string" ||
        typeof payload.sessionId !== "string" ||
        typeof payload.jti !== "string" ||
        typeof payload.tv !== "number" ||
        typeof payload.iat !== "number" ||
        typeof payload.exp !== "number"
      ) {
        return null;
      }

      if (payload.role !== "admin" && payload.role !== "user") {
        return null;
      }

      return {
        sub: payload.sub,
        email: payload.email as string,
        role: payload.role as "admin" | "user",
        sessionId: payload.sessionId as string,
        jti: payload.jti as string,
        tv: payload.tv as number,
        iat: payload.iat,
        exp: payload.exp,
      };
    } catch {
      return null;
    }
  }

  async verifyRefreshToken(token: string): Promise<RefreshTokenPayload | null> {
    try {
      const header = jose.decodeProtectedHeader(token);
      if (!header.kid || header.alg !== ALGORITHM) {
        return null;
      }

      const publicKey = await findPublicKeyByKid(header.kid, "refresh");
      if (!publicKey) {
        return null;
      }

      const { payload } = await jose.jwtVerify(token, publicKey, {
        algorithms: [ALGORITHM],
      });

      if (
        typeof payload.sub !== "string" ||
        typeof payload.sessionId !== "string" ||
        typeof payload.jti !== "string" ||
        typeof payload.tv !== "number" ||
        typeof payload.iat !== "number" ||
        typeof payload.exp !== "number"
      ) {
        return null;
      }

      return {
        sub: payload.sub,
        sessionId: payload.sessionId as string,
        jti: payload.jti as string,
        tv: payload.tv as number,
        iat: payload.iat,
        exp: payload.exp,
      };
    } catch {
      return null;
    }
  }

  async getJwksData(): Promise<JsonWebKeySet> {
    const keys: JsonWebKey[] = [];

    const accessKeys = await getAccessKeySet();
    const accessJwk = await jose.exportJWK(accessKeys.publicKey);
    keys.push({
      kty: accessJwk.kty ?? "RSA",
      kid: accessKeys.kid,
      alg: ALGORITHM,
      use: "sig",
      n: accessJwk.n ?? "",
      e: accessJwk.e ?? "",
    });

    const refreshKeys = await getRefreshKeySet();
    const refreshJwk = await jose.exportJWK(refreshKeys.publicKey);
    keys.push({
      kty: refreshJwk.kty ?? "RSA",
      kid: refreshKeys.kid,
      alg: ALGORITHM,
      use: "sig",
      n: refreshJwk.n ?? "",
      e: refreshJwk.e ?? "",
    });

    if (Date.now() < previousKeysExpiry) {
      const prevKeys = await getPreviousKeys();
      for (const prev of prevKeys) {
        const jwk = await jose.exportJWK(prev.publicKey);
        keys.push({
          kty: jwk.kty ?? "RSA",
          kid: prev.kid,
          alg: ALGORITHM,
          use: "sig",
          n: jwk.n ?? "",
          e: jwk.e ?? "",
        });
      }
    }

    return { keys };
  }
}


--------------------------------------------------------------------------------
File: src\infrastructure\crypto\otp.service.ts
--------------------------------------------------------------------------------

import crypto from "node:crypto";
import { env } from "@/env";

const ALGORITHM = "aes-256-cbc" as const;
const IV_LENGTH = 16;
const OTP_MIN = 10_000_000;
const OTP_MAX = 99_999_999;

function getEncryptionKey(): Buffer {
  return Buffer.from(env.ENCRYPTION_KEY, "utf-8");
}

export function generateOtp(): string {
  const otp = crypto.randomInt(OTP_MIN, OTP_MAX + 1);
  return otp.toString();
}

export function encryptOtp(otp: string): string {
  const iv = crypto.randomBytes(IV_LENGTH);
  const key = getEncryptionKey();

  const cipher = crypto.createCipheriv(ALGORITHM, key, iv);
  let encrypted = cipher.update(otp, "utf-8", "hex");
  encrypted += cipher.final("hex");

  return `${iv.toString("hex")}:${encrypted}`;
}

export function decryptOtp(encryptedOtp: string): string | null {
  try {
    const colonIndex = encryptedOtp.indexOf(":");
    if (colonIndex === -1) return null;

    const ivHex = encryptedOtp.substring(0, colonIndex);
    const ciphertext = encryptedOtp.substring(colonIndex + 1);

    const iv = Buffer.from(ivHex, "hex");
    if (iv.length !== IV_LENGTH) return null;

    const key = getEncryptionKey();

    const decipher = crypto.createDecipheriv(ALGORITHM, key, iv);
    let decrypted = decipher.update(ciphertext, "hex", "utf-8");
    decrypted += decipher.final("utf-8");

    return decrypted;
  } catch {
    return null;
  }
}

export function verifyOtp(
  submittedOtp: string,
  encryptedStoredOtp: string
): boolean {
  const decrypted = decryptOtp(encryptedStoredOtp);
  if (!decrypted) return false;

  if (submittedOtp.length !== decrypted.length) {
    const buf = Buffer.from(decrypted);
    crypto.timingSafeEqual(buf, buf);
    return false;
  }

  return crypto.timingSafeEqual(
    Buffer.from(submittedOtp),
    Buffer.from(decrypted)
  );
}

export const OTP_EXPIRY_MS = 15 * 60 * 1000;

export const OTP_MAX_ATTEMPTS = 5;


--------------------------------------------------------------------------------
File: src\infrastructure\crypto\password.service.ts
--------------------------------------------------------------------------------

import bcrypt from "bcrypt";
import crypto from "node:crypto";

const BCRYPT_ROUNDS = 12;

const PBKDF2_ITERATIONS = 310_000;
const PBKDF2_KEY_LENGTH = 64;
const PBKDF2_DIGEST = "sha512";

export async function hashPassword(plaintext: string): Promise<string> {
  return bcrypt.hash(plaintext, BCRYPT_ROUNDS);
}

export async function verifyPassword(
  plaintext: string,
  storedHash: string
): Promise<{ valid: boolean; needsRehash: boolean }> {
  const isBcrypt =
    storedHash.startsWith("$2b$") || storedHash.startsWith("$2a$");

  if (isBcrypt) {
    const valid = await bcrypt.compare(plaintext, storedHash);
    return { valid, needsRehash: false };
  }

  const colonIndex = storedHash.indexOf(":");
  if (colonIndex === -1) {
    return { valid: false, needsRehash: false };
  }

  const salt = storedHash.substring(0, colonIndex);
  const expectedHash = storedHash.substring(colonIndex + 1);

  const derivedKey = await new Promise<Buffer>((resolve, reject) => {
    crypto.pbkdf2(
      plaintext,
      Buffer.from(salt, "hex"),
      PBKDF2_ITERATIONS,
      PBKDF2_KEY_LENGTH,
      PBKDF2_DIGEST,
      (err, key) => {
        if (err) reject(err);
        else resolve(key);
      }
    );
  });

  const derivedHex = derivedKey.toString("hex");
  const valid = timingSafeEqual(derivedHex, expectedHash);

  return { valid, needsRehash: true };
}

function timingSafeEqual(a: string, b: string): boolean {
  if (a.length !== b.length) {
    const bufA = Buffer.from(a);
    crypto.timingSafeEqual(bufA, bufA);
    return false;
  }

  return crypto.timingSafeEqual(Buffer.from(a), Buffer.from(b));
}

export function validatePasswordComplexity(password: string): string | null {
  const issues: string[] = [];

  if (password.length < 8) {
    issues.push("at least 8 characters");
  }
  if (!/[A-Z]/.test(password)) {
    issues.push("an uppercase letter");
  }
  if (!/[a-z]/.test(password)) {
    issues.push("a lowercase letter");
  }
  if (!/[0-9]/.test(password)) {
    issues.push("a digit");
  }
  if (!/[!@#$%^&*()_+\-=\[\]{}|;':",.<>/?\\`~]/.test(password)) {
    issues.push("a special character");
  }

  if (issues.length === 0) return null;

  return `Password must contain ${issues.join(", ")}`;
}


--------------------------------------------------------------------------------
File: src\infrastructure\database\auth-event.repository.impl.ts
--------------------------------------------------------------------------------

import { ObjectId } from "mongodb";
import type { Collection } from "mongodb";
import type { IAuthEventRepository } from "@domain/repositories/auth-event.repository";
import type {
  AuthEventEntity,
  AuthEventType,
} from "@domain/entities/auth-event.entity";
import { getCollection } from "./connection";
import type { AuthEventDocument } from "./schemas/auth-event.schema";
import { AUTH_EVENTS_COLLECTION } from "./schemas/auth-event.schema";

function toEntity(doc: AuthEventDocument): AuthEventEntity {
  return {
    id: doc._id.toHexString(),
    eventType: doc.eventType,
    userId: doc.userId,
    email: doc.email,
    sessionId: doc.sessionId,
    ipAddress: doc.ipAddress,
    userAgent: doc.userAgent,
    timestamp: doc.timestamp,
    success: doc.success,
    failureReason: doc.failureReason,
    metadata: doc.metadata,
    serviceId: doc.serviceId,
    requestId: doc.requestId,
  };
}

async function collection(): Promise<Collection<AuthEventDocument>> {
  return getCollection<AuthEventDocument>(AUTH_EVENTS_COLLECTION);
}

export class AuthEventRepositoryImpl implements IAuthEventRepository {
  async create(event: Omit<AuthEventEntity, "id">): Promise<void> {
    try {
      const col = await collection();
      await col.insertOne({
        _id: new ObjectId(),
        eventType: event.eventType,
        userId: event.userId,
        email: event.email,
        sessionId: event.sessionId,
        ipAddress: event.ipAddress,
        userAgent: event.userAgent,
        timestamp: event.timestamp,
        success: event.success,
        failureReason: event.failureReason,
        metadata: event.metadata,
        serviceId: event.serviceId,
        requestId: event.requestId,
      });
    } catch (error) {
      console.error(
        `[AuthEvent] Failed to write ${event.eventType} event:`,
        error instanceof Error ? error.message : "Unknown error"
      );
    }
  }

  async findByUserId(
    userId: string,
    options?: { limit?: number; offset?: number; eventType?: AuthEventType }
  ): Promise<AuthEventEntity[]> {
    const col = await collection();
    const filter: Record<string, unknown> = { userId };

    if (options?.eventType) {
      filter.eventType = options.eventType;
    }

    const cursor = col
      .find(filter)
      .sort({ timestamp: -1 })
      .skip(options?.offset ?? 0)
      .limit(options?.limit ?? 100);

    const docs = await cursor.toArray();
    return docs.map(toEntity);
  }

  async findByIp(
    ipAddress: string,
    options?: { limit?: number; since?: Date }
  ): Promise<AuthEventEntity[]> {
    const col = await collection();
    const filter: Record<string, unknown> = { ipAddress };

    if (options?.since) {
      filter.timestamp = { $gte: options.since };
    }

    const cursor = col
      .find(filter)
      .sort({ timestamp: -1 })
      .limit(options?.limit ?? 100);

    const docs = await cursor.toArray();
    return docs.map(toEntity);
  }
}


--------------------------------------------------------------------------------
File: src\infrastructure\database\connection.ts
--------------------------------------------------------------------------------

import { MongoClient, ServerApiVersion } from "mongodb";
import type { MongoClientOptions, Db } from "mongodb";
import { env } from "@/env";

const CLIENT_OPTIONS: MongoClientOptions = {
  maxPoolSize: 10,
  minPoolSize: 1,
  maxIdleTimeMS: 10_000,

  connectTimeoutMS: 10_000,
  socketTimeoutMS: 45_000,
  serverSelectionTimeoutMS: 10_000,

  serverApi: {
    version: ServerApiVersion.v1,
    strict: true,
    deprecationErrors: true,
  },

  w: "majority",
  retryWrites: true,
  retryReads: true,

  compressors: ["zstd", "snappy", "zlib"],
};

interface CircuitBreakerState {
  failures: number;
  state: "CLOSED" | "OPEN" | "HALF_OPEN";
  lastFailureTime: number;
  nextRetryTime: number;
}

const CIRCUIT_BREAKER_CONFIG = {
  failureThreshold: 5,
  recoveryTimeMs: 30_000,
} as const;

const circuitBreaker: CircuitBreakerState = {
  failures: 0,
  state: "CLOSED",
  lastFailureTime: 0,
  nextRetryTime: 0,
};

let client: MongoClient | null = null;
let db: Db | null = null;
let connectionTimestamp: number = 0;

const CONNECTION_TTL_MS = 10 * 60 * 1000;

function sanitizeError(error: unknown): string {
  if (error instanceof Error) {
    return error.message.replace(
      /mongodb(\+srv)?:\/\/[^\s]+/g,
      "mongodb://[REDACTED]"
    );
  }
  return "Unknown database error";
}

function canAttemptConnection(): boolean {
  if (circuitBreaker.state === "CLOSED") return true;

  if (
    circuitBreaker.state === "OPEN" &&
    Date.now() >= circuitBreaker.nextRetryTime
  ) {
    circuitBreaker.state = "HALF_OPEN";
    return true;
  }

  return circuitBreaker.state === "HALF_OPEN";
}

function recordSuccess(): void {
  circuitBreaker.failures = 0;
  circuitBreaker.state = "CLOSED";
  circuitBreaker.lastFailureTime = 0;
  circuitBreaker.nextRetryTime = 0;
}

function recordFailure(): void {
  circuitBreaker.failures += 1;
  circuitBreaker.lastFailureTime = Date.now();

  if (circuitBreaker.failures >= CIRCUIT_BREAKER_CONFIG.failureThreshold) {
    circuitBreaker.state = "OPEN";
    circuitBreaker.nextRetryTime =
      Date.now() + CIRCUIT_BREAKER_CONFIG.recoveryTimeMs;

    console.error(
      `[MongoDB] Circuit breaker OPEN after ${circuitBreaker.failures} failures. ` +
        `Retry at ${new Date(circuitBreaker.nextRetryTime).toISOString()}`
    );
  }
}

export async function getDatabase(): Promise<Db> {
  if (
    client &&
    db &&
    connectionTimestamp > 0 &&
    Date.now() - connectionTimestamp > CONNECTION_TTL_MS
  ) {
    console.warn("[MongoDB] Connection TTL exceeded, reconnecting...");
    await closeConnection();
  }

  if (client && db) {
    return db;
  }

  if (!canAttemptConnection()) {
    throw new Error(
      `Database connection refused: circuit breaker is ${circuitBreaker.state}. ` +
        `Retry after ${new Date(circuitBreaker.nextRetryTime).toISOString()}`
    );
  }

  try {
    client = new MongoClient(env.MONGODB_URI, CLIENT_OPTIONS);

    client.on("connectionPoolCreated", (event) => {
      console.log(`[MongoDB] Pool created: ${event.address}`);
    });

    client.on("connectionPoolCleared", (event) => {
      console.warn(`[MongoDB] Pool cleared: ${event.address}`);
    });

    client.on("connectionCheckOutFailed", (event) => {
      console.error(`[MongoDB] Connection checkout failed: ${event.reason}`);
    });

    await client.connect();

    db = client.db(env.DB_NAME);
    await db.command({ ping: 1 });

    connectionTimestamp = Date.now();
    recordSuccess();

    console.log(
      `[MongoDB] Connected to database "${env.DB_NAME}" successfully`
    );

    return db;
  } catch (error) {
    recordFailure();

    if (client) {
      try {
        await client.close();
      } catch {}
      client = null;
      db = null;
    }

    throw new Error(`Database connection failed: ${sanitizeError(error)}`);
  }
}

export async function getCollection<T extends Document>(
  name: string
): Promise<import("mongodb").Collection<T>> {
  const database = await getDatabase();
  return database.collection<T>(name);
}

export async function closeConnection(): Promise<void> {
  if (client) {
    try {
      await client.close();
    } catch (error) {
      console.error(
        `[MongoDB] Error closing connection: ${sanitizeError(error)}`
      );
    } finally {
      client = null;
      db = null;
      connectionTimestamp = 0;
    }
  }
}


--------------------------------------------------------------------------------
File: src\infrastructure\database\indexes.ts
--------------------------------------------------------------------------------

import type { Db, IndexDescription } from "mongodb";
import { getDatabase } from "./connection";
import { USERS_COLLECTION } from "./schemas/user.schema";
import { SESSIONS_COLLECTION } from "./schemas/session.schema";
import { AUTH_EVENTS_COLLECTION } from "./schemas/auth-event.schema";

const INDEX_DEFINITIONS: Array<{
  collection: string;
  indexes: IndexDescription[];
}> = [
  {
    collection: USERS_COLLECTION,
    indexes: [
      {
        key: { email: 1 },
        unique: true,
        name: "idx_email_unique",
      },
      {
        key: { verificationToken: 1 },
        sparse: true,
        name: "idx_verification_token",
      },
      {
        key: { verificationTokenHash: 1 },
        sparse: true,
        name: "idx_verification_token_hash",
      },
      {
        key: { passwordResetTokenHash: 1 },
        sparse: true,
        name: "idx_password_reset_token_hash",
      },
      {
        key: { role: 1 },
        name: "idx_role",
      },
      {
        key: { createdAt: -1 },
        name: "idx_created_at_desc",
      },
      {
        key: { email: 1, isVerified: 1 },
        name: "idx_email_verified",
      },
      {
        key: { tokenVersion: 1 },
        name: "idx_token_version",
      },
    ],
  },
  {
    collection: SESSIONS_COLLECTION,
    indexes: [
      {
        key: { userId: 1 },
        name: "idx_user_id",
      },
      {
        key: { sessionId: 1 },
        unique: true,
        name: "idx_session_id_unique",
      },
      {
        key: { refreshTokenHash: 1 },
        unique: true,
        name: "idx_refresh_token_hash_unique",
      },
      {
        key: { expiresAt: 1 },
        expireAfterSeconds: 0,
        name: "idx_expires_at_ttl",
      },
      {
        key: { userId: 1, expiresAt: -1 },
        name: "idx_user_id_expires_at",
      },
    ],
  },
  {
    collection: AUTH_EVENTS_COLLECTION,
    indexes: [
      {
        key: { timestamp: -1 },
        name: "idx_timestamp_desc",
      },
      {
        key: { userId: 1, timestamp: -1 },
        name: "idx_user_id_timestamp",
      },
      {
        key: { eventType: 1, timestamp: -1 },
        name: "idx_event_type_timestamp",
      },
      {
        key: { ipAddress: 1, timestamp: -1 },
        name: "idx_ip_address_timestamp",
      },
      {
        key: { sessionId: 1 },
        sparse: true,
        name: "idx_session_id",
      },
      {
        key: { timestamp: 1 },
        expireAfterSeconds: 7_776_000,
        name: "idx_timestamp_ttl_90d",
      },
    ],
  },
];

export async function createIndexes(): Promise<void> {
  const db = await getDatabase();

  for (const { collection, indexes } of INDEX_DEFINITIONS) {
    try {
      const result = await db.collection(collection).createIndexes(indexes);
      console.log(
        `[Indexes] ${collection}: ensured ${result.length} indexes — [${result.join(", ")}]`
      );
    } catch (error) {
      console.error(
        `[Indexes] Failed to create indexes for ${collection}:`,
        error instanceof Error ? error.message : "Unknown error"
      );
    }
  }
}

export async function dropIndexes(
  db: Db,
  collectionName: string
): Promise<void> {
  await db.collection(collectionName).dropIndexes();
}


--------------------------------------------------------------------------------
File: src\infrastructure\database\schemas\auth-event.schema.ts
--------------------------------------------------------------------------------

import type { ObjectId } from "mongodb";
import type { AuthEventType } from "@domain/entities/auth-event.entity";

export interface AuthEventDocument {
  _id: ObjectId;
  eventType: AuthEventType;
  userId?: string;
  email?: string;
  sessionId?: string;
  ipAddress?: string;
  userAgent?: string;
  timestamp: Date;
  success: boolean;
  failureReason?: string;
  metadata?: Record<string, unknown>;
  serviceId: string;
  requestId: string;
}

export const AUTH_EVENTS_COLLECTION = "platform_auth_events" as const;


--------------------------------------------------------------------------------
File: src\infrastructure\database\schemas\session.schema.ts
--------------------------------------------------------------------------------

import type { ObjectId } from "mongodb";

export interface SessionDocument {
  _id: ObjectId;
  sessionId: string;
  userId: string;
  refreshTokenHash: string;
  ipAddress?: string;
  userAgent?: string;
  expiresAt: Date;
  createdAt: Date;
  lastUsedAt: Date;
}

export const SESSIONS_COLLECTION = "platform_sessions" as const;


--------------------------------------------------------------------------------
File: src\infrastructure\database\schemas\user.schema.ts
--------------------------------------------------------------------------------

import type { ObjectId } from "mongodb";

export interface UserDocument {
  _id: ObjectId;
  email: string;
  hashedPassword: string;
  role: "admin" | "user";
  isVerified: boolean;
  tokenVersion: number;
  tier: "free" | "pro";

  verificationToken?: string;
  verificationTokenHash?: string;
  verificationTokenExpiry?: Date;

  passwordResetToken?: string;
  passwordResetTokenHash?: string;
  passwordResetTokenExpiry?: Date;

  otpSecret?: string;
  otpExpiry?: Date;
  otpAttempts?: number;

  createdAt: Date;
  updatedAt: Date;
}

export const USERS_COLLECTION = "platform_users" as const;


--------------------------------------------------------------------------------
File: src\infrastructure\database\session.repository.impl.ts
--------------------------------------------------------------------------------

import type { Collection } from "mongodb";
import type { ISessionRepository } from "@domain/repositories/session.repository";
import type { SessionEntity } from "@domain/entities/session.entity";
import { getCollection } from "./connection";
import type { SessionDocument } from "./schemas/session.schema";
import { SESSIONS_COLLECTION } from "./schemas/session.schema";

function toEntity(doc: SessionDocument): SessionEntity {
  return {
    id: doc._id.toHexString(),
    sessionId: doc.sessionId,
    userId: doc.userId,
    refreshTokenHash: doc.refreshTokenHash,
    ipAddress: doc.ipAddress,
    userAgent: doc.userAgent,
    expiresAt: doc.expiresAt,
    createdAt: doc.createdAt,
    lastUsedAt: doc.lastUsedAt,
  };
}

async function collection(): Promise<Collection<SessionDocument>> {
  return getCollection<SessionDocument>(SESSIONS_COLLECTION);
}

export class SessionRepositoryImpl implements ISessionRepository {
  async create(
    session: Omit<SessionEntity, "id" | "createdAt">
  ): Promise<SessionEntity> {
    const col = await collection();
    const now = new Date();

    const doc: Omit<SessionDocument, "_id"> = {
      sessionId: session.sessionId,
      userId: session.userId,
      refreshTokenHash: session.refreshTokenHash,
      ipAddress: session.ipAddress,
      userAgent: session.userAgent,
      expiresAt: session.expiresAt,
      createdAt: now,
      lastUsedAt: session.lastUsedAt,
    };

    const result = await col.insertOne(doc as SessionDocument);
    return toEntity({
      _id: result.insertedId,
      ...doc,
    } as SessionDocument);
  }

  async findByRefreshTokenHash(hash: string): Promise<SessionEntity | null> {
    const col = await collection();
    const doc = await col.findOne({
      refreshTokenHash: hash,
      expiresAt: { $gt: new Date() },
    });
    return doc ? toEntity(doc) : null;
  }

  async findBySessionId(sessionId: string): Promise<SessionEntity | null> {
    const col = await collection();
    const doc = await col.findOne({
      sessionId,
      expiresAt: { $gt: new Date() },
    });
    return doc ? toEntity(doc) : null;
  }

  async findByUserId(userId: string): Promise<SessionEntity[]> {
    const col = await collection();
    const docs = await col
      .find({
        userId,
        expiresAt: { $gt: new Date() },
      })
      .sort({ expiresAt: -1 })
      .toArray();
    return docs.map(toEntity);
  }

  async delete(sessionId: string): Promise<boolean> {
    const col = await collection();
    const result = await col.deleteOne({ sessionId });
    return result.deletedCount > 0;
  }

  async deleteAllForUser(userId: string): Promise<number> {
    const col = await collection();
    const result = await col.deleteMany({ userId });
    return result.deletedCount;
  }

  async findAndDeleteByRefreshTokenHash(
    hash: string
  ): Promise<SessionEntity | null> {
    const col = await collection();
    const doc = await col.findOneAndDelete({
      refreshTokenHash: hash,
      expiresAt: { $gt: new Date() },
    });
    return doc ? toEntity(doc) : null;
  }

  async updateLastUsed(sessionId: string, lastUsedAt: Date): Promise<void> {
    const col = await collection();
    await col.updateOne({ sessionId }, { $set: { lastUsedAt } });
  }

  async deleteExpiredSessions(): Promise<number> {
    const col = await collection();
    const result = await col.deleteMany({
      expiresAt: { $lte: new Date() },
    });
    return result.deletedCount;
  }
}


--------------------------------------------------------------------------------
File: src\infrastructure\database\user.repository.impl.ts
--------------------------------------------------------------------------------

import { ObjectId } from "mongodb";
import type { Collection } from "mongodb";
import type { IUserRepository } from "@domain/repositories/user.repository";
import type { UserEntity } from "@domain/entities/user.entity";
import { ConflictError } from "@domain/errors/conflict.error";
import { getCollection } from "./connection";
import type { UserDocument } from "./schemas/user.schema";
import { USERS_COLLECTION } from "./schemas/user.schema";

function toEntity(doc: UserDocument): UserEntity {
  return {
    id: doc._id.toHexString(),
    email: doc.email,
    hashedPassword: doc.hashedPassword,
    role: doc.role,
    isVerified: doc.isVerified,
    tokenVersion: doc.tokenVersion,
    tier: doc.tier,
    verificationToken: doc.verificationToken,
    verificationTokenHash: doc.verificationTokenHash,
    verificationTokenExpiry: doc.verificationTokenExpiry,
    passwordResetToken: doc.passwordResetToken,
    passwordResetTokenHash: doc.passwordResetTokenHash,
    passwordResetTokenExpiry: doc.passwordResetTokenExpiry,
    otpSecret: doc.otpSecret,
    otpExpiry: doc.otpExpiry,
    otpAttempts: doc.otpAttempts,
    createdAt: doc.createdAt,
    updatedAt: doc.updatedAt,
  };
}

async function collection(): Promise<Collection<UserDocument>> {
  return getCollection<UserDocument>(USERS_COLLECTION);
}

export class UserRepositoryImpl implements IUserRepository {
  async findByEmail(email: string): Promise<UserEntity | null> {
    const col = await collection();
    const doc = await col.findOne({ email: email.toLowerCase() });
    return doc ? toEntity(doc) : null;
  }

  async findById(id: string): Promise<UserEntity | null> {
    if (!ObjectId.isValid(id)) return null;
    const col = await collection();
    const doc = await col.findOne({ _id: new ObjectId(id) });
    return doc ? toEntity(doc) : null;
  }

  async create(
    user: Omit<UserEntity, "id" | "createdAt" | "updatedAt">
  ): Promise<UserEntity> {
    const col = await collection();
    const now = new Date();

    const doc: Omit<UserDocument, "_id"> = {
      email: user.email.toLowerCase(),
      hashedPassword: user.hashedPassword,
      role: user.role,
      isVerified: user.isVerified,
      tokenVersion: user.tokenVersion,
      tier: user.tier,
      verificationToken: user.verificationToken,
      verificationTokenHash: user.verificationTokenHash,
      verificationTokenExpiry: user.verificationTokenExpiry,
      passwordResetToken: user.passwordResetToken,
      passwordResetTokenHash: user.passwordResetTokenHash,
      passwordResetTokenExpiry: user.passwordResetTokenExpiry,
      otpSecret: user.otpSecret,
      otpExpiry: user.otpExpiry,
      otpAttempts: user.otpAttempts,
      createdAt: now,
      updatedAt: now,
    };

    try {
      const result = await col.insertOne(doc as UserDocument);
      return toEntity({
        _id: result.insertedId,
        ...doc,
      } as UserDocument);
    } catch (error) {
      if (
        error instanceof Error &&
        "code" in error &&
        (error as { code: number }).code === 11000
      ) {
        throw new ConflictError("An account with this email already exists");
      }
      throw error;
    }
  }

  async updatePassword(
    userId: string,
    hashedPassword: string,
    tokenVersion?: number
  ): Promise<void> {
    const col = await collection();
    const update: Record<string, unknown> = {
      hashedPassword,
      updatedAt: new Date(),
    };
    if (tokenVersion !== undefined) {
      update.tokenVersion = tokenVersion;
    }
    await col.updateOne({ _id: new ObjectId(userId) }, { $set: update });
  }

  async updateTokenVersion(
    userId: string,
    tokenVersion: number
  ): Promise<void> {
    const col = await collection();
    await col.updateOne(
      { _id: new ObjectId(userId) },
      { $set: { tokenVersion, updatedAt: new Date() } }
    );
  }

  async updateVerification(
    userId: string,
    update: {
      isVerified: boolean;
      verificationToken?: string | null;
      verificationTokenHash?: string | null;
      verificationTokenExpiry?: Date | null;
    }
  ): Promise<void> {
    const col = await collection();
    const $set: Record<string, unknown> = {
      isVerified: update.isVerified,
      updatedAt: new Date(),
    };
    const $unset: Record<string, ""> = {};

    if (update.verificationToken === null) {
      $unset.verificationToken = "";
    } else if (update.verificationToken !== undefined) {
      $set.verificationToken = update.verificationToken;
    }

    if (update.verificationTokenHash === null) {
      $unset.verificationTokenHash = "";
    } else if (update.verificationTokenHash !== undefined) {
      $set.verificationTokenHash = update.verificationTokenHash;
    }

    if (update.verificationTokenExpiry === null) {
      $unset.verificationTokenExpiry = "";
    } else if (update.verificationTokenExpiry !== undefined) {
      $set.verificationTokenExpiry = update.verificationTokenExpiry;
    }

    const updateOp: Record<string, unknown> = { $set };
    if (Object.keys($unset).length > 0) {
      updateOp.$unset = $unset;
    }

    await col.updateOne({ _id: new ObjectId(userId) }, updateOp);
  }

  async updateOtp(
    userId: string,
    update: {
      otpSecret: string;
      otpExpiry: Date;
      otpAttempts: number;
    }
  ): Promise<void> {
    const col = await collection();
    await col.updateOne(
      { _id: new ObjectId(userId) },
      {
        $set: {
          otpSecret: update.otpSecret,
          otpExpiry: update.otpExpiry,
          otpAttempts: update.otpAttempts,
          updatedAt: new Date(),
        },
      }
    );
  }

  async clearOtp(userId: string): Promise<void> {
    const col = await collection();
    await col.updateOne(
      { _id: new ObjectId(userId) },
      {
        $unset: {
          otpSecret: "",
          otpExpiry: "",
          otpAttempts: "",
        },
        $set: { updatedAt: new Date() },
      }
    );
  }

  async findByVerificationTokenHash(hash: string): Promise<UserEntity | null> {
    const col = await collection();
    const doc = await col.findOne({ verificationTokenHash: hash });
    return doc ? toEntity(doc) : null;
  }

  async findByPasswordResetTokenHash(hash: string): Promise<UserEntity | null> {
    const col = await collection();
    const doc = await col.findOne({ passwordResetTokenHash: hash });
    return doc ? toEntity(doc) : null;
  }

  async updatePasswordResetToken(
    userId: string,
    update: {
      passwordResetToken: string;
      passwordResetTokenHash: string;
      passwordResetTokenExpiry: Date;
    }
  ): Promise<void> {
    const col = await collection();
    await col.updateOne(
      { _id: new ObjectId(userId) },
      {
        $set: {
          passwordResetToken: update.passwordResetToken,
          passwordResetTokenHash: update.passwordResetTokenHash,
          passwordResetTokenExpiry: update.passwordResetTokenExpiry,
          updatedAt: new Date(),
        },
      }
    );
  }

  async clearPasswordResetToken(userId: string): Promise<void> {
    const col = await collection();
    await col.updateOne(
      { _id: new ObjectId(userId) },
      {
        $unset: {
          passwordResetToken: "",
          passwordResetTokenHash: "",
          passwordResetTokenExpiry: "",
        },
        $set: { updatedAt: new Date() },
      }
    );
  }

  async updateVerificationToken(
    userId: string,
    update: {
      verificationToken: string;
      verificationTokenHash: string;
      verificationTokenExpiry: Date;
    }
  ): Promise<void> {
    const col = await collection();
    await col.updateOne(
      { _id: new ObjectId(userId) },
      {
        $set: {
          verificationToken: update.verificationToken,
          verificationTokenHash: update.verificationTokenHash,
          verificationTokenExpiry: update.verificationTokenExpiry,
          updatedAt: new Date(),
        },
      }
    );
  }

  async incrementOtpAttempts(userId: string): Promise<void> {
    const col = await collection();
    await col.updateOne(
      { _id: new ObjectId(userId) },
      { $inc: { otpAttempts: 1 }, $set: { updatedAt: new Date() } }
    );
  }
}


--------------------------------------------------------------------------------
File: src\infrastructure\email\brevo.provider.ts
--------------------------------------------------------------------------------

import * as brevo from "@getbrevo/brevo";
import pRetry from "p-retry";
import type { IEmailProvider } from "@app/interfaces/email.provider";
import { env } from "@/env";

function getApiInstance(): brevo.TransactionalEmailsApi {
  if (!process.env.BREVO_API_KEY) {
    process.env.BREVO_API_KEY = env.BREVO_API_KEY;
  }

  return new brevo.TransactionalEmailsApi();
}

const RETRY_OPTIONS: Parameters<typeof pRetry>[1] = {
  retries: 2,
  minTimeout: 1000,
  factor: 2,
  onFailedAttempt: (error) => {
    console.warn(
      `[Email] Attempt ${error.attemptNumber} failed. ` +
        `${error.retriesLeft} retries remaining. ` +
        `Error: ${error.message}`
    );
  },
  shouldRetry: (error) => {
    if (error instanceof Error && "statusCode" in error) {
      const status = (error as { statusCode: number }).statusCode;
      if (status >= 400 && status < 500) return false;
    }
    return true;
  },
};

interface BaseEmailParams {
  sender: { email: string; name: string };
  to: Array<{ email: string }>;
  subject: string;
  htmlContent: string;
}

function buildVerificationEmail(to: string, token: string): BaseEmailParams {
  const verifyUrl = `${env.NEXT_PUBLIC_SITE_URL}/verify-email?token=${encodeURIComponent(token)}`;

  return {
    sender: { email: env.FROM_EMAIL, name: "ankurhalder.com" },
    to: [{ email: to }],
    subject: "Verify your email — ankurhalder.com",
    htmlContent: `
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Verify your email</title>
</head>
<body style="margin:0; padding:0; background-color:#f4f4f5; font-family:-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">
  <table width="100%" cellpadding="0" cellspacing="0" style="background-color:#f4f4f5; padding:40px 20px;">
    <tr>
      <td align="center">
        <table width="600" cellpadding="0" cellspacing="0" style="background-color:#ffffff; border-radius:8px; overflow:hidden; box-shadow:0 1px 3px rgba(0,0,0,0.1);">
          <!-- Header -->
          <tr>
            <td style="background-color:#7c3aed; padding:24px 32px;">
              <h1 style="color:#ffffff; margin:0; font-size:20px; font-weight:600;">ankurhalder.com</h1>
            </td>
          </tr>
          <!-- Body -->
          <tr>
            <td style="padding:32px;">
              <h2 style="color:#18181b; margin:0 0 16px 0; font-size:24px;">Verify your email address</h2>
              <p style="color:#3f3f46; line-height:1.6; margin:0 0 24px 0;">
                Thank you for signing up. Please click the button below to verify your email address and activate your account.
              </p>
              <table cellpadding="0" cellspacing="0" style="margin:0 0 24px 0;">
                <tr>
                  <td style="background-color:#7c3aed; border-radius:6px; padding:12px 24px;">
                    <a href="${verifyUrl}" style="color:#ffffff; text-decoration:none; font-weight:600; font-size:16px; display:inline-block;">
                      Verify Email Address
                    </a>
                  </td>
                </tr>
              </table>
              <p style="color:#71717a; font-size:14px; line-height:1.6; margin:0 0 16px 0;">
                If the button does not work, copy and paste this link into your browser:
              </p>
              <p style="color:#7c3aed; font-size:14px; word-break:break-all; margin:0 0 24px 0;">
                ${verifyUrl}
              </p>
              <p style="color:#a1a1aa; font-size:12px; margin:0;">
                This link expires in 1 hour. If you did not create an account, you can safely ignore this email.
              </p>
            </td>
          </tr>
        </table>
      </td>
    </tr>
  </table>
</body>
</html>`,
  };
}

function buildOtpEmail(to: string, otp: string): BaseEmailParams {
  return {
    sender: { email: env.FROM_EMAIL, name: "ankurhalder.com" },
    to: [{ email: to }],
    subject: "Your admin verification code",
    htmlContent: `
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Admin verification code</title>
</head>
<body style="margin:0; padding:0; background-color:#f4f4f5; font-family:-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">
  <table width="100%" cellpadding="0" cellspacing="0" style="background-color:#f4f4f5; padding:40px 20px;">
    <tr>
      <td align="center">
        <table width="600" cellpadding="0" cellspacing="0" style="background-color:#ffffff; border-radius:8px; overflow:hidden; box-shadow:0 1px 3px rgba(0,0,0,0.1);">
          <!-- Header -->
          <tr>
            <td style="background-color:#dc2626; padding:24px 32px;">
              <h1 style="color:#ffffff; margin:0; font-size:20px; font-weight:600;">Admin Verification</h1>
            </td>
          </tr>
          <!-- Body -->
          <tr>
            <td style="padding:32px; text-align:center;">
              <h2 style="color:#18181b; margin:0 0 16px 0; font-size:24px;">Your verification code</h2>
              <p style="color:#3f3f46; line-height:1.6; margin:0 0 24px 0;">
                Use the following code to complete your admin sign-in:
              </p>
              <div style="background-color:#fef2f2; border:2px solid #fecaca; border-radius:8px; padding:20px; margin:0 0 24px 0;">
                <span style="font-size:36px; font-weight:700; letter-spacing:8px; color:#dc2626; font-family:monospace;">
                  ${otp}
                </span>
              </div>
              <p style="color:#71717a; font-size:14px; line-height:1.6; margin:0 0 8px 0;">
                This code expires in <strong>15 minutes</strong>.
              </p>
              <p style="color:#a1a1aa; font-size:12px; margin:0;">
                If you did not attempt to sign in, your account may be compromised. Please change your password immediately.
              </p>
            </td>
          </tr>
        </table>
      </td>
    </tr>
  </table>
</body>
</html>`,
  };
}

function buildPasswordResetEmail(to: string, token: string): BaseEmailParams {
  const resetUrl = `${env.NEXT_PUBLIC_SITE_URL}/reset-password?token=${encodeURIComponent(token)}`;

  return {
    sender: { email: env.FROM_EMAIL, name: "ankurhalder.com" },
    to: [{ email: to }],
    subject: "Reset your password — ankurhalder.com",
    htmlContent: `
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Reset your password</title>
</head>
<body style="margin:0; padding:0; background-color:#f4f4f5; font-family:-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">
  <table width="100%" cellpadding="0" cellspacing="0" style="background-color:#f4f4f5; padding:40px 20px;">
    <tr>
      <td align="center">
        <table width="600" cellpadding="0" cellspacing="0" style="background-color:#ffffff; border-radius:8px; overflow:hidden; box-shadow:0 1px 3px rgba(0,0,0,0.1);">
          <!-- Header -->
          <tr>
            <td style="background-color:#7c3aed; padding:24px 32px;">
              <h1 style="color:#ffffff; margin:0; font-size:20px; font-weight:600;">ankurhalder.com</h1>
            </td>
          </tr>
          <!-- Body -->
          <tr>
            <td style="padding:32px;">
              <h2 style="color:#18181b; margin:0 0 16px 0; font-size:24px;">Reset your password</h2>
              <p style="color:#3f3f46; line-height:1.6; margin:0 0 24px 0;">
                We received a request to reset your password. Click the button below to choose a new password.
              </p>
              <table cellpadding="0" cellspacing="0" style="margin:0 0 24px 0;">
                <tr>
                  <td style="background-color:#7c3aed; border-radius:6px; padding:12px 24px;">
                    <a href="${resetUrl}" style="color:#ffffff; text-decoration:none; font-weight:600; font-size:16px; display:inline-block;">
                      Reset Password
                    </a>
                  </td>
                </tr>
              </table>
              <p style="color:#71717a; font-size:14px; line-height:1.6; margin:0 0 16px 0;">
                If the button does not work, copy and paste this link into your browser:
              </p>
              <p style="color:#7c3aed; font-size:14px; word-break:break-all; margin:0 0 24px 0;">
                ${resetUrl}
              </p>
              <p style="color:#a1a1aa; font-size:12px; margin:0;">
                This link expires in 1 hour. If you did not request a password reset, you can safely ignore this email.
              </p>
            </td>
          </tr>
        </table>
      </td>
    </tr>
  </table>
</body>
</html>`,
  };
}

function buildContactFormEmail(
  from: string,
  name: string,
  subject: string,
  message: string
): BaseEmailParams {
  return {
    sender: { email: env.FROM_EMAIL, name: "ankurhalder.com Contact Form" },
    to: [{ email: env.ADMIN_EMAIL }],
    subject: `Contact form: ${subject}`,
    htmlContent: `
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Contact form submission</title>
</head>
<body style="margin:0; padding:0; background-color:#f4f4f5; font-family:-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">
  <table width="100%" cellpadding="0" cellspacing="0" style="background-color:#f4f4f5; padding:40px 20px;">
    <tr>
      <td align="center">
        <table width="600" cellpadding="0" cellspacing="0" style="background-color:#ffffff; border-radius:8px; overflow:hidden; box-shadow:0 1px 3px rgba(0,0,0,0.1);">
          <!-- Header -->
          <tr>
            <td style="background-color:#2563eb; padding:24px 32px;">
              <h1 style="color:#ffffff; margin:0; font-size:20px; font-weight:600;">New Contact Form Submission</h1>
            </td>
          </tr>
          <!-- Body -->
          <tr>
            <td style="padding:32px;">
              <table width="100%" cellpadding="8" cellspacing="0" style="margin:0 0 24px 0;">
                <tr>
                  <td style="color:#71717a; font-weight:600; width:100px; vertical-align:top;">From:</td>
                  <td style="color:#18181b;">${escapeHtml(name)} &lt;${escapeHtml(from)}&gt;</td>
                </tr>
                <tr>
                  <td style="color:#71717a; font-weight:600; vertical-align:top;">Subject:</td>
                  <td style="color:#18181b;">${escapeHtml(subject)}</td>
                </tr>
              </table>
              <div style="background-color:#f4f4f5; border-radius:6px; padding:20px; margin:0;">
                <p style="color:#3f3f46; line-height:1.6; margin:0; white-space:pre-wrap;">${escapeHtml(message)}</p>
              </div>
            </td>
          </tr>
        </table>
      </td>
    </tr>
  </table>
</body>
</html>`,
  };
}

function escapeHtml(text: string): string {
  const map: Record<string, string> = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#039;",
  };
  return text.replace(/[&<>"']/g, (char) => map[char] ?? char);
}

// ── Brevo Provider Class ──

export class BrevoEmailProvider implements IEmailProvider {
  /**
   * Send email via Brevo with retry logic.
   *
   * Uses p-retry for resilience against transient failures.
   * All email sending is ultimately called fire-and-forget from use cases.
   */
  private async sendEmail(params: BaseEmailParams): Promise<void> {
    const api = getApiInstance();

    const sendSmtpEmail = new brevo.SendSmtpEmail();
    sendSmtpEmail.sender = params.sender;
    sendSmtpEmail.to = params.to;
    sendSmtpEmail.subject = params.subject;
    sendSmtpEmail.htmlContent = params.htmlContent;

    await pRetry(async () => {
      await api.sendTransacEmail(sendSmtpEmail);
    }, RETRY_OPTIONS);
  }

  async sendVerificationEmail(to: string, token: string): Promise<void> {
    const params = buildVerificationEmail(to, token);
    await this.sendEmail(params);
  }

  async sendOtpEmail(to: string, otp: string): Promise<void> {
    const params = buildOtpEmail(to, otp);
    await this.sendEmail(params);
  }

  async sendPasswordResetEmail(to: string, token: string): Promise<void> {
    const params = buildPasswordResetEmail(to, token);
    await this.sendEmail(params);
  }

  async sendContactFormEmail(
    from: string,
    name: string,
    subject: string,
    message: string
  ): Promise<void> {
    const params = buildContactFormEmail(from, name, subject, message);
    await this.sendEmail(params);
  }
}


--------------------------------------------------------------------------------
File: src\infrastructure\redis\client.ts
--------------------------------------------------------------------------------

import { Redis } from "@upstash/redis";
import { env } from "@/env";

let redisClient: Redis | null = null;
let redisAvailable = true;
let lastRedisError: number = 0;

const REDIS_RETRY_COOLDOWN_MS = 30_000;

export function getRedisClient(): Redis | null {
  if (
    !redisAvailable &&
    Date.now() - lastRedisError < REDIS_RETRY_COOLDOWN_MS
  ) {
    return null;
  }

  if (redisClient) {
    return redisClient;
  }

  try {
    if (!env.UPSTASH_REDIS_REST_URL || !env.UPSTASH_REDIS_REST_TOKEN) {
      console.warn(
        "[Redis] Missing UPSTASH credentials. Running without Redis."
      );
      redisAvailable = false;
      return null;
    }

    redisClient = new Redis({
      url: env.UPSTASH_REDIS_REST_URL,
      token: env.UPSTASH_REDIS_REST_TOKEN,
      automaticDeserialization: true,
    });

    redisAvailable = true;
    return redisClient;
  } catch (error) {
    console.error(
      "[Redis] Failed to initialize client:",
      error instanceof Error ? error.message : "Unknown error"
    );
    redisAvailable = false;
    lastRedisError = Date.now();
    return null;
  }
}

export function isRedisAvailable(): boolean {
  return redisAvailable;
}

export function recordRedisFailure(error: unknown): void {
  console.error(
    "[Redis] Operation failed:",
    error instanceof Error ? error.message : "Unknown error"
  );
  lastRedisError = Date.now();
}

export { redisClient };


--------------------------------------------------------------------------------
File: src\infrastructure\redis\otp-rate-limiter.ts
--------------------------------------------------------------------------------

import { getRedisClient } from "./client";

const BACKOFF_INTERVALS = [0, 30, 60, 120, 300];

const MAX_BACKOFF_SECONDS = 300;

const RATE_LIMIT_TTL_SECONDS = 24 * 60 * 60;

interface RateLimitResult {
  allowed: boolean;
  retryAfterSeconds?: number;
}

export async function checkOtpRateLimit(
  userId: string
): Promise<RateLimitResult> {
  const redis = getRedisClient();

  if (!redis) {
    console.warn("[OTP RateLimit] Redis unavailable, allowing request");
    return { allowed: true };
  }

  const key = `otp:ratelimit:${userId}`;

  try {
    const data = await redis.get<{ count: number; lastAttempt: number }>(key);

    if (!data) {
      await redis.set(
        key,
        { count: 1, lastAttempt: Date.now() },
        {
          ex: RATE_LIMIT_TTL_SECONDS,
        }
      );
      return { allowed: true };
    }

    const { count, lastAttempt } = data;
    const now = Date.now();
    const secondsSinceLastAttempt = Math.floor((now - lastAttempt) / 1000);

    const backoffSeconds =
      count >= BACKOFF_INTERVALS.length
        ? MAX_BACKOFF_SECONDS
        : BACKOFF_INTERVALS[count] || 0;

    if (secondsSinceLastAttempt < backoffSeconds) {
      const retryAfterSeconds = backoffSeconds - secondsSinceLastAttempt;
      return {
        allowed: false,
        retryAfterSeconds,
      };
    }

    await redis.set(
      key,
      { count: count + 1, lastAttempt: now },
      {
        ex: RATE_LIMIT_TTL_SECONDS,
      }
    );

    return { allowed: true };
  } catch (error) {
    console.error(
      "[OTP RateLimit] Redis operation failed:",
      error instanceof Error ? error.message : "Unknown error"
    );

    return { allowed: true };
  }
}

export async function resetOtpRateLimit(userId: string): Promise<void> {
  const redis = getRedisClient();

  if (!redis) {
    return;
  }

  const key = `otp:ratelimit:${userId}`;

  try {
    await redis.del(key);
  } catch (error) {
    console.error(
      "[OTP RateLimit] Failed to reset counter:",
      error instanceof Error ? error.message : "Unknown error"
    );
  }
}


--------------------------------------------------------------------------------
File: src\infrastructure\redis\revocation.store.impl.ts
--------------------------------------------------------------------------------

import type { IRevocationStore } from "@app/interfaces/revocation.store";
import { getRedisClient, recordRedisFailure } from "./client";
import { SimpleLRU } from "./simple-lru";

const KEYS = {
  token: (jti: string) => `revoked:token:${jti}`,
  session: (sessionId: string) => `revoked:session:${sessionId}`,
  user: (userId: string) => `revoked:user:${userId}`,
} as const;

const LRU_MAX_SIZE = 10_000;

export class RevocationStoreImpl implements IRevocationStore {
  private readonly tokenLRU = new SimpleLRU<true>(LRU_MAX_SIZE);
  private readonly sessionLRU = new SimpleLRU<true>(LRU_MAX_SIZE);
  private readonly userLRU = new SimpleLRU<number>(LRU_MAX_SIZE);

  async revokeToken(jti: string, ttlSeconds: number): Promise<void> {
    this.tokenLRU.set(jti, true, ttlSeconds);

    const redis = getRedisClient();
    if (redis) {
      try {
        await redis.set(KEYS.token(jti), "1", { ex: ttlSeconds });
      } catch (error) {
        recordRedisFailure(error);
      }
    }
  }

  async isTokenRevoked(jti: string): Promise<boolean> {
    if (this.tokenLRU.has(jti)) {
      return true;
    }

    const redis = getRedisClient();
    if (redis) {
      try {
        const result = await redis.get(KEYS.token(jti));
        if (result !== null) {
          this.tokenLRU.set(jti, true, 900);
          return true;
        }
      } catch (error) {
        recordRedisFailure(error);
      }
    }

    return false;
  }

  async revokeSession(sessionId: string, ttlSeconds: number): Promise<void> {
    this.sessionLRU.set(sessionId, true, ttlSeconds);

    const redis = getRedisClient();
    if (redis) {
      try {
        await redis.set(KEYS.session(sessionId), "1", { ex: ttlSeconds });
      } catch (error) {
        recordRedisFailure(error);
      }
    }
  }

  async isSessionRevoked(sessionId: string): Promise<boolean> {
    if (this.sessionLRU.has(sessionId)) {
      return true;
    }

    const redis = getRedisClient();
    if (redis) {
      try {
        const result = await redis.get(KEYS.session(sessionId));
        if (result !== null) {
          this.sessionLRU.set(sessionId, true, 604_800);
          return true;
        }
      } catch (error) {
        recordRedisFailure(error);
      }
    }

    return false;
  }

  async revokeAllUserSessions(
    userId: string,
    ttlSeconds: number
  ): Promise<void> {
    const timestamp = Date.now();

    this.userLRU.set(userId, timestamp, ttlSeconds);

    const redis = getRedisClient();
    if (redis) {
      try {
        await redis.set(KEYS.user(userId), timestamp.toString(), {
          ex: ttlSeconds,
        });
      } catch (error) {
        recordRedisFailure(error);
      }
    }
  }

  async getUserRevocationTimestamp(userId: string): Promise<number | null> {
    const lruTimestamp = this.userLRU.get(userId);
    if (lruTimestamp !== undefined) {
      return lruTimestamp;
    }

    const redis = getRedisClient();
    if (redis) {
      try {
        const result = await redis.get<string>(KEYS.user(userId));
        if (result !== null) {
          const timestamp = parseInt(result, 10);
          if (!isNaN(timestamp)) {
            this.userLRU.set(userId, timestamp, 2_592_000);
            return timestamp;
          }
        }
      } catch (error) {
        recordRedisFailure(error);
      }
    }

    return null;
  }
}


--------------------------------------------------------------------------------
File: src\infrastructure\redis\simple-lru.ts
--------------------------------------------------------------------------------

export class SimpleLRU<V> {
  private readonly cache = new Map<string, { value: V; expiresAt: number }>();
  private readonly maxSize: number;

  constructor(maxSize: number) {
    this.maxSize = maxSize;
  }

  set(key: string, value: V, ttlSeconds: number): void {
    if (this.cache.size >= this.maxSize && !this.cache.has(key)) {
      const firstKey = this.cache.keys().next().value;
      if (firstKey !== undefined) {
        this.cache.delete(firstKey);
      }
    }

    this.cache.delete(key);
    this.cache.set(key, {
      value,
      expiresAt: Date.now() + ttlSeconds * 1000,
    });
  }

  get(key: string): V | undefined {
    const entry = this.cache.get(key);
    if (!entry) return undefined;

    if (Date.now() > entry.expiresAt) {
      this.cache.delete(key);
      return undefined;
    }

    this.cache.delete(key);
    this.cache.set(key, entry);
    return entry.value;
  }

  has(key: string): boolean {
    return this.get(key) !== undefined;
  }

  delete(key: string): boolean {
    return this.cache.delete(key);
  }

  get size(): number {
    return this.cache.size;
  }

  prune(): number {
    const now = Date.now();
    let pruned = 0;
    for (const [key, entry] of this.cache) {
      if (now > entry.expiresAt) {
        this.cache.delete(key);
        pruned++;
      }
    }
    return pruned;
  }
}


--------------------------------------------------------------------------------
File: src\instrumentation.ts
--------------------------------------------------------------------------------

import { createIndexes } from "@/infrastructure/database/indexes";

export async function register() {
  if (process.env.NEXT_RUNTIME === "nodejs") {
    console.log("[Instrumentation] Initializing auth service...");

    try {
      await createIndexes();
      console.log("[Instrumentation] Database indexes created successfully");

      console.log("[Instrumentation] Auth service ready");
    } catch (error) {
      console.error(
        "[Instrumentation] Failed to initialize:",
        error instanceof Error ? error.message : "Unknown error"
      );
    }
  }
}


--------------------------------------------------------------------------------
File: src\presentation\helpers\cookies.ts
--------------------------------------------------------------------------------

import { NextResponse } from "next/server";
import { env } from "@/env";

const IS_PRODUCTION = env.NODE_ENV === "production";

const BASE_COOKIE_CONFIG = {
  httpOnly: true,
  secure: IS_PRODUCTION,
  sameSite: "lax" as const,
  domain: IS_PRODUCTION ? ".ankurhalder.com" : undefined,
  path: "/",
};

const ACCESS_TOKEN_COOKIE = "accessToken";
const REFRESH_TOKEN_COOKIE = "refreshToken";

export function setAuthCookies(
  res: NextResponse,
  accessToken: string,
  refreshToken: string,
  rememberMe: boolean = false
): NextResponse {
  res.cookies.set(ACCESS_TOKEN_COOKIE, accessToken, {
    ...BASE_COOKIE_CONFIG,
    maxAge: 15 * 60,
  });

  res.cookies.set(REFRESH_TOKEN_COOKIE, refreshToken, {
    ...BASE_COOKIE_CONFIG,
    maxAge: rememberMe ? 30 * 24 * 60 * 60 : 7 * 24 * 60 * 60,
  });

  return res;
}

export function clearAuthCookies(res: NextResponse): NextResponse {
  res.cookies.set(ACCESS_TOKEN_COOKIE, "", {
    ...BASE_COOKIE_CONFIG,
    maxAge: 0,
  });

  res.cookies.set(REFRESH_TOKEN_COOKIE, "", {
    ...BASE_COOKIE_CONFIG,
    maxAge: 0,
  });

  return res;
}


--------------------------------------------------------------------------------
File: src\presentation\helpers\request-context.ts
--------------------------------------------------------------------------------

import { NextRequest } from "next/server";
import { v4 as uuidv4 } from "uuid";
import type { RequestContext } from "@app/dtos/auth.dto";

export function getClientIp(req: NextRequest): string {
  const forwardedFor = req.headers.get("x-forwarded-for");
  if (forwardedFor) {
    return forwardedFor.split(",")[0]?.trim() ?? "unknown";
  }

  const realIp = req.headers.get("x-real-ip");
  if (realIp) {
    return realIp.trim();
  }

  return "unknown";
}

export function getUserAgent(req: NextRequest): string {
  return req.headers.get("user-agent") ?? "unknown";
}

export function generateRequestId(): string {
  return uuidv4();
}

export function buildRequestContext(req: NextRequest): RequestContext {
  return {
    requestId: generateRequestId(),
    ipAddress: getClientIp(req),
    userAgent: getUserAgent(req),
  };
}


--------------------------------------------------------------------------------
File: src\presentation\helpers\response.ts
--------------------------------------------------------------------------------

import { NextResponse } from "next/server";
import { AuthenticationError } from "@domain/errors/authentication.error";
import { AuthorizationError } from "@domain/errors/authorization.error";
import { ValidationError } from "@domain/errors/validation.error";
import { ConflictError } from "@domain/errors/conflict.error";
import { NotFoundError } from "@domain/errors/not-found.error";
import { RateLimitError } from "@domain/errors/rate-limit.error";
import { TokenError } from "@domain/errors/token.error";

export function successResponse<T>(
  data: T,
  status: number = 200
): NextResponse {
  return NextResponse.json(data, { status });
}

export function errorResponse(
  error: Error | string,
  requestIdOrCode: string,
  requestId?: string,
  status?: number,
  details?: unknown
): NextResponse {
  if (error instanceof Error) {
    return handleDomainError(error, requestIdOrCode);
  }

  const errorMessage = error;
  const code = requestIdOrCode;
  const reqId = requestId || "unknown";
  const statusCode = status || 500;

  const body: Record<string, unknown> = {
    error: errorMessage,
    code,
    requestId: reqId,
  };
  if (details) body.details = details;

  return NextResponse.json(body, { status: statusCode });
}

export function mapDomainErrorToHttp(error: Error): [number, string] {
  if (error instanceof AuthenticationError) {
    return [401, "AUTHENTICATION_ERROR"];
  }

  if (error instanceof AuthorizationError) {
    return [403, "AUTHORIZATION_ERROR"];
  }

  if (error instanceof ValidationError) {
    return [400, "VALIDATION_ERROR"];
  }

  if (error instanceof ConflictError) {
    return [409, "CONFLICT_ERROR"];
  }

  if (error instanceof NotFoundError) {
    return [404, "NOT_FOUND_ERROR"];
  }

  if (error instanceof RateLimitError) {
    return [429, "RATE_LIMIT_ERROR"];
  }

  if (error instanceof TokenError) {
    return [401, "TOKEN_ERROR"];
  }

  return [500, "INTERNAL_ERROR"];
}

export function handleDomainError(
  error: Error,
  requestId: string
): NextResponse {
  const [status, code] = mapDomainErrorToHttp(error);

  if (status === 500) {
    console.error(`[${requestId}] Internal error:`, error);
  }

  return errorResponse(error.message, code, requestId, status);
}


--------------------------------------------------------------------------------
File: src\presentation\middleware\auth.ts
--------------------------------------------------------------------------------

import { type NextRequest } from "next/server";
import { JwtServiceImpl } from "@/infrastructure/crypto/jwt.service";
import { UserRepositoryImpl } from "@/infrastructure/database/user.repository.impl";
import { RevocationStoreImpl } from "@/infrastructure/redis/revocation.store.impl";
import { AuthenticationError } from "@/domain/errors/authentication.error";
import { AuthorizationError } from "@/domain/errors/authorization.error";
import { errorResponse } from "@/presentation/helpers/response";
import { buildRequestContext } from "@/presentation/helpers/request-context";

type RouteHandler = (
  request: NextRequest,
  context: { userId: string }
) => Promise<Response>;

export type AuthLevel = "user" | "admin";

const ROLE_HIERARCHY: Record<string, number> = {
  user: 1,
  admin: 2,
};

export function withAuth(requiredLevel: AuthLevel = "user") {
  return function (
    handler: RouteHandler
  ): (request: NextRequest) => Promise<Response> {
    return async (request: NextRequest): Promise<Response> => {
      const context = buildRequestContext(request);

      try {
        const authHeader = request.headers.get("authorization");
        if (!authHeader || !authHeader.startsWith("Bearer ")) {
          throw new AuthenticationError(
            "Missing or invalid authorization header"
          );
        }

        const token = authHeader.substring(7);

        const jwtService = new JwtServiceImpl();
        const payload = await jwtService.verifyAccessToken(token);

        if (
          !payload ||
          !payload.sub ||
          !payload.jti ||
          typeof payload.tv !== "number"
        ) {
          throw new AuthenticationError("Invalid token structure");
        }

        const revocationStore = new RevocationStoreImpl();
        const isRevoked = await revocationStore.isTokenRevoked(payload.jti);
        if (isRevoked) {
          throw new AuthenticationError("Token has been revoked");
        }

        const userRepository = new UserRepositoryImpl();
        const user = await userRepository.findById(payload.sub);

        if (!user) {
          throw new AuthenticationError("User not found");
        }

        if (user.tokenVersion !== payload.tv) {
          throw new AuthenticationError("Token version mismatch");
        }

        const userRoleLevel = ROLE_HIERARCHY[user.role] || 0;
        const requiredRoleLevel = ROLE_HIERARCHY[requiredLevel] || 0;

        if (userRoleLevel < requiredRoleLevel) {
          throw new AuthorizationError(
            `Insufficient permissions. Required: ${requiredLevel}`
          );
        }

        return handler(request, { userId: user.id });
      } catch (error) {
        if (
          error instanceof AuthenticationError ||
          error instanceof AuthorizationError
        ) {
          return errorResponse(error, context.requestId);
        }
        throw error;
      }
    };
  };
}


--------------------------------------------------------------------------------
File: src\presentation\middleware\cors.ts
--------------------------------------------------------------------------------

import { type NextRequest, NextResponse } from "next/server";
import { env } from "@/env";

type RouteHandler = (request: NextRequest) => Promise<Response>;

export function withCors(handler: RouteHandler): RouteHandler {
  return async (request: NextRequest): Promise<Response> => {
    const origin = request.headers.get("origin");
    const allowedOrigins = env.ALLOWED_ORIGINS;

    const isAllowed = origin && allowedOrigins.includes(origin);

    if (request.method === "OPTIONS") {
      if (!isAllowed) {
        return new NextResponse(null, { status: 403 });
      }

      return new NextResponse(null, {
        status: 204,
        headers: {
          "Access-Control-Allow-Origin": origin,
          "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
          "Access-Control-Allow-Headers":
            "Content-Type, Authorization, X-CSRF-Token",
          "Access-Control-Allow-Credentials": "true",
          "Access-Control-Max-Age": "86400",
        },
      });
    }

    const response = await handler(request);

    if (isAllowed) {
      response.headers.set("Access-Control-Allow-Origin", origin);
      response.headers.set("Access-Control-Allow-Credentials", "true");
      response.headers.set("Vary", "Origin");
    }

    return response;
  };
}


--------------------------------------------------------------------------------
File: src\presentation\middleware\csrf.ts
--------------------------------------------------------------------------------

import { type NextRequest } from "next/server";
import { timingSafeEqual } from "crypto";
import { AuthenticationError } from "@/domain/errors/authentication.error";
import { errorResponse } from "@/presentation/helpers/response";
import { buildRequestContext } from "@/presentation/helpers/request-context";

type RouteHandler = (request: NextRequest) => Promise<Response>;

export function withCsrf(handler: RouteHandler): RouteHandler {
  return async (request: NextRequest): Promise<Response> => {
    const context = buildRequestContext(request);

    try {
      if (["GET", "HEAD", "OPTIONS"].includes(request.method)) {
        return handler(request);
      }

      const tokenFromHeader = request.headers.get("x-csrf-token");
      const tokenFromCookie = request.cookies.get("csrf-token")?.value;

      if (!tokenFromHeader || !tokenFromCookie) {
        throw new AuthenticationError("CSRF token missing");
      }

      const headerBuffer = Buffer.from(tokenFromHeader, "utf8");
      const cookieBuffer = Buffer.from(tokenFromCookie, "utf8");

      if (
        headerBuffer.length !== cookieBuffer.length ||
        !timingSafeEqual(headerBuffer, cookieBuffer)
      ) {
        throw new AuthenticationError("CSRF token invalid");
      }

      return handler(request);
    } catch (error) {
      if (error instanceof AuthenticationError) {
        return errorResponse(error, context.requestId);
      }
      throw error;
    }
  };
}


--------------------------------------------------------------------------------
File: src\presentation\middleware\rate-limit.ts
--------------------------------------------------------------------------------

import { type NextRequest } from "next/server";
import { Ratelimit } from "@upstash/ratelimit";
import { getRedisClient } from "@/infrastructure/redis/client";
import { RateLimitError } from "@/domain/errors/rate-limit.error";
import { errorResponse } from "@/presentation/helpers/response";
import { buildRequestContext } from "@/presentation/helpers/request-context";

type RouteHandler = (request: NextRequest) => Promise<Response>;

function getClientIp(request: NextRequest): string {
  return (
    request.headers.get("x-forwarded-for")?.split(",")[0]?.trim() ||
    request.headers.get("x-real-ip") ||
    "unknown"
  );
}

export function withRateLimit(maxRequests: number, windowSeconds: number) {
  return function (handler: RouteHandler): RouteHandler {
    const redis = getRedisClient();

    if (!redis) {
      console.warn("[RateLimit] Redis unavailable, skipping rate limit");
      return handler;
    }

    const limiter = new Ratelimit({
      redis,
      limiter: Ratelimit.slidingWindow(maxRequests, `${windowSeconds}s`),
      prefix: "ratelimit",
      analytics: true,
    });

    return async (request: NextRequest): Promise<Response> => {
      const context = buildRequestContext(request);
      const clientIp = getClientIp(request);

      try {
        const { success, limit, remaining, reset } =
          await limiter.limit(clientIp);

        if (!success) {
          const retryAfter = Math.ceil((reset - Date.now()) / 1000);
          throw new RateLimitError(retryAfter);
        }

        const response = await handler(request);

        response.headers.set("X-RateLimit-Limit", limit.toString());
        response.headers.set("X-RateLimit-Remaining", remaining.toString());
        response.headers.set("X-RateLimit-Reset", reset.toString());

        return response;
      } catch (error) {
        if (error instanceof RateLimitError) {
          return errorResponse(error, context.requestId);
        }
        throw error;
      }
    };
  };
}


--------------------------------------------------------------------------------
File: src\presentation\validation\schemas.ts
--------------------------------------------------------------------------------

import { z } from "zod";

export const SignupSchema = z.object({
  email: z.string().email("Invalid email format").max(254).trim().toLowerCase(),
  password: z
    .string()
    .min(8, "Password must be at least 8 characters")
    .max(128, "Password must not exceed 128 characters"),
  name: z.string().max(100).optional(),
});

export const SigninSchema = z.object({
  email: z.string().email("Invalid email format").max(254).trim().toLowerCase(),
  password: z.string().min(1, "Password is required").max(128),
  rememberMe: z.boolean().optional().default(false),
});

export const VerifyOtpSchema = z.object({
  email: z.string().email("Invalid email format").max(254).trim().toLowerCase(),
  otp: z
    .string()
    .length(8, "OTP must be exactly 8 digits")
    .regex(/^\d{8}$/, "OTP must contain only digits"),
});

export const VerifyEmailSchema = z.object({
  token: z
    .string()
    .length(64, "Verification token must be 64 characters")
    .regex(/^[a-f0-9]{64}$/, "Invalid verification token format"),
});

export const ForgotPasswordSchema = z.object({
  email: z.string().email("Invalid email format").max(254).trim().toLowerCase(),
});

export const ResetPasswordSchema = z.object({
  token: z
    .string()
    .length(64, "Reset token must be 64 characters")
    .regex(/^[a-f0-9]{64}$/, "Invalid reset token format"),
  newPassword: z
    .string()
    .min(8, "Password must be at least 8 characters")
    .max(128, "Password must not exceed 128 characters"),
});

export const ResendVerificationSchema = z.object({
  email: z.string().email("Invalid email format").max(254).trim().toLowerCase(),
});

export const ContactFormSchema = z.object({
  email: z.string().email("Invalid email format").max(254).trim(),
  name: z
    .string()
    .min(1, "Name is required")
    .max(100, "Name must not exceed 100 characters")
    .trim(),
  subject: z
    .string()
    .min(1, "Subject is required")
    .max(200, "Subject must not exceed 200 characters")
    .trim(),
  message: z
    .string()
    .min(1, "Message is required")
    .max(5000, "Message must not exceed 5000 characters")
    .trim(),
});


--------------------------------------------------------------------------------
File: tsconfig.json
--------------------------------------------------------------------------------

{
  "compilerOptions": {
    /* Language & Environment */
    "target": "ES2022",
    "lib": ["ES2022"],
    "module": "ESNext",
    "moduleResolution": "bundler",
    "jsx": "react-jsx",
    /* Strict Mode */
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "forceConsistentCasingInFileNames": true,
    "exactOptionalPropertyTypes": false,
    /* Emit */
    "noEmit": true,
    "incremental": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    /* Path Aliases - Layer Boundaries */
    "baseUrl": ".",
    "paths": {
      "@domain/*": ["src/domain/*"],
      "@app/*": ["src/application/*"],
      "@infra/*": ["src/infrastructure/*"],
      "@presentation/*": ["src/presentation/*"],
      "@/*": ["src/*"]
    },
    /* Next.js */
    "plugins": [
      {
        "name": "next"
      }
    ],
    "allowJs": true
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts"
  ],
  "exclude": ["node_modules", ".next"]
}


--------------------------------------------------------------------------------
File: vercel.json
--------------------------------------------------------------------------------

{
  "redirects": [
    {
      "source": "/",
      "destination": "/api/health",
      "permanent": false
    }
  ],
  "headers": [
    {
      "source": "/api/:path*",
      "headers": [
        {
          "key": "X-Content-Type-Options",
          "value": "nosniff"
        },
        {
          "key": "X-Frame-Options",
          "value": "DENY"
        },
        {
          "key": "X-XSS-Protection",
          "value": "1; mode=block"
        },
        {
          "key": "Referrer-Policy",
          "value": "strict-origin-when-cross-origin"
        },
        {
          "key": "Permissions-Policy",
          "value": "geolocation=(), microphone=(), camera=()"
        },
        {
          "key": "Strict-Transport-Security",
          "value": "max-age=31536000; includeSubDomains"
        }
      ]
    }
  ]
}


================================================================================
END OF CODEBASE
================================================================================
